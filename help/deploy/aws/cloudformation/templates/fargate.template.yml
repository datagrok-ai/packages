---
AWSTemplateFormatVersion: '2010-09-09'
Description: "Datagrok template to deploy all components to ECS Fargate in new VPC"
#Transform: AWS::LanguageExtensions
Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: "Network configuration"
        Parameters:
          - CIDR
          - InternetIngressAccess
          - InternetSubnetAllow
          - InternetEgressAccess
    ParameterLabels:
      CIDR:
        default: "CIDR: VPC CIDR"
      InternetIngressAccess:
        default: "InternetIngressAccess: Access from internet"
      InternetEgressAccess:
        default: "InternetEgressAccess: Access to internet"
      InternetSubnetAllow:
        default: "InternetSubnetAllow: Allow connect from CIDR"
Parameters:
  CIDR:
    Type: String
    Default: '10.0.0.0/17'
    AllowedPattern: "[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+/[0-9]+"
    Description: CIDR block for the new Datagrok VPC
  InternetIngressAccess:
    Type: String
    Default: 'true'
    AllowedValues:
      - 'true'
      - 'false'
    Description: "Do you want Datagrok to be available from internet? The exact subnet from which Datagrok will be available can be specified in 'InternetSubnetAllow: Allow connect to Datagrok from CIDR' parameter."
  InternetEgressAccess:
    Type: String
    Default: 'true'
    AllowedValues:
      - 'true'
      - 'false'
    Description: Do you want Datagrok to be able to access internet? The access will be created using NAT Gateway. Either access to the internet from Datagrok or configured proxy are required to install Datagrok packages (https://datagrok.ai/help/develop#packages).
  InternetSubnetAllow:
    Type: String
    AllowedPattern: "[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+/[0-9]+"
    Description: Subnet for access to Datagrok client endpoints. Set CIDR to 0.0.0.0/0 to allow all IP addresses access, or another CIDR range.
Conditions:
  InternetIngressAccess:
    Fn::Equals:
      - Ref: InternetIngressAccess
      - 'true'
  InternetEgressAccess:
    Fn::Equals:
      - Ref: InternetEgressAccess
      - 'true'
  CreatePublicSubnets:
    Fn::Or:
      - Condition: InternetIngressAccess
      - Condition: InternetEgressAccess
Resources:
  VPC:
    Properties:
      CidrBlock:
        Ref: CIDR
      EnableDnsHostnames: true
      EnableDnsSupport: true
      InstanceTenancy: default
      Tags:
        - Key: Name
          Value:
            Fn::Sub: "${AWS::StackName} Datagrok VPC"
        - Key: datagrok.component
          Value: common
    Type: AWS::EC2::VPC
  InternetGateway:
    Condition: CreatePublicSubnets
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
        - Key: Name
          Value:
            Fn::Sub: "${AWS::StackName} Datagrok Internet Gateway"
        - Key: datagrok.component
          Value: common
  InternetGatewayAttach:
    Condition: CreatePublicSubnets
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      InternetGatewayId:
        Ref: InternetGateway
      VpcId:
        Ref: VPC
  PublicSubnetRouteTable:
    Condition: CreatePublicSubnets
    Properties:
      Tags:
        - Key: Name
          Value:
            Fn::Sub: "${AWS::StackName} Datagrok Public Subnet Route Table"
        - Key: datagrok.component
          Value: common
      VpcId:
        Ref: VPC
    Type: AWS::EC2::RouteTable
  PublicSubnetPublicRoute:
    Condition: CreatePublicSubnets
    Type: AWS::EC2::Route
    Properties:
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId:
        Ref: InternetGateway
      RouteTableId:
        Ref: PublicSubnetRouteTable
  PublicSubnet1:
    Condition: CreatePublicSubnets
    Properties:
      CidrBlock:
        Fn::Select:
          - 0
          - Fn::Cidr:
              - Fn::GetAtt:
                  - VPC
                  - CidrBlock
              - 6
              - 6
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value:
            Fn::Sub: "${AWS::StackName} Datagrok Public Subnet 1"
        - Key: datagrok.component
          Value: common
      VpcId:
        Ref: VPC
      AvailabilityZone:
        Fn::Select:
          - 0
          - Fn::GetAZs:
              Ref: AWS::Region
    Type: AWS::EC2::Subnet
  PublicSubnetRouteAssos1:
    Condition: CreatePublicSubnets
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId:
        Ref: PublicSubnetRouteTable
      SubnetId:
        Ref: PublicSubnet1
  PublicSubnet2:
    Condition: CreatePublicSubnets
    Properties:
      CidrBlock:
        Fn::Select:
          - 1
          - Fn::Cidr:
              - Fn::GetAtt:
                  - VPC
                  - CidrBlock
              - 6
              - 6
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value:
            Fn::Sub: "${AWS::StackName} Datagrok Public Subnet 2"
        - Key: datagrok.component
          Value: common
      VpcId:
        Ref: VPC
      AvailabilityZone:
        Fn::Select:
          - 1
          - Fn::GetAZs:
              Ref: AWS::Region
    Type: AWS::EC2::Subnet
  PublicSubnetRouteAssos2:
    Condition: CreatePublicSubnets
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId:
        Ref: PublicSubnetRouteTable
      SubnetId:
        Ref: PublicSubnet2
  NatGatewayEIP:
    Condition: InternetEgressAccess
    Type: AWS::EC2::EIP
    Properties:
      Domain: vpc
      Tags:
        - Key: Name
          Value:
            Fn::Sub: "${AWS::StackName} Datagrok Nat Gateway EIP"
        - Key: datagrok.component
          Value: common
  NatGateway:
    Condition: InternetEgressAccess
    Type: AWS::EC2::NatGateway
    Properties:
      AllocationId:
        Fn::GetAtt:
          - NatGatewayEIP
          - AllocationId
      ConnectivityType: public
      SubnetId:
        Ref: PublicSubnet1
      Tags:
        - Key: Name
          Value:
            Fn::Sub: "${AWS::StackName} Datagrok Nat Gateway"
        - Key: datagrok.component
          Value: common
  PrivateSubnetRouteTable:
    Properties:
      Tags:
        - Key: Name
          Value:
            Fn::Sub: "${AWS::StackName} Datagrok Private Subnet Route Table"
        - Key: datagrok.component
          Value: common
      VpcId:
        Ref: VPC
    Type: AWS::EC2::RouteTable
  PrivateSubnetNatRoute:
    Condition: InternetEgressAccess
    Type: AWS::EC2::Route
    Properties:
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId:
        Ref: NatGateway
      RouteTableId:
        Ref: PrivateSubnetRouteTable
  PrivateSubnet1:
    Properties:
      CidrBlock:
        Fn::Select:
          - 2
          - Fn::Cidr:
              - Fn::GetAtt:
                  - VPC
                  - CidrBlock
              - 6
              - 6
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value:
            Fn::Sub: "${AWS::StackName} Datagrok Private Subnet 1"
        - Key: datagrok.component
          Value: common
      VpcId:
        Ref: VPC
      AvailabilityZone:
        Fn::Select:
          - 0
          - Fn::GetAZs:
              Ref: AWS::Region
    Type: AWS::EC2::Subnet
  PrivateSubnetRouteAssos1:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId:
        Ref: PrivateSubnetRouteTable
      SubnetId:
        Ref: PrivateSubnet1
  PrivateSubnet2:
    Properties:
      CidrBlock:
        Fn::Select:
          - 3
          - Fn::Cidr:
              - Fn::GetAtt:
                  - VPC
                  - CidrBlock
              - 6
              - 6
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value:
            Fn::Sub: "${AWS::StackName} Datagrok Private Subnet 2"
        - Key: datagrok.component
          Value: common
      VpcId:
        Ref: VPC
      AvailabilityZone:
        Fn::Select:
          - 1
          - Fn::GetAZs:
              Ref: AWS::Region
    Type: AWS::EC2::Subnet
  PrivateSubnetRouteAssos2:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId:
        Ref: PrivateSubnetRouteTable
      SubnetId:
        Ref: PrivateSubnet2
  DataSubnetRouteTable:
    Properties:
      Tags:
        - Key: Name
          Value:
            Fn::Sub: "${AWS::StackName} Datagrok Data Subnet Route Table"
        - Key: datagrok.component
          Value: rds
      VpcId:
        Ref: VPC
    Type: AWS::EC2::RouteTable
  DataSubnet1:
    Properties:
      CidrBlock:
        Fn::Select:
          - 4
          - Fn::Cidr:
              - Fn::GetAtt:
                  - VPC
                  - CidrBlock
              - 6
              - 6
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value:
            Fn::Sub: "${AWS::StackName} Datagrok Data Subnet 1"
        - Key: datagrok.component
          Value: rds
      VpcId:
        Ref: VPC
      AvailabilityZone:
        Fn::Select:
          - 0
          - Fn::GetAZs:
              Ref: AWS::Region
    Type: AWS::EC2::Subnet
  DataSubnetRouteAssos1:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId:
        Ref: DataSubnetRouteTable
      SubnetId:
        Ref: DataSubnet1
  DataSubnet2:
    Properties:
      CidrBlock:
        Fn::Select:
          - 5
          - Fn::Cidr:
              - Fn::GetAtt:
                  - VPC
                  - CidrBlock
              - 6
              - 6
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value:
            Fn::Sub: "${AWS::StackName} Datagrok Data Subnet 2"
        - Key: datagrok.component
          Value: rds
      VpcId:
        Ref: VPC
      AvailabilityZone:
        Fn::Select:
          - 1
          - Fn::GetAZs:
              Ref: AWS::Region
    Type: AWS::EC2::Subnet
  DataSubnetRouteAssos2:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId:
        Ref: DataSubnetRouteTable
      SubnetId:
        Ref: DataSubnet2
  DBSubnetGroup:
    Type: AWS::RDS::DBSubnetGroup
    Properties:
      DBSubnetGroupDescription:
        Fn::Sub: "${AWS::StackName} Datagrok DB Subnet Group"
      DBSubnetGroupName:
        Fn::Sub: "${AWS::StackName}-datagrok-rds-subnet"
      SubnetIds:
        - Ref: DataSubnet1
        - Ref: DataSubnet2
      Tags:
        - Key: datagrok.component
          Value: rds
  DBSecurityGroup:
    Properties:
      GroupDescription:
        Fn::Sub: "${AWS::StackName} Datagrok DB Security Group"
      Tags:
        - Key: Name
          Value:
            Fn::Sub: "${AWS::StackName}-datagrok-rds"
        - Key: datagrok.component
          Value: datagrok
      VpcId:
        Ref: VPC
      SecurityGroupEgress: [ ]
      SecurityGroupIngress:
        - Description:
            Fn::Sub: "${AWS::StackName} Allow connection from datagrok server"
          FromPort: 5432
          ToPort: 5432
          IpProtocol: TCP
          SourceSecurityGroupId:
            Ref: DatagrokSecurityGroup
    Type: AWS::EC2::SecurityGroup
  CvmSecurityGroup:
    Properties:
      GroupDescription:
        Fn::Sub: "${AWS::StackName} Datagrok CVM Security Group"
      Tags:
        - Key: Name
          Value:
            Fn::Sub: "${AWS::StackName}-datagrok-cvm"
        - Key: datagrok.component
          Value: cvm
      VpcId:
        Ref: VPC
    Type: AWS::EC2::SecurityGroup
  CvmSecurityGroupInternalCommunications:
    Properties:
      Description:
        Fn::Sub: "${AWS::StackName} Allow communication within network CVM"
      GroupId:
        Ref: CvmSecurityGroup
      IpProtocol: "-1"
      SourceSecurityGroupId:
        Ref: CvmSecurityGroup
    Type: AWS::EC2::SecurityGroupIngress
  CvmSecurityGroupCommunications:
    Properties:
      Description:
        Fn::Sub: "${AWS::StackName} Allow communication from Datagrok to CVM components"
      GroupId:
        Ref: CvmSecurityGroup
      IpProtocol: "-1"
      SourceSecurityGroupId:
        Ref: DatagrokSecurityGroup
    Type: AWS::EC2::SecurityGroupIngress
  CvmSecurityGroupALBCommunications:
    Properties:
      Description:
        Fn::Sub: "${AWS::StackName} Allow communication from ALB to CVM components"
      GroupId:
        Ref: CvmSecurityGroup
      IpProtocol: "-1"
      SourceSecurityGroupId:
        Ref: CvmALBSecurityGroup
    Type: AWS::EC2::SecurityGroupIngress
  CvmSecurityGroupALBIntCommunications:
    Properties:
      Description:
        Fn::Sub: "${AWS::StackName} Allow communication from internal ALB to CVM components"
      GroupId:
        Ref: CvmSecurityGroup
      IpProtocol: "-1"
      SourceSecurityGroupId:
        Ref: CvmALBIntSecurityGroup
    Type: AWS::EC2::SecurityGroupIngress
  CvmALBSecurityGroup:
    Properties:
      GroupDescription:
        Fn::Sub: "${AWS::StackName} Datagrok CVM ALB Security Group"
      Tags:
        - Key: Name
          Value:
            Fn::Sub: "${AWS::StackName}-datagrok-cvm-alb"
        - Key: datagrok.component
          Value: cvm
      VpcId:
        Ref: VPC
    Type: AWS::EC2::SecurityGroup
  CvmALBIntSecurityGroup:
    Properties:
      GroupDescription:
        Fn::Sub: "${AWS::StackName} Datagrok CVM ALB Internal Security Group"
      Tags:
        - Key: Name
          Value:
            Fn::Sub: "${AWS::StackName}-datagrok-cvm-alb-int"
        - Key: datagrok.component
          Value: cvm
      VpcId:
        Ref: VPC
      SecurityGroupIngress:
        - Description:
            Fn::Sub: "${AWS::StackName} Allow internal connections from Datagrok to CVM"
          FromPort: 8090
          ToPort: 8090
          IpProtocol: TCP
          SourceSecurityGroupId:
            Ref: DatagrokSecurityGroup
        - Description:
            Fn::Sub: "${AWS::StackName} Allow internal connections to HTTP"
          FromPort: 80
          ToPort: 80
          IpProtocol: TCP
          SourceSecurityGroupId:
            Ref: DatagrokSecurityGroup
        - Description:
            Fn::Sub: "${AWS::StackName} Allow internal connections from Datagrok to H2O"
          FromPort: 54321
          ToPort: 54321
          IpProtocol: TCP
          SourceSecurityGroupId:
            Ref: DatagrokSecurityGroup
        - Description: "${AWS::StackName} Allow internal connections from Datagrok to H2O GH"
          FromPort: 5005
          ToPort: 5005
          IpProtocol: TCP
          SourceSecurityGroupId:
            Ref: DatagrokSecurityGroup
      SecurityGroupEgress:
        - Description:
            Fn::Sub: "${AWS::StackName} CVM egress rules"
          DestinationSecurityGroupId:
            Ref: CvmSecurityGroup
          FromPort: 0
          ToPort: 65535
          IpProtocol: TCP
    Type: AWS::EC2::SecurityGroup
  CvmEgress:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      Description:
        Fn::Sub: "${AWS::StackName} CVM egress rules"
      DestinationSecurityGroupId:
        Ref: CvmSecurityGroup
      FromPort: 0
      GroupId:
        Ref: CvmALBSecurityGroup
      IpProtocol: TCP
      ToPort: 65535
  Cvm80Ingress:
    Properties:
      CidrIp:
        Ref: InternetSubnetAllow
      Description:
        Fn::Sub: "${AWS::StackName} 80/tcp on CVM ALB for JKG, JN, GC"
      FromPort: 80
      GroupId:
        Ref: CvmALBSecurityGroup
      IpProtocol: TCP
      ToPort: 80
    Type: AWS::EC2::SecurityGroupIngress
  Cvm443Ingress:
    Properties:
      CidrIp:
        Ref: InternetSubnetAllow
      Description:
        Fn::Sub: "${AWS::StackName} 443/tcp on CVM ALB for JKG, JN, GC"
      FromPort: 443
      GroupId:
        Ref: CvmALBSecurityGroup
      IpProtocol: TCP
      ToPort: 443
    Type: AWS::EC2::SecurityGroupIngress
  Cvm5005Ingress:
    Properties:
      CidrIp:
        Ref: InternetSubnetAllow
      Description:
        Fn::Sub: "${AWS::StackName} 5005/tcp on CVM ALB for H2O GH"
      FromPort: 5005
      GroupId:
        Ref: CvmALBSecurityGroup
      IpProtocol: TCP
      ToPort: 5005
    Type: AWS::EC2::SecurityGroupIngress
  Cvm54321Ingress:
    Properties:
      CidrIp:
        Ref: InternetSubnetAllow
      Description:
        Fn::Sub: "${AWS::StackName} 54321/tcp on CVM ALB for H2O"
      FromPort: 54321
      GroupId:
        Ref: CvmALBSecurityGroup
      IpProtocol: TCP
      ToPort: 54321
    Type: AWS::EC2::SecurityGroupIngress
  Cvm80IngressVPC:
    Properties:
      CidrIp:
        Ref: CIDR
      Description:
        Fn::Sub: "${AWS::StackName} VPC 80/tcp on CVM ALB for JKG, JN, GC"
      FromPort: 80
      GroupId:
        Ref: CvmALBSecurityGroup
      IpProtocol: TCP
      ToPort: 80
    Type: AWS::EC2::SecurityGroupIngress
  Cvm443IngressVPC:
    Properties:
      CidrIp:
        Ref: CIDR
      Description:
        Fn::Sub: "${AWS::StackName} VPC 443/tcp on CVM ALB for JKG, JN, GC"
      FromPort: 443
      GroupId:
        Ref: CvmALBSecurityGroup
      IpProtocol: TCP
      ToPort: 443
    Type: AWS::EC2::SecurityGroupIngress
  Cvm5005IngressVPC:
    Properties:
      CidrIp:
        Ref: CIDR
      Description:
        Fn::Sub: "${AWS::StackName} VPC 5005/tcp on CVM ALB for H2O GH"
      FromPort: 5005
      GroupId:
        Ref: CvmALBSecurityGroup
      IpProtocol: TCP
      ToPort: 5005
    Type: AWS::EC2::SecurityGroupIngress
  Cvm54321IngressVPC:
    Properties:
      CidrIp:
        Ref: CIDR
      Description:
        Fn::Sub: "${AWS::StackName} VPC 54321/tcp on CVM ALB for H2O"
      FromPort: 54321
      GroupId:
        Ref: CvmALBSecurityGroup
      IpProtocol: TCP
      ToPort: 54321
    Type: AWS::EC2::SecurityGroupIngress
  Cvm80IngressNatGW:
    Condition: InternetEgressAccess
    Properties:
      CidrIp:
        Ref: NatGatewayEIP
      Description:
        Fn::Sub: "${AWS::StackName} NatGW 80/tcp on CVM ALB for JKG, JN, GC"
      FromPort: 80
      GroupId:
        Ref: CvmALBSecurityGroup
      IpProtocol: TCP
      ToPort: 80
    Type: AWS::EC2::SecurityGroupIngress
  Cvm443IngressNatGW:
    Condition: InternetEgressAccess
    Properties:
      CidrIp:
        Ref: NatGatewayEIP
      Description:
        Fn::Sub: "${AWS::StackName} NatGW 443/tcp on CVM ALB for JKG, JN, GC"
      FromPort: 443
      GroupId:
        Ref: CvmALBSecurityGroup
      IpProtocol: TCP
      ToPort: 443
    Type: AWS::EC2::SecurityGroupIngress
  Cvm5005IngressNatGW:
    Condition: InternetEgressAccess
    Properties:
      CidrIp:
        Ref: NatGatewayEIP
      Description:
        Fn::Sub: "${AWS::StackName} NatGW 5005/tcp on CVM ALB for H2O GH"
      FromPort: 5005
      GroupId:
        Ref: CvmALBSecurityGroup
      IpProtocol: TCP
      ToPort: 5005
    Type: AWS::EC2::SecurityGroupIngress
  Cvm54321IngressNatGW:
    Condition: InternetEgressAccess
    Properties:
      CidrIp:
        Ref: NatGatewayEIP
      Description:
        Fn::Sub: "${AWS::StackName} NatGW 54321/tcp on CVM ALB for H2O"
      FromPort: 54321
      GroupId:
        Ref: CvmALBSecurityGroup
      IpProtocol: TCP
      ToPort: 54321
    Type: AWS::EC2::SecurityGroupIngress

  DatagrokSecurityGroup:
    Properties:
      GroupDescription:
        Fn::Sub: "${AWS::StackName} Datagrok Security Group"
      Tags:
        - Key: Name
          Value:
            Fn::Sub: "${AWS::StackName}-datagrok"
        - Key: datagrok.component
          Value: datagrok
      VpcId:
        Ref: VPC
    Type: AWS::EC2::SecurityGroup
  ALBSecurityGroup:
    Properties:
      GroupDescription:
        Fn::Sub: "${AWS::StackName} Datagrok ALB Security Group"
      Tags:
        - Key: Name
          Value:
            Fn::Sub: "${AWS::StackName}-datagrok-alb"
        - Key: datagrok.component
          Value: datagrok
      VpcId:
        Ref: VPC
    Type: AWS::EC2::SecurityGroup
  SecurityGroupInternalCommunications:
    Properties:
      Description:
        Fn::Sub: "${AWS::StackName} Allow communication within network Datagrok"
      GroupId:
        Ref: DatagrokSecurityGroup
      IpProtocol: "-1"
      SourceSecurityGroupId:
        Ref: DatagrokSecurityGroup
    Type: AWS::EC2::SecurityGroupIngress
  SecurityGroupCvmCommunications:
    Properties:
      Description:
        Fn::Sub: "${AWS::StackName} Allow communication from CVM to Datagrok components"
      GroupId:
        Ref: DatagrokSecurityGroup
      IpProtocol: "-1"
      SourceSecurityGroupId:
        Ref: CvmSecurityGroup
    Type: AWS::EC2::SecurityGroupIngress
  SecurityGroupALBCommunications:
    Properties:
      Description:
        Fn::Sub: "${AWS::StackName} Allow communication from ALB to Datagrok components"
      GroupId:
        Ref: DatagrokSecurityGroup
      IpProtocol: "-1"
      SourceSecurityGroupId:
        Ref: ALBSecurityGroup
    Type: AWS::EC2::SecurityGroupIngress
  SecurityGroupIntALBCommunications:
    Properties:
      Description:
        Fn::Sub: "${AWS::StackName} Allow communication from internal ALB to Datagrok components"
      GroupId:
        Ref: DatagrokSecurityGroup
      IpProtocol: "-1"
      SourceSecurityGroupId:
        Ref: ALBIntSecurityGroup
    Type: AWS::EC2::SecurityGroupIngress
  DatagrokEgress:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      Description:
        Fn::Sub: "${AWS::StackName} Datagrok egress rules"
      DestinationSecurityGroupId:
        Ref: DatagrokSecurityGroup
      FromPort: 0
      GroupId:
        Ref: ALBSecurityGroup
      IpProtocol: TCP
      ToPort: 65535
  Datagrok80Ingress:
    Properties:
      CidrIp:
        Ref: InternetSubnetAllow
      Description:
        Fn::Sub: "${AWS::StackName} 80/tcp on Datagrok ALB for Datagrok Server"
      FromPort: 80
      GroupId:
        Ref: ALBSecurityGroup
      IpProtocol: TCP
      ToPort: 80
    Type: AWS::EC2::SecurityGroupIngress
  Datagrok443Ingress:
    Properties:
      CidrIp:
        Ref: InternetSubnetAllow
      Description:
        Fn::Sub: "${AWS::StackName} 443/tcp on Datagrok ALB for Datagrok Server"
      FromPort: 443
      GroupId:
        Ref: ALBSecurityGroup
      IpProtocol: TCP
      ToPort: 443
    Type: AWS::EC2::SecurityGroupIngress
  Datagrok80IngressVPC:
    Properties:
      CidrIp:
        Ref: CIDR
      Description:
        Fn::Sub: "${AWS::StackName} VPC 80/tcp on Datagrok ALB for Datagrok Server"
      FromPort: 80
      GroupId:
        Ref: ALBSecurityGroup
      IpProtocol: TCP
      ToPort: 80
    Type: AWS::EC2::SecurityGroupIngress
  Datagrok443IngressVPC:
    Properties:
      CidrIp:
        Ref: CIDR
      Description:
        Fn::Sub: "${AWS::StackName} VPC 443/tcp on Datagrok ALB for Datagrok Server"
      FromPort: 443
      GroupId:
        Ref: ALBSecurityGroup
      IpProtocol: TCP
      ToPort: 443
    Type: AWS::EC2::SecurityGroupIngress
  Datagrok80IngressNatGW:
    Condition: InternetEgressAccess
    Properties:
      CidrIp:
        Ref: NatGatewayEIP
      Description:
        Fn::Sub: "${AWS::StackName} NatGW 80/tcp on Datagrok ALB for Datagrok Server"
      FromPort: 80
      GroupId:
        Ref: ALBSecurityGroup
      IpProtocol: TCP
      ToPort: 80
    Type: AWS::EC2::SecurityGroupIngress
  Datagrok443IngressNatGW:
    Condition: InternetEgressAccess
    Properties:
      CidrIp:
        Ref: NatGatewayEIP
      Description:
        Fn::Sub: "${AWS::StackName} NatGW 443/tcp on Datagrok ALB for Datagrok Server"
      FromPort: 443
      GroupId:
        Ref: ALBSecurityGroup
      IpProtocol: TCP
      ToPort: 443
    Type: AWS::EC2::SecurityGroupIngress
  ALBIntSecurityGroup:
    Properties:
      GroupDescription:
        Fn::Sub: "${AWS::StackName} Datagrok ALB Internal Security Group"
      Tags:
        - Key: Name
          Value:
            Fn::Sub: "${AWS::StackName}-datagrok-alb-int"
        - Key: datagrok.component
          Value: datagrok
      VpcId:
        Ref: VPC
      SecurityGroupIngress:
        - Description:
            Fn::Sub: "${AWS::StackName} Allow internal connections from CVM to Datagrok"
          FromPort: 8080
          ToPort: 8080
          IpProtocol: TCP
          SourceSecurityGroupId:
            Ref: CvmSecurityGroup
        - Description:
            Fn::Sub: "${AWS::StackName} Allow internal connections from Datagrok to Grok Connect"
          FromPort: 1234
          ToPort: 1234
          IpProtocol: TCP
          SourceSecurityGroupId:
            Ref: DatagrokSecurityGroup
        - Description:
            Fn::Sub: "${AWS::StackName} Allow internal connections from Datagrok to Grok Spawner"
          FromPort: 8000
          ToPort: 8000
          IpProtocol: TCP
          SourceSecurityGroupId:
            Ref: DatagrokSecurityGroup
      SecurityGroupEgress:
        - Description:
            Fn::Sub: "${AWS::StackName} Datagrok egress rules"
          DestinationSecurityGroupId:
            Ref: DatagrokSecurityGroup
          FromPort: 0
          ToPort: 65535
          IpProtocol: TCP
    Type: AWS::EC2::SecurityGroup
  ECSPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      Description:
        Fn::Sub: "${AWS::StackName} Datagrok policy for ECS Services"
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Action:
              - logs:CreateLogStream
              - logs:PutLogEvents
            Effect: Allow
            Resource:
              - Fn::GetAtt:
                  - LogGroup
                  - Arn
              - Fn::Sub:
                  - "${log}:log-stream:*"
                  - log:
                      Fn::GetAtt:
                        - LogGroup
                        - Arn
          - Action:
              - ecr:GetAuthorizationToken
            Effect: Allow
            Resource: "*"
          - Action:
              - ecr:BatchCheckLayerAvailability
              - ecr:BatchGetImage
              - ecr:GetDownloadUrlForLayer
            Effect: Allow
            Resource:
              - "arn:aws:ecr:us-east-1:709825985650:repository/datagrok/*"
              - Fn::Sub: "arn:aws:ecr:${AWS::Region}:${AWS::AccountId}:repository/datagrok/*"
      ManagedPolicyName:
        Fn::Sub: "${AWS::StackName}-ECSPolicy-${AWS::Region}"
  TaskExecutionRole:
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Condition: { }
            Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
        Version: '2012-10-17'
      ManagedPolicyArns:
        - Ref: ECSPolicy
    Type: AWS::IAM::Role
  GrokComputeService:
    DependsOn:
      - CvmTCP80Listener
      - CvmTCP443Listener
      - CvmTCP8090IntListener
      - GrokComputeTCP5005ListenerRule
      - GrokComputeTCP5005IntListenerRule
    Properties:
      Cluster:
        Fn::GetAtt:
          - CvmCluster
          - Arn
      DeploymentConfiguration:
        MaximumPercent: 200
        MinimumHealthyPercent: 100
      DeploymentController:
        Type: ECS
      DesiredCount: 1
      LaunchType: "FARGATE"
      LoadBalancers:
        - ContainerName: grok_compute
          ContainerPort: 5005
          TargetGroupArn:
            Ref: GrokComputeTCP5005TargetGroup
        - ContainerName: grok_compute
          ContainerPort: 5005
          TargetGroupArn:
            Ref: GrokComputeTCP5005IntTargetGroup
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: DISABLED
          SecurityGroups:
            - Ref: CvmSecurityGroup
          Subnets:
            - Ref: PrivateSubnet1
            - Ref: PrivateSubnet2
      PlatformVersion: 1.4.0
      PropagateTags: SERVICE
      SchedulingStrategy: REPLICA
      ServiceRegistries:
        - RegistryArn:
            Fn::GetAtt:
              - GrokComputeServiceDiscoveryEntry
              - Arn
      Tags:
        - Key: Name
          Value:
            Fn::Sub: "${AWS::StackName} Datagrok CVM Grok Compute Service"
        - Key: datagrok.component
          Value: cvm
        - Key: datagrok.service
          Value: grok_compute
      TaskDefinition:
        Ref: GrokComputeTaskDefinition
    Type: AWS::ECS::Service
  GrokComputeServiceDiscoveryEntry:
    Properties:
      Description:
        Fn::Sub: "${AWS::StackName} Datagrok CVM grok_compute service discovery entry in Cloud Map"
      DnsConfig:
        DnsRecords:
          - TTL: 60
            Type: A
        RoutingPolicy: MULTIVALUE
      HealthCheckCustomConfig:
        FailureThreshold: 1
      Name: grok_compute
      NamespaceId:
        Ref: CloudMap
    Type: AWS::ServiceDiscovery::Service
  CvmTCP80Listener:
    Properties:
      DefaultActions:
        - RedirectConfig:
            Port: '443'
            Protocol: HTTPS
            StatusCode: HTTP_301
          Type: redirect
      LoadBalancerArn:
        Ref: LoadBalancerCvm
      Port: 80
      Protocol: HTTP
    Type: AWS::ElasticLoadBalancingV2::Listener
  CvmTCP8090IntListener:
    Properties:
      DefaultActions:
        - FixedResponseConfig:
            StatusCode: 204
          Type: fixed-response
      LoadBalancerArn:
        Ref: LoadBalancerIntCvm
      Port: 8090
      Protocol: HTTP
    Type: AWS::ElasticLoadBalancingV2::Listener
  CvmTCP443Listener:
    Properties:
      DefaultActions:
        - FixedResponseConfig:
            StatusCode: 204
          Type: fixed-response
      LoadBalancerArn:
        Ref: LoadBalancerCvm
      Port: 443
      Protocol: HTTPS
      Certificates:
        - CertificateArn:
            Ref: ArnSSLCertificate
    Type: AWS::ElasticLoadBalancingV2::Listener
  GrokComputeTCP5005TargetGroup:
    Properties:
      Name:
        Fn::Sub: "${AWS::StackName}-datagrok-cvm-gc"
      Port: 5005
      Protocol: HTTP
      Tags:
        - Key: datagrok.component
          Value: cvm
      TargetType: 'ip'
      VpcId:
        Ref: VPC
      HealthCheckPath: "/grok_compute/info"
      Matcher:
        HttpCode: 200
      TargetGroupAttributes:
        - Key: stickiness.enabled
          Value: true
        - Key: stickiness.type
          Value: lb_cookie
        - Key: stickiness.lb_cookie.duration_seconds
          Value: 86400
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
  GrokComputeTCP5005IntTargetGroup:
    Properties:
      Name:
        Fn::Sub: "${AWS::StackName}-datagrok-cvm-gc-i"
      Port: 5005
      Protocol: HTTP
      Tags:
        - Key: datagrok.component
          Value: cvm
      TargetType: 'ip'
      VpcId:
        Ref: VPC
      HealthCheckPath: "/grok_compute/info"
      Matcher:
        HttpCode: 200
      TargetGroupAttributes:
        - Key: stickiness.enabled
          Value: true
        - Key: stickiness.type
          Value: lb_cookie
        - Key: stickiness.lb_cookie.duration_seconds
          Value: 86400
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
  GrokComputeTaskDefinition:
    Properties:
      ContainerDefinitions:
        - Command:
            - Fn::Sub: "${AWS::Region}.compute.internal"
            - Fn::Sub: ${AWS::StackName}.datagrok.${AWS::Region}.lb.internal
            - Fn::Sub: ${AWS::StackName}.datagrok.${AWS::Region}.cm.internal
          Essential: false
          Image:
            Fn::Sub:
              - "${domain}/${repo}:${tag}"
              - domain:
                  Fn::FindInMap: [ Images, Searchdomain, domain ]
                repo:
                  Fn::FindInMap: [ Images, Searchdomain, repo ]
                tag:
                  Fn::FindInMap: [ Images, Searchdomain, version ]
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group:
                Ref: LogGroup
              awslogs-region:
                Ref: AWS::Region
              awslogs-stream-prefix: cvm
          MemoryReservation: 100
          Name: ResolvConf
        - DependsOn:
            - Condition: SUCCESS
              ContainerName: ResolvConf
          Environment:
            - Name: GROK_COMPUTE_NUM_CORES
              Value: '2'
          Essential: true
          Image:
            Fn::Sub:
              - "${domain}/${repo}:${tag}"
              - domain:
                  Fn::FindInMap: [ Images, GrokCompute, domain ]
                repo:
                  Fn::FindInMap: [ Images, GrokCompute, repo ]
                tag:
                  Ref: GrokComputeVersion
          LinuxParameters: { }
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group:
                Ref: LogGroup
              awslogs-region:
                Ref: AWS::Region
              awslogs-stream-prefix: cvm
          MemoryReservation: 1024
          Name: grok_compute
          PortMappings:
            - ContainerPort: 5005
              HostPort: 5005
              Protocol: tcp
      Cpu: '1024'
      ExecutionRoleArn:
        Fn::GetAtt:
          - TaskExecutionRole
          - Arn
      Family:
        Fn::Sub: "${AWS::StackName}-datagrok-cvm-grok_compute"
      Memory: '2048'
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - "FARGATE"
    Type: AWS::ECS::TaskDefinition
  H2oService:
    DependsOn:
      - H2oTCP5005Listener
      - H2oTCP5005IntListener
      - H2oTCP54321Listener
      - H2oTCP54321IntListener
    Properties:
      Cluster:
        Fn::GetAtt:
          - CvmCluster
          - Arn
      DeploymentConfiguration:
        MaximumPercent: 200
        MinimumHealthyPercent: 100
      DeploymentController:
        Type: ECS
      DesiredCount: 1
      LaunchType: "FARGATE"
      LoadBalancers:
        - ContainerName: h2o
          ContainerPort: 5005
          TargetGroupArn:
            Ref: H2oTCP5005TargetGroup
        - ContainerName: h2o
          ContainerPort: 54321
          TargetGroupArn:
            Ref: H2oTCP54321TargetGroup
        - ContainerName: h2o
          ContainerPort: 5005
          TargetGroupArn:
            Ref: H2oTCP5005IntTargetGroup
        - ContainerName: h2o
          ContainerPort: 54321
          TargetGroupArn:
            Ref: H2oTCP54321IntTargetGroup
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: ENABLED
          SecurityGroups:
            - Ref: CvmSecurityGroup
          Subnets:
            - Ref: PrivateSubnet1
            - Ref: PrivateSubnet2
      PlatformVersion: 1.4.0
      PropagateTags: SERVICE
      SchedulingStrategy: REPLICA
      ServiceRegistries:
        - RegistryArn:
            Fn::GetAtt:
              - H2oServiceDiscoveryEntry
              - Arn
      Tags:
        - Key: Name
          Value:
            Fn::Sub: "${AWS::StackName} Datagrok CVM H2O Service"
        - Key: datagrok.component
          Value: cvm
        - Key: datagrok.service
          Value: h2o
      TaskDefinition:
        Ref: H2oTaskDefinition
    Type: AWS::ECS::Service
  H2oServiceDiscoveryEntry:
    Properties:
      Description:
        Fn::Sub: "${AWS::StackName} Datagrok CVM h2o service discovery entry in Cloud Map"
      DnsConfig:
        DnsRecords:
          - TTL: 60
            Type: A
        RoutingPolicy: MULTIVALUE
      HealthCheckCustomConfig:
        FailureThreshold: 1
      Name: h2o
      NamespaceId:
        Ref: CloudMap
    Type: AWS::ServiceDiscovery::Service
  H2oTCP5005Listener:
    Properties:
      DefaultActions:
        - ForwardConfig:
            TargetGroups:
              - TargetGroupArn:
                  Ref: H2oTCP5005TargetGroup
          Type: forward
      LoadBalancerArn:
        Ref: LoadBalancerCvm
      Port: 5005
      Protocol: HTTPS
      Certificates:
        - CertificateArn:
            Ref: ArnSSLCertificate
    Type: AWS::ElasticLoadBalancingV2::Listener
  H2oTCP5005IntListener:
    Properties:
      DefaultActions:
        - ForwardConfig:
            TargetGroups:
              - TargetGroupArn:
                  Ref: H2oTCP5005IntTargetGroup
          Type: forward
      LoadBalancerArn:
        Ref: LoadBalancerIntCvm
      Port: 5005
      Protocol: HTTP
    Type: AWS::ElasticLoadBalancingV2::Listener
  H2oTCP5005TargetGroup:
    Properties:
      Name:
        Fn::Sub: "${AWS::StackName}-datagrok-cvm-h2o-gh"
      Port: 5005
      Protocol: HTTP
      Tags:
        - Key: datagrok.component
          Value: cvm
      TargetType: 'ip'
      VpcId:
        Ref: VPC
      HealthCheckPath: "/helper/info"
      Matcher:
        HttpCode: '200'
      TargetGroupAttributes:
        - Key: stickiness.enabled
          Value: 'true'
        - Key: stickiness.type
          Value: lb_cookie
        - Key: stickiness.lb_cookie.duration_seconds
          Value: '86400'
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
  H2oTCP5005IntTargetGroup:
    Properties:
      Name:
        Fn::Sub: "${AWS::StackName}-datagrok-cvm-h2o-gh-i"
      Port: 5005
      Protocol: HTTP
      Tags:
        - Key: datagrok.component
          Value: cvm
      TargetType: 'ip'
      VpcId:
        Ref: VPC
      HealthCheckPath: "/helper/info"
      Matcher:
        HttpCode: '200'
      TargetGroupAttributes:
        - Key: stickiness.enabled
          Value: 'true'
        - Key: stickiness.type
          Value: lb_cookie
        - Key: stickiness.lb_cookie.duration_seconds
          Value: '86400'
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
  H2oTCP54321Listener:
    Properties:
      DefaultActions:
        - ForwardConfig:
            TargetGroups:
              - TargetGroupArn:
                  Ref: H2oTCP54321TargetGroup
          Type: forward
      LoadBalancerArn:
        Ref: LoadBalancerCvm
      Port: 54321
      Protocol: HTTPS
      Certificates:
        - CertificateArn:
            Ref: ArnSSLCertificate
    Type: AWS::ElasticLoadBalancingV2::Listener
  H2oTCP54321IntListener:
    Properties:
      DefaultActions:
        - ForwardConfig:
            TargetGroups:
              - TargetGroupArn:
                  Ref: H2oTCP54321IntTargetGroup
          Type: forward
      LoadBalancerArn:
        Ref: LoadBalancerIntCvm
      Port: 54321
      Protocol: HTTP
    Type: AWS::ElasticLoadBalancingV2::Listener
  H2oTCP54321TargetGroup:
    Properties:
      Name:
        Fn::Sub: "${AWS::StackName}-datagrok-cvm-h2o"
      Port: 54321
      Protocol: HTTP
      Tags:
        - Key: datagrok.component
          Value: cvm
      TargetType: 'ip'
      VpcId:
        Ref: VPC
      HealthCheckPath: "/3/About"
      Matcher:
        HttpCode: '200'
      TargetGroupAttributes:
        - Key: stickiness.enabled
          Value: 'true'
        - Key: stickiness.type
          Value: lb_cookie
        - Key: stickiness.lb_cookie.duration_seconds
          Value: '86400'
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
  H2oTCP54321IntTargetGroup:
    Properties:
      Name:
        Fn::Sub: "${AWS::StackName}-datagrok-cvm-h2o-i"
      Port: 54321
      Protocol: HTTP
      Tags:
        - Key: datagrok.component
          Value: cvm
      TargetType: 'ip'
      VpcId:
        Ref: VPC
      HealthCheckPath: "/3/About"
      Matcher:
        HttpCode: '200'
      TargetGroupAttributes:
        - Key: stickiness.enabled
          Value: 'true'
        - Key: stickiness.type
          Value: lb_cookie
        - Key: stickiness.lb_cookie.duration_seconds
          Value: '86400'
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
  H2oTaskDefinition:
    Properties:
      ContainerDefinitions:
        - Command:
            - Fn::Sub: "${AWS::Region}.compute.internal"
            - Fn::Sub: ${AWS::StackName}.datagrok.${AWS::Region}.lb.internal
            - Fn::Sub: ${AWS::StackName}.datagrok.${AWS::Region}.cm.internal
          Essential: false
          Image:
            Fn::Sub:
              - "${domain}/${repo}:${tag}"
              - domain:
                  Fn::FindInMap: [ Images, Searchdomain, domain ]
                repo:
                  Fn::FindInMap: [ Images, Searchdomain, repo ]
                tag:
                  Fn::FindInMap: [ Images, Searchdomain, version ]
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group:
                Ref: LogGroup
              awslogs-region:
                Ref: AWS::Region
              awslogs-stream-prefix: cvm
          MemoryReservation: 100
          Name: ResolvConf
        - DependsOn:
            - Condition: SUCCESS
              ContainerName: ResolvConf
          Essential: true
          Image:
            Fn::Sub:
              - "${domain}/${repo}:${tag}"
              - domain:
                  Fn::FindInMap: [ Images, H2o, domain ]
                repo:
                  Fn::FindInMap: [ Images, H2o, repo ]
                tag:
                  Ref: H2oVersion
          LinuxParameters: { }
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group:
                Ref: LogGroup
              awslogs-region:
                Ref: AWS::Region
              awslogs-stream-prefix: cvm
          MemoryReservation: 1024
          Name: h2o
          PortMappings:
            - ContainerPort: 5005
              HostPort: 5005
              Protocol: tcp
            - ContainerPort: 54321
              HostPort: 54321
              Protocol: tcp
      Cpu: '512'
      ExecutionRoleArn:
        Fn::GetAtt:
          - TaskExecutionRole
          - Arn
      Family:
        Fn::Sub: "${AWS::StackName}-datagrok-cvm-h2o"
      Memory: '2048'
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - "FARGATE"
    Type: AWS::ECS::TaskDefinition
  JupyterKernelGatewayService:
    DependsOn:
      - CvmTCP80Listener
      - CvmTCP443Listener
      - CvmTCP8090IntListener
      - JupyterKernelGatewayTCP5005ListenerRule
      - JupyterKernelGatewayTCP5005IntListenerRule
      - JupyterKernelGatewayTCP8888ListenerRule
      - JupyterKernelGatewayTCP8888IntListenerRule
    Properties:
      Cluster:
        Fn::GetAtt:
          - CvmCluster
          - Arn
      DeploymentConfiguration:
        MaximumPercent: 200
        MinimumHealthyPercent: 100
      DeploymentController:
        Type: ECS
      DesiredCount: 1
      LaunchType: "FARGATE"
      LoadBalancers:
        - ContainerName: jupyter_kernel_gateway
          ContainerPort: 5005
          TargetGroupArn:
            Ref: JupyterKernelGatewayTCP5005TargetGroup
        - ContainerName: jupyter_kernel_gateway
          ContainerPort: 8888
          TargetGroupArn:
            Ref: JupyterKernelGatewayTCP8888TargetGroup
        - ContainerName: jupyter_kernel_gateway
          ContainerPort: 5005
          TargetGroupArn:
            Ref: JupyterKernelGatewayTCP5005IntTargetGroup
        - ContainerName: jupyter_kernel_gateway
          ContainerPort: 8888
          TargetGroupArn:
            Ref: JupyterKernelGatewayTCP8888IntTargetGroup
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: ENABLED
          SecurityGroups:
            - Ref: CvmSecurityGroup
          Subnets:
            - Ref: PrivateSubnet1
            - Ref: PrivateSubnet2
      PlatformVersion: 1.4.0
      PropagateTags: SERVICE
      SchedulingStrategy: REPLICA
      ServiceRegistries:
        - RegistryArn:
            Fn::GetAtt:
              - JupyterKernelGatewayServiceDiscoveryEntry
              - Arn
      Tags:
        - Key: datagrok.component
          Value: cvm
        - Key: datagrok.service
          Value: jupyter_kernel_gateway
      TaskDefinition:
        Ref: JupyterKernelGatewayTaskDefinition
    Type: AWS::ECS::Service
  JupyterKernelGatewayServiceDiscoveryEntry:
    Properties:
      Description:
        Fn::Sub: "${AWS::StackName} Datagrok CVM 'jupyter_kernel_gateway' service discovery entry in Cloud Map"
      DnsConfig:
        DnsRecords:
          - TTL: 60
            Type: A
        RoutingPolicy: MULTIVALUE
      HealthCheckCustomConfig:
        FailureThreshold: 1
      Name: jupyter_kernel_gateway
      NamespaceId:
        Ref: CloudMap
    Type: AWS::ServiceDiscovery::Service
  JupyterKernelGatewayTCP5005TargetGroup:
    Properties:
      Name:
        Fn::Sub: "${AWS::StackName}-datagrok-cvm-jkg-gh"
      Port: 5005
      Protocol: HTTP
      Tags:
        - Key: datagrok.component
          Value: cvm
      TargetType: 'ip'
      VpcId:
        Ref: VPC
      HealthCheckPath: "/jupyter/helper/info"
      Matcher:
        HttpCode: 200
      TargetGroupAttributes:
        - Key: stickiness.enabled
          Value: true
        - Key: stickiness.type
          Value: lb_cookie
        - Key: stickiness.lb_cookie.duration_seconds
          Value: 86400
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
  JupyterKernelGatewayTCP5005IntTargetGroup:
    Properties:
      Name:
        Fn::Sub: "${AWS::StackName}-datagrok-cvm-jkg-gh-i"
      Port: 5005
      Protocol: HTTP
      Tags:
        - Key: datagrok.component
          Value: cvm
      TargetType: 'ip'
      VpcId:
        Ref: VPC
      HealthCheckPath: "/jupyter/helper/info"
      Matcher:
        HttpCode: 200
      TargetGroupAttributes:
        - Key: stickiness.enabled
          Value: true
        - Key: stickiness.type
          Value: lb_cookie
        - Key: stickiness.lb_cookie.duration_seconds
          Value: 86400
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
  JupyterKernelGatewayTCP8888TargetGroup:
    Properties:
      Name:
        Fn::Sub: "${AWS::StackName}-datagrok-cvm-jkg"
      Port: 8888
      Protocol: HTTP
      Tags:
        - Key: com.docker.compose.project
          Value: cvm
      TargetType: 'ip'
      VpcId:
        Ref: VPC
      HealthCheckPath: "/jupyter/api/swagger.yaml"
      Matcher:
        HttpCode: 200
      TargetGroupAttributes:
        - Key: stickiness.enabled
          Value: true
        - Key: stickiness.type
          Value: lb_cookie
        - Key: stickiness.lb_cookie.duration_seconds
          Value: 86400
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
  JupyterKernelGatewayTCP8888IntTargetGroup:
    Properties:
      Name:
        Fn::Sub: "${AWS::StackName}-datagrok-cvm-jkg-i"
      Port: 8888
      Protocol: HTTP
      Tags:
        - Key: com.docker.compose.project
          Value: cvm
      TargetType: 'ip'
      VpcId:
        Ref: VPC
      HealthCheckPath: "/jupyter/api/swagger.yaml"
      Matcher:
        HttpCode: 200
      TargetGroupAttributes:
        - Key: stickiness.enabled
          Value: true
        - Key: stickiness.type
          Value: lb_cookie
        - Key: stickiness.lb_cookie.duration_seconds
          Value: 86400
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
  JupyterKernelGatewayTaskDefinition:
    Properties:
      ContainerDefinitions:
        - Command:
            - Fn::Sub: "${AWS::Region}.compute.internal"
            - Fn::Sub: ${AWS::StackName}.datagrok.${AWS::Region}.lb.internal
            - Fn::Sub: ${AWS::StackName}.datagrok.${AWS::Region}.cm.internal
          Essential: false
          Image:
            Fn::Sub:
              - "${domain}/${repo}:${tag}"
              - domain:
                  Fn::FindInMap: [ Images, Searchdomain, domain ]
                repo:
                  Fn::FindInMap: [ Images, Searchdomain, repo ]
                tag:
                  Fn::FindInMap: [ Images, Searchdomain, version ]
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group:
                Ref: LogGroup
              awslogs-region:
                Ref: AWS::Region
              awslogs-stream-prefix: cvm
          MemoryReservation: 100
          Name: ResolvConf
        - DependsOn:
            - Condition: SUCCESS
              ContainerName: ResolvConf
          Essential: true
          Image:
            Fn::Sub:
              - "${domain}/${repo}:${tag}"
              - domain:
                  Fn::FindInMap: [ Images, JKG, domain ]
                repo:
                  Fn::FindInMap: [ Images, JKG, repo ]
                tag:
                  Ref: JKGVersion
          LinuxParameters: { }
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group:
                Ref: LogGroup
              awslogs-region:
                Ref: AWS::Region
              awslogs-stream-prefix: cvm
          MemoryReservation: 2048
          Name: jupyter_kernel_gateway
          PortMappings:
            - ContainerPort: 5005
              HostPort: 5005
              Protocol: tcp
            - ContainerPort: 8888
              HostPort: 8888
              Protocol: tcp
      Cpu: '1024'
      ExecutionRoleArn:
        Fn::GetAtt:
          - TaskExecutionRole
          - Arn
      Family: datagrok-cvm-jupyter_kernel_gateway
      Memory: '3072'
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - "FARGATE"
      EphemeralStorage:
        SizeInGiB: 50
    Type: AWS::ECS::TaskDefinition
  JupyterNotebookService:
    DependsOn:
      - CvmTCP80Listener
      - CvmTCP443Listener
      - CvmTCP8090IntListener
      - JupyterNotebookTCP5005ListenerRule
      - JupyterNotebookTCP5005IntListenerRule
      - JupyterNotebookTCP8889ListenerRule
      - JupyterNotebookTCP8889IntListenerRule
    Properties:
      Cluster:
        Fn::GetAtt:
          - CvmCluster
          - Arn
      DeploymentConfiguration:
        MaximumPercent: 200
        MinimumHealthyPercent: 100
      DeploymentController:
        Type: ECS
      DesiredCount: 1
      LaunchType: "FARGATE"
      LoadBalancers:
        - ContainerName: jupyter_notebook
          ContainerPort: 5005
          TargetGroupArn:
            Ref: JupyterNotebookTCP5005TargetGroup
        - ContainerName: jupyter_notebook
          ContainerPort: 8889
          TargetGroupArn:
            Ref: JupyterNotebookTCP8889TargetGroup
        - ContainerName: jupyter_notebook
          ContainerPort: 5005
          TargetGroupArn:
            Ref: JupyterNotebookTCP5005IntTargetGroup
        - ContainerName: jupyter_notebook
          ContainerPort: 8889
          TargetGroupArn:
            Ref: JupyterNotebookTCP8889IntTargetGroup
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: ENABLED
          SecurityGroups:
            - Ref: CvmSecurityGroup
          Subnets:
            - Ref: PrivateSubnet1
            - Ref: PrivateSubnet2
      PlatformVersion: 1.4.0
      PropagateTags: SERVICE
      SchedulingStrategy: REPLICA
      ServiceRegistries:
        - RegistryArn:
            Fn::GetAtt:
              - JupyterNotebookServiceDiscoveryEntry
              - Arn
      Tags:
        - Key: datagrok.component
          Value: cvm
        - Key: datagrok.service
          Value: jupyter_notebook
      TaskDefinition:
        Ref: JupyterNotebookTaskDefinition
    Type: AWS::ECS::Service
  JupyterNotebookServiceDiscoveryEntry:
    Properties:
      Description:
        Fn::Sub: "${AWS::StackName} Datagrok CVM jupyter_notebook service discovery entry in Cloud Map"
      DnsConfig:
        DnsRecords:
          - TTL: 60
            Type: A
        RoutingPolicy: MULTIVALUE
      HealthCheckCustomConfig:
        FailureThreshold: 1
      Name: jupyter_notebook
      NamespaceId:
        Ref: CloudMap
    Type: AWS::ServiceDiscovery::Service
  JupyterNotebookTCP5005TargetGroup:
    Properties:
      Name:
        Fn::Sub: "${AWS::StackName}-datagrok-cvm-jn-gh"
      Port: 5005
      Protocol: HTTP
      Tags:
        - Key: datagrok.component
          Value: cvm
      TargetType: 'ip'
      VpcId:
        Ref: VPC
      HealthCheckPath: "/notebook/helper/info"
      Matcher:
        HttpCode: 200
      TargetGroupAttributes:
        - Key: stickiness.enabled
          Value: true
        - Key: stickiness.type
          Value: lb_cookie
        - Key: stickiness.lb_cookie.duration_seconds
          Value: 86400
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
  JupyterNotebookTCP5005IntTargetGroup:
    Properties:
      Name:
        Fn::Sub: "${AWS::StackName}-datagrok-cvm-jn-gh-i"
      Port: 5005
      Protocol: HTTP
      Tags:
        - Key: datagrok.component
          Value: cvm
      TargetType: 'ip'
      VpcId:
        Ref: VPC
      HealthCheckPath: "/notebook/helper/info"
      Matcher:
        HttpCode: 200
      TargetGroupAttributes:
        - Key: stickiness.enabled
          Value: true
        - Key: stickiness.type
          Value: lb_cookie
        - Key: stickiness.lb_cookie.duration_seconds
          Value: 86400
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
  JupyterNotebookTCP8889TargetGroup:
    Properties:
      Name:
        Fn::Sub: "${AWS::StackName}-datagrok-cvm-jn"
      Port: 8889
      Protocol: HTTP
      Tags:
        - Key: datagrok.component
          Value: cvm
      TargetType: 'ip'
      VpcId:
        Ref: VPC
      HealthCheckPath: "/notebook/api"
      Matcher:
        HttpCode: 200
      TargetGroupAttributes:
        - Key: stickiness.enabled
          Value: true
        - Key: stickiness.type
          Value: lb_cookie
        - Key: stickiness.lb_cookie.duration_seconds
          Value: 86400
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
  JupyterNotebookTCP8889IntTargetGroup:
    Properties:
      Name:
        Fn::Sub: "${AWS::StackName}-datagrok-cvm-jn-i"
      Port: 8889
      Protocol: HTTP
      Tags:
        - Key: datagrok.component
          Value: cvm
      TargetType: 'ip'
      VpcId:
        Ref: VPC
      HealthCheckPath: "/notebook/api"
      Matcher:
        HttpCode: 200
      TargetGroupAttributes:
        - Key: stickiness.enabled
          Value: true
        - Key: stickiness.type
          Value: lb_cookie
        - Key: stickiness.lb_cookie.duration_seconds
          Value: 86400
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
  JupyterNotebookTaskDefinition:
    Properties:
      ContainerDefinitions:
        - Command:
            - Fn::Sub: "${AWS::Region}.compute.internal"
            - Fn::Sub: ${AWS::StackName}.datagrok.${AWS::Region}.lb.internal
            - Fn::Sub: ${AWS::StackName}.datagrok.${AWS::Region}.cm.internal
          Essential: false
          Image:
            Fn::Sub:
              - "${domain}/${repo}:${tag}"
              - domain:
                  Fn::FindInMap: [ Images, Searchdomain, domain ]
                repo:
                  Fn::FindInMap: [ Images, Searchdomain, repo ]
                tag:
                  Fn::FindInMap: [ Images, Searchdomain, version ]
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group:
                Ref: LogGroup
              awslogs-region:
                Ref: AWS::Region
              awslogs-stream-prefix: cvm
          MemoryReservation: 100
          Name: ResolvConf
        - DependsOn:
            - Condition: SUCCESS
              ContainerName: ResolvConf
          Essential: true
          Image:
            Fn::Sub:
              - "${domain}/${repo}:${tag}"
              - domain:
                  Fn::FindInMap: [ Images, JN, domain ]
                repo:
                  Fn::FindInMap: [ Images, JN, repo ]
                tag:
                  Ref: JNVersion
          LinuxParameters: { }
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group:
                Ref: LogGroup
              awslogs-region:
                Ref: AWS::Region
              awslogs-stream-prefix: cvm
          MemoryReservation: 1024
          Name: jupyter_notebook
          PortMappings:
            - ContainerPort: 5005
              HostPort: 5005
              Protocol: tcp
            - ContainerPort: 8889
              HostPort: 8889
              Protocol: tcp
      Cpu: '512'
      ExecutionRoleArn:
        Fn::GetAtt:
          - TaskExecutionRole
          - Arn
      Family: datagrok-cvm-jupyter_notebook
      Memory: '2048'
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - "FARGATE"
    Type: AWS::ECS::TaskDefinition
  GrokComputeTCP5005ListenerRule:
    Properties:
      Actions:
        - ForwardConfig:
            TargetGroups:
              - TargetGroupArn:
                  Ref: GrokComputeTCP5005TargetGroup
          Type: forward
      Conditions:
        - Field: path-pattern
          PathPatternConfig:
            Values:
              - "/grok_compute/*"
      ListenerArn:
        Ref: CvmTCP443Listener
      Priority: 2
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
  GrokComputeTCP5005IntListenerRule:
    Properties:
      Actions:
        - ForwardConfig:
            TargetGroups:
              - TargetGroupArn:
                  Ref: GrokComputeTCP5005IntTargetGroup
          Type: forward
      Conditions:
        - Field: path-pattern
          PathPatternConfig:
            Values:
              - "/grok_compute/*"
      ListenerArn:
        Ref: CvmTCP8090IntListener
      Priority: 2
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
  JupyterKernelGatewayTCP5005ListenerRule:
    Properties:
      Actions:
        - ForwardConfig:
            TargetGroups:
              - TargetGroupArn:
                  Ref: JupyterKernelGatewayTCP5005TargetGroup
          Type: forward
      Conditions:
        - Field: path-pattern
          PathPatternConfig:
            Values:
              - "/jupyter/helper/*"
      ListenerArn:
        Ref: CvmTCP443Listener
      Priority: 3
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
  JupyterKernelGatewayTCP5005IntListenerRule:
    Properties:
      Actions:
        - ForwardConfig:
            TargetGroups:
              - TargetGroupArn:
                  Ref: JupyterKernelGatewayTCP5005IntTargetGroup
          Type: forward
      Conditions:
        - Field: path-pattern
          PathPatternConfig:
            Values:
              - "/jupyter/helper/*"
      ListenerArn:
        Ref: CvmTCP8090IntListener
      Priority: 3
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
  JupyterKernelGatewayTCP8888ListenerRule:
    Properties:
      Actions:
        - ForwardConfig:
            TargetGroups:
              - TargetGroupArn:
                  Ref: JupyterKernelGatewayTCP8888TargetGroup
          Type: forward
      Conditions:
        - Field: path-pattern
          PathPatternConfig:
            Values:
              - "/jupyter/*"
      ListenerArn:
        Ref: CvmTCP443Listener
      Priority: 4
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
  JupyterKernelGatewayTCP8888IntListenerRule:
    Properties:
      Actions:
        - ForwardConfig:
            TargetGroups:
              - TargetGroupArn:
                  Ref: JupyterKernelGatewayTCP8888IntTargetGroup
          Type: forward
      Conditions:
        - Field: path-pattern
          PathPatternConfig:
            Values:
              - "/jupyter/*"
      ListenerArn:
        Ref: CvmTCP8090IntListener
      Priority: 4
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
  JupyterNotebookTCP5005ListenerRule:
    Properties:
      Actions:
        - ForwardConfig:
            TargetGroups:
              - TargetGroupArn:
                  Ref: JupyterNotebookTCP5005TargetGroup
          Type: forward
      Conditions:
        - Field: path-pattern
          PathPatternConfig:
            Values:
              - "/notebook/helper/*"
      ListenerArn:
        Ref: CvmTCP443Listener
      Priority: 5
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
  JupyterNotebookTCP5005IntListenerRule:
    Properties:
      Actions:
        - ForwardConfig:
            TargetGroups:
              - TargetGroupArn:
                  Ref: JupyterNotebookTCP5005IntTargetGroup
          Type: forward
      Conditions:
        - Field: path-pattern
          PathPatternConfig:
            Values:
              - "/notebook/helper/*"
      ListenerArn:
        Ref: CvmTCP8090IntListener
      Priority: 5
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
  JupyterNotebookTCP8889ListenerRule:
    Properties:
      Actions:
        - ForwardConfig:
            TargetGroups:
              - TargetGroupArn:
                  Ref: JupyterNotebookTCP8889TargetGroup
          Type: forward
      Conditions:
        - Field: path-pattern
          PathPatternConfig:
            Values:
              - "/notebook/*"
      ListenerArn:
        Ref: CvmTCP443Listener
      Priority: 6
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
  JupyterNotebookTCP8889IntListenerRule:
    Properties:
      Actions:
        - ForwardConfig:
            TargetGroups:
              - TargetGroupArn:
                  Ref: JupyterNotebookTCP8889IntTargetGroup
          Type: forward
      Conditions:
        - Field: path-pattern
          PathPatternConfig:
            Values:
              - "/notebook/*"
      ListenerArn:
        Ref: CvmTCP8090IntListener
      Priority: 6
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
  CloudMap:
    Properties:
      Description: "${AWS::StackName} Service Map for Datagrok"
      Name:
        Fn::Sub: ${AWS::StackName}.datagrok.${AWS::Region}.cm.internal
      Vpc:
        Ref: VPC
    Type: AWS::ServiceDiscovery::PrivateDnsNamespace
  DatagrokInsightsLogGroup:
    Type: AWS::Logs::LogGroup
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Properties:
      LogGroupName:
        Fn::Sub:
          - "/aws/ecs/containerinsights/${cluster_name}/performance"
          - cluster_name:
              Ref: Cluster
      RetentionInDays: 7
  Cluster:
    Properties:
      ClusterName:
        Fn::Sub: "${AWS::StackName}-datagrok"
      Tags:
        - Key: datagrok.component
          Value: datagrok
      ClusterSettings:
        - Name: containerInsights
          Value: enabled
    Type: AWS::ECS::Cluster
  CvmInsightsLogGroup:
    Type: AWS::Logs::LogGroup
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Properties:
      LogGroupName:
        Fn::Sub:
          - "/aws/ecs/containerinsights/${cluster_name}/performance"
          - cluster_name:
              Ref: CvmCluster
      RetentionInDays: 1
  CvmCluster:
    Properties:
      ClusterName:
        Fn::Sub: "${AWS::StackName}-datagrok-cvm"
      Tags:
        - Key: datagrok.component
          Value: cvm
      ClusterSettings:
        - Name: containerInsights
          Value: enabled
    Type: AWS::ECS::Cluster
  DatagrokService:
    DependsOn:
      - TCP80Listener
      - TCP443Listener
      - TCP8080IntListener
      - S3
      - DB
    Properties:
      Cluster:
        Fn::GetAtt:
          - Cluster
          - Arn
      DeploymentConfiguration:
        MaximumPercent: 200
        MinimumHealthyPercent: 100
      DeploymentController:
        Type: ECS
      DesiredCount: 1
      LaunchType: "FARGATE"
      LoadBalancers:
        - ContainerName: datagrok
          ContainerPort: 8080
          TargetGroupArn:
            Ref: TCP8080TargetGroup
        - ContainerName: datagrok
          ContainerPort: 8080
          TargetGroupArn:
            Ref: TCP8080IntTargetGroup
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: ENABLED
          SecurityGroups:
            - Ref: DatagrokSecurityGroup
          Subnets:
            - Ref: PrivateSubnet1
            - Ref: PrivateSubnet2
      PlatformVersion: 1.4.0
      PropagateTags: SERVICE
      SchedulingStrategy: REPLICA
      ServiceRegistries:
        - RegistryArn:
            Fn::GetAtt:
              - ServiceDiscoveryEntry
              - Arn
      Tags:
        - Key: datagrok.component
          Value: datagrok
        - Key: datagrok.service
          Value: datagrok
      TaskDefinition:
        Ref: DatagrokTaskDefinition
    Type: AWS::ECS::Service
  ServiceDiscoveryEntry:
    Properties:
      Description:
        Fn::Sub: "${AWS::StackName} Datagrok datagrok service discovery entry in Cloud Map"
      DnsConfig:
        DnsRecords:
          - TTL: 60
            Type: A
        RoutingPolicy: MULTIVALUE
      HealthCheckCustomConfig:
        FailureThreshold: 1
      Name: datagrok
      NamespaceId:
        Ref: CloudMap
    Type: AWS::ServiceDiscovery::Service
  TCP443Listener:
    Properties:
      DefaultActions:
        - ForwardConfig:
            TargetGroups:
              - TargetGroupArn:
                  Ref: TCP8080TargetGroup
          Type: forward
      LoadBalancerArn:
        Ref: LoadBalancerDatagrok
      Port: 443
      Protocol: HTTPS
      Certificates:
        - CertificateArn:
            Ref: ArnSSLCertificate
    Type: AWS::ElasticLoadBalancingV2::Listener
  TCP8080IntListener:
    Properties:
      DefaultActions:
        - ForwardConfig:
            TargetGroups:
              - TargetGroupArn:
                  Ref: TCP8080IntTargetGroup
          Type: forward
      LoadBalancerArn:
        Ref: LoadBalancerIntDatagrok
      Port: 8080
      Protocol: HTTP
    Type: AWS::ElasticLoadBalancingV2::Listener
  TCP8080TargetGroup:
    Properties:
      Name:
        Fn::Sub: "${AWS::StackName}-datagrok"
      Port: 8080
      Protocol: HTTP
      Tags:
        - Key: datagrok.component
          Value: datagrok
      TargetType: 'ip'
      VpcId:
        Ref: VPC
      HealthCheckIntervalSeconds: 60
      HealthCheckPath: "/api/admin/health"
      Matcher:
        HttpCode: 200
      UnhealthyThresholdCount: 5
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
  TCP8080IntTargetGroup:
    Properties:
      Name:
        Fn::Sub: "${AWS::StackName}-datagrok-i"
      Port: 8080
      Protocol: HTTP
      Tags:
        - Key: datagrok.component
          Value: datagrok
      TargetType: 'ip'
      VpcId:
        Ref: VPC
      HealthCheckIntervalSeconds: 60
      HealthCheckPath: "/api/admin/health"
      Matcher:
        HttpCode: 200
      UnhealthyThresholdCount: 5
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
  TCP80Listener:
    Properties:
      DefaultActions:
        - RedirectConfig:
            Port: '443'
            Protocol: HTTPS
            StatusCode: HTTP_301
          Type: redirect
      LoadBalancerArn:
        Ref: LoadBalancerDatagrok
      Port: 80
      Protocol: HTTP
    Type: AWS::ElasticLoadBalancingV2::Listener
  GrokConnectService:
    DependsOn:
      - TCP1234IntListener
    Properties:
      Cluster:
        Fn::GetAtt:
          - Cluster
          - Arn
      DeploymentConfiguration:
        MaximumPercent: 200
        MinimumHealthyPercent: 100
      DeploymentController:
        Type: ECS
      DesiredCount: 1
      LaunchType: "FARGATE"
      LoadBalancers:
        - ContainerName: grok_connect
          ContainerPort: 1234
          TargetGroupArn:
            Ref: TCP1234IntTargetGroup
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: ENABLED
          SecurityGroups:
            - Ref: DatagrokSecurityGroup
          Subnets:
            - Ref: PrivateSubnet1
            - Ref: PrivateSubnet2
      PlatformVersion: 1.4.0
      PropagateTags: SERVICE
      SchedulingStrategy: REPLICA
      ServiceRegistries:
        - RegistryArn:
            Fn::GetAtt:
              - GrokConnectServiceDiscoveryEntry
              - Arn
      Tags:
        - Key: datagrok.component
          Value: datagrok
        - Key: datagrok.service
          Value: grok_connect
      TaskDefinition:
        Ref: GrokConnectTaskDefinition
    Type: AWS::ECS::Service
  GrokConnectServiceDiscoveryEntry:
    Properties:
      Description:
        Fn::Sub: "${AWS::StackName} Datagrok grok_connect service discovery entry in Cloud Map"
      DnsConfig:
        DnsRecords:
          - TTL: 60
            Type: A
        RoutingPolicy: MULTIVALUE
      HealthCheckCustomConfig:
        FailureThreshold: 1
      Name: grok_connect
      NamespaceId:
        Ref: CloudMap
    Type: AWS::ServiceDiscovery::Service
  GrokConnectTaskDefinition:
    Properties:
      ContainerDefinitions:
        - Command:
            - Fn::Sub: "${AWS::Region}.compute.internal"
            - Fn::Sub: ${AWS::StackName}.datagrok.${AWS::Region}.lb.internal
            - Fn::Sub: ${AWS::StackName}.datagrok.${AWS::Region}.cm.internal
          Essential: false
          Image:
            Fn::Sub:
              - "${domain}/${repo}:${tag}"
              - domain:
                  Fn::FindInMap: [ Images, Searchdomain, domain ]
                repo:
                  Fn::FindInMap: [ Images, Searchdomain, repo ]
                tag:
                  Fn::FindInMap: [ Images, Searchdomain, version ]
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group:
                Ref: LogGroup
              awslogs-region:
                Ref: AWS::Region
              awslogs-stream-prefix: grok_connect
          MemoryReservation: 100
          Name: ResolvConf
        - DependsOn:
            - Condition: SUCCESS
              ContainerName: ResolvConf
          Essential: true
          Image:
            Fn::Sub:
              - "${domain}/${repo}:${tag}"
              - domain:
                  Fn::FindInMap: [ Images, GrokConnect, domain ]
                repo:
                  Fn::FindInMap: [ Images, GrokConnect, repo ]
                tag:
                  Ref: GrokConnectVersion
          LinuxParameters: { }
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group:
                Ref: LogGroup
              awslogs-region:
                Ref: AWS::Region
              awslogs-stream-prefix: grok_connect
          MemoryReservation: 1024
          Name: grok_connect
          PortMappings:
            - ContainerPort: 1234
              HostPort: 1234
              Protocol: tcp
      Cpu: '1024'
      ExecutionRoleArn:
        Fn::GetAtt:
          - TaskExecutionRole
          - Arn
      Family: grok_connect
      Memory: '2048'
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - "FARGATE"
    Type: AWS::ECS::TaskDefinition
  TCP1234IntListener:
    Properties:
      DefaultActions:
        - ForwardConfig:
            TargetGroups:
              - TargetGroupArn:
                  Ref: TCP1234IntTargetGroup
          Type: forward
      LoadBalancerArn:
        Ref: LoadBalancerIntDatagrok
      Port: 1234
      Protocol: HTTP
    Type: AWS::ElasticLoadBalancingV2::Listener
  TCP1234IntTargetGroup:
    Properties:
      Name:
        Fn::Sub: "${AWS::StackName}-gcon-i"
      Port: 1234
      Protocol: HTTP
      Tags:
        - Key: datagrok.component
          Value: datagrok
      TargetType: 'ip'
      VpcId:
        Ref: VPC
      HealthCheckIntervalSeconds: 60
      HealthCheckPath: "/health"
      Matcher:
        HttpCode: 200
      UnhealthyThresholdCount: 5
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
  DatagrokDbUser:
    Type: AWS::SecretsManager::Secret
    Properties:
      Description: Datagrok Admin User First-login password
      GenerateSecretString:
        SecretStringTemplate: '{"user": "dg"}'
        GenerateStringKey: password
        RequireEachIncludedType: true
        PasswordLength: 32
        ExcludePunctuation: true
  DatagrokDbAdminUser:
    Type: AWS::SecretsManager::Secret
    Properties:
      Description: Datagrok Admin User First-login password
      GenerateSecretString:
        SecretStringTemplate: '{"user": "superuser"}'
        GenerateStringKey: password
        RequireEachIncludedType: true
        PasswordLength: 32
        ExcludePunctuation: true
  AdminPassword:
    Type: AWS::SecretsManager::Secret
    Properties:
      Description: Datagrok Admin user first-login password
      GenerateSecretString:
        SecretStringTemplate: '{"user": "admin"}'
        GenerateStringKey: password
        RequireEachIncludedType: true
        PasswordLength: 16
        ExcludePunctuation: true
  AdminDevKey:
    Type: AWS::SecretsManager::Secret
    Properties:
      Description: Datagrok Admin user developer key
      GenerateSecretString:
        SecretStringTemplate: '{"user": "admin"}'
        GenerateStringKey: password
        RequireEachIncludedType: true
        PasswordLength: 24
        ExcludePunctuation: true
  DB:
    Type: AWS::RDS::DBInstance
    UpdateReplacePolicy: Delete
    DeletionPolicy: Snapshot
    Properties:
      AllocatedStorage: '50'
      AllowMajorVersionUpgrade: false
      AutoMinorVersionUpgrade: true
      BackupRetentionPeriod: 3
      DBInstanceClass: db.t3.large
      DBInstanceIdentifier:
        Fn::Sub: "${AWS::StackName}-datagrok-rds"
      DBName: datagrok
      DBSubnetGroupName:
        Ref: DBSubnetGroup
      DeleteAutomatedBackups: true
      DeletionProtection: false
      Engine: postgres
      EngineVersion: '12.15'
      MasterUsername:
        Fn::Sub:
          - "{{resolve:secretsmanager:${secret}:SecretString:user}}"
          - secret:
              Ref: DatagrokDbAdminUser
      MasterUserPassword:
        Fn::Sub:
          - "{{resolve:secretsmanager:${secret}:SecretString:password}}"
          - secret:
              Ref: DatagrokDbAdminUser
      MultiAZ: false
      Port: '5432'
      PubliclyAccessible: false
      StorageEncrypted: true
      Tags:
        - Key: datagrok.component
          Value: datagrok
      VPCSecurityGroups:
        - Ref: DBSecurityGroup
      EnableIAMDatabaseAuthentication: true
  S3:
    Type: AWS::S3::Bucket
    Properties:
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - BucketKeyEnabled: true
            ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      BucketName:
        Fn::Sub:
          - "${AWS::StackName}-datagrok-s3-${uuid}"
          - uuid:
              Fn::Select:
                - 2
                - Fn::Split:
                    - "/"
                    - Ref: AWS::StackId
      ObjectLockEnabled: false
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      Tags:
        - Key: datagrok.component
          Value: datagrok
  S3VPCEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Action:
              - s3:PutObject
              - s3:GetObject
              - s3:DeleteObject
              - s3:ListBucket
            Effect: Allow
            Principal: "*"
            Condition: { }
            Resource:
              - Fn::GetAtt:
                  - S3
                  - Arn
              - Fn::Sub:
                  - "${bucket}/*"
                  - bucket:
                      Fn::GetAtt:
                        - S3
                        - Arn
              - Fn::Sub: arn:aws:s3:::amazonlinux.${AWS::Region}.amazonaws.com
              - Fn::Sub: arn:aws:s3:::amazonlinux.${AWS::Region}.amazonaws.com/*
              - Fn::Sub: arn:aws:s3:::amazonlinux-2-repos-${AWS::Region}
              - Fn::Sub: arn:aws:s3:::amazonlinux-2-repos-${AWS::Region}/*
              - Fn::Sub: arn:aws:s3:::prod-${AWS::Region}-starport-layer-bucket
              - Fn::Sub: arn:aws:s3:::prod-${AWS::Region}-starport-layer-bucket/*
              - "arn:aws:s3:::docker-images-prod"
              - "arn:aws:s3:::docker-images-prod/*"
              - "arn:aws:s3:::datagrok-data",
              - "arn:aws:s3:::datagrok-data/*"
      RouteTableIds:
        - Ref: PrivateSubnetRouteTable
      ServiceName:
        Fn::Sub: com.amazonaws.${AWS::Region}.s3
      VpcEndpointType: Gateway
      VpcId:
        Ref: VPC
  S3Policy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket:
        Ref: S3
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Action:
              - s3:PutObject
              - s3:GetObject
              - s3:DeleteObject
            Condition:
              StringNotEquals:
                aws:SourceVpce:
                  Ref: S3VPCEndpoint
                "aws:PrincipalArn":
                  - "arn:aws:iam::${AWS::AccountId}:root",
                  - Ref: S3EmptyLambdaRole
            Effect: Deny
            Principal: '*'
            Resource:
              - Fn::GetAtt:
                  - S3
                  - Arn
              - Fn::Sub:
                  - ${bucket}/*
                  - bucket:
                      Fn::GetAtt:
                        - S3
                        - Arn
          - Principal: "*"
            Action: "*"
            Effect: Deny
            Resource:
              - Fn::GetAtt:
                  - S3
                  - Arn
              - Fn::Sub:
                  - "${bucket}/*"
                  - bucket:
                      Fn::GetAtt:
                        - S3
                        - Arn
            Condition:
              Bool:
                aws:SecureTransport: false
  S3EmptyLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName:
            Fn::Sub: "${AWS::StackName}-s3-lambda"
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'logs:CreateLogStream'
                  - 'logs:PutLogEvents'
                Resource:
                  Fn::Sub: "arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/${AWS::StackName}-S3EmptyLambdaFunction-*:*"
              - Action:
                  - s3:GetObject
                  - s3:DeleteObject
                  - s3:ListBucket
                Effect: Allow
                Resource:
                  - Fn::GetAtt:
                      - S3
                      - Arn
                  - Fn::Sub:
                      - "${bucket}/*"
                      - bucket:
                          Fn::GetAtt:
                            - S3
                            - Arn
  S3EmptyLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      Description: Sets required settings for Datagrok
      Code:
        ZipFile: |
          import boto3
          import cfnresponse


          def handler(event, context):
              try:
                  bucket = event['ResourceProperties']['BucketName']
                  status = 0

                  if event['RequestType'] == 'Delete':
                      s3 = boto3.resource('s3')
                      bucket = s3.Bucket(bucket)
                      for obj in bucket.objects.filter():
                          s3.Object(bucket.name, obj.key).delete()
                      status = 201

                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {'Status': status})
              except Exception as e:
                  print(type(e).__name__, e)
                  cfnresponse.send(event, context, cfnresponse.FAILED, {'Exception': f"{type(e).__name__} {e}"})
      Handler: index.handler
      Runtime: python3.11
      Role:
        Fn::GetAtt:
          - S3EmptyLambdaRole
          - Arn
      MemorySize: 128
      Timeout: 600
      VpcConfig:
        SecurityGroupIds:
          - Ref: DatagrokSecurityGroup
        SubnetIds:
          - Ref: PrivateSubnet1
          - Ref: PrivateSubnet2
  S3EmptyLambdaFunctionLogGroup:
    Type: AWS::Logs::LogGroup
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Properties:
      LogGroupName:
        Fn::Sub:
          - "/aws/lambda/${function_name}"
          - function_name:
              Ref: S3EmptyLambdaFunction
      RetentionInDays: 1
  S3Empty:
    Type: AWS::CloudFormation::CustomResource
    DependsOn:
      - S3EmptyLambdaFunctionLogGroup
    Properties:
      BucketName:
        Ref: S3
      ServiceToken:
        Fn::GetAtt:
          - S3EmptyLambdaFunction
          - Arn
  DatagrokTaskDefinition:
    Properties:
      ContainerDefinitions:
        - Command:
            - Fn::Sub: "${AWS::Region}.compute.internal"
            - Fn::Sub: ${AWS::StackName}.datagrok.${AWS::Region}.lb.internal
            - Fn::Sub: ${AWS::StackName}.datagrok.${AWS::Region}.cm.internal
          Essential: false
          Image:
            Fn::Sub:
              - "${domain}/${repo}:${tag}"
              - domain:
                  Fn::FindInMap: [ Images, Searchdomain, domain ]
                repo:
                  Fn::FindInMap: [ Images, Searchdomain, repo ]
                tag:
                  Fn::FindInMap: [ Images, Searchdomain, version ]
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group:
                Ref: LogGroup
              awslogs-region:
                Ref: AWS::Region
              awslogs-stream-prefix: datagrok
          MemoryReservation: 100
          Name: ResolvConf
        - DependsOn:
            - Condition: SUCCESS
              ContainerName: ResolvConf
          Environment:
            - Name: GROK_MODE
              Value: auto
            - Name: GROK_PARAMETERS
              Value:
                Fn::Sub:
                  - '{ "amazonStorageRegion": "${AWS::Region}", "amazonStorageBucket": "${bucket}",
              "dbServer": "${dbServer}", "dbPort": "${dbPort}", "db": "datagrok",
              "dbLogin": "${dbLogin}", "dbPassword": "${dbPassword}", "dbAdminLogin":
              "${dbAdminLogin}", "dbAdminPassword": "${dbAdminPassword}", "dbSsl": false,
              "deployDemo": false, "deployTestDemo": false, "adminPassword": "${adminPassword}", "adminDevKey": "${adminDevKey}"
              }'
                  - bucket:
                      Ref: S3
                    dbServer:
                      Fn::GetAtt:
                        - DB
                        - Endpoint.Address
                    dbPort:
                      Fn::GetAtt:
                        - DB
                        - Endpoint.Port
                    dbLogin:
                      Fn::Sub:
                        - "{{resolve:secretsmanager:${secret}:SecretString:user}}"
                        - secret:
                            Ref: DatagrokDbUser
                    dbPassword:
                      Fn::Sub:
                        - "{{resolve:secretsmanager:${secret}:SecretString:password}}"
                        - secret:
                            Ref: DatagrokDbUser
                    dbAdminLogin:
                      Fn::Sub:
                        - "{{resolve:secretsmanager:${secret}:SecretString:user}}"
                        - secret:
                            Ref: DatagrokDbAdminUser
                    dbAdminPassword:
                      Fn::Sub:
                        - "{{resolve:secretsmanager:${secret}:SecretString:password}}"
                        - secret:
                            Ref: DatagrokDbAdminUser
                    adminPassword:
                      Fn::Sub:
                        - "{{resolve:secretsmanager:${secret}:SecretString:password}}"
                        - secret:
                            Ref: AdminPassword
                    adminDevKey:
                      Fn::Sub:
                        - "{{resolve:secretsmanager:${secret}:SecretString:password}}"
                        - secret:
                            Ref: AdminDevKey
          Essential: true
          Image:
            Fn::Sub:
              - "${domain}/${repo}:${tag}"
              - domain:
                  Fn::FindInMap: [ Images, Datagrok, domain ]
                repo:
                  Fn::FindInMap: [ Images, Datagrok, repo ]
                tag:
                  Ref: DatagrokVersion
          LinuxParameters: { }
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group:
                Ref: LogGroup
              awslogs-region:
                Ref: AWS::Region
              awslogs-stream-prefix: datagrok
          MemoryReservation: 1024
          Name: datagrok
          PortMappings:
            - ContainerPort: 8080
              HostPort: 8080
              Protocol: tcp
      Cpu: '2048'
      ExecutionRoleArn:
        Fn::GetAtt:
          - TaskExecutionRole
          - Arn
      Family: datagrok
      Memory: '4096'
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - "FARGATE"
      TaskRoleArn:
        Ref: TaskRole
    Type: AWS::ECS::TaskDefinition
  Policy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      Description:
        Fn::Sub: "${AWS::StackName} Datagrok policy to access AWS resources"
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Action:
              - s3:PutObject
              - s3:GetObject
              - s3:DeleteObject
              - s3:ListBucket
            Condition: { }
            Effect: Allow
            Resource:
              - Fn::GetAtt:
                  - S3
                  - Arn
              - Fn::Sub:
                  - "${bucket}/*"
                  - bucket:
                      Fn::GetAtt:
                        - S3
                        - Arn
      ManagedPolicyName:
        Fn::Sub: "${AWS::StackName}-S3Access-${AWS::Region}"
  TaskRole:
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Condition: { }
            Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
        Version: '2012-10-17'
      ManagedPolicyArns:
        - Ref: Policy
        - Ref: ECSPolicy
      Tags:
        - Key: datagrok.component
          Value: datagrok
        - Key: datagrok.service
          Value: datagrok
    Type: AWS::IAM::Role
  LoadBalancerDatagrok:
    Properties:
      Name:
        Fn::Sub: "${AWS::StackName}-datagrok"
      Scheme:
        'Fn::If':
          - InternetIngressAccess
          - 'internet-facing'
          - 'internal'
      SecurityGroups:
        - Ref: ALBSecurityGroup
      Subnets:
        'Fn::If':
          - InternetIngressAccess
          - - Ref: PublicSubnet1
            - Ref: PublicSubnet2
          - - Ref: PrivateSubnet1
            - Ref: PrivateSubnet2
      Tags:
        - Key: Name
          Value:
            Fn::Sub: "${AWS::StackName}-datagrok-alb"
        - Key: datagrok.component
          Value: datagrok
      Type: application
      LoadBalancerAttributes:
        - Key: routing.http.drop_invalid_header_fields.enabled
          Value: 'true'
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
  LoadBalancerCvm:
    Properties:
      Name:
        Fn::Sub: "${AWS::StackName}-datagrok-cvm"
      Scheme:
        'Fn::If':
          - InternetIngressAccess
          - 'internet-facing'
          - 'internal'
      SecurityGroups:
        - Ref: CvmALBSecurityGroup
      Subnets:
        'Fn::If':
          - InternetIngressAccess
          - - Ref: PublicSubnet1
            - Ref: PublicSubnet2
          - - Ref: PrivateSubnet1
            - Ref: PrivateSubnet2
      Tags:
        - Key: Name
          Value:
            Fn::Sub: "${AWS::StackName}-datagrok-cvm-alb"
        - Key: datagrok.component
          Value: cvm
      Type: application
      LoadBalancerAttributes:
        - Key: routing.http.drop_invalid_header_fields.enabled
          Value: 'true'
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
  LoadBalancerIntDatagrok:
    Properties:
      Name:
        Fn::Sub: "${AWS::StackName}-datagrok-int"
      Scheme: internal
      SecurityGroups:
        - Ref: ALBIntSecurityGroup
      Subnets:
        - Ref: PrivateSubnet1
        - Ref: PrivateSubnet2
      Tags:
        - Key: Name
          Value:
            Fn::Sub: "${AWS::StackName}-datagrok-alb-int"
        - Key: datagrok.component
          Value: datagrok
      Type: application
      LoadBalancerAttributes:
        - Key: routing.http.drop_invalid_header_fields.enabled
          Value: 'true'
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
  LoadBalancerIntCvm:
    Properties:
      Name:
        Fn::Sub: "${AWS::StackName}-datagrok-cvm-int"
      Scheme: internal
      SecurityGroups:
        - Ref: CvmALBIntSecurityGroup
      Subnets:
        - Ref: PrivateSubnet1
        - Ref: PrivateSubnet2
      Tags:
        - Key: Name
          Value:
            Fn::Sub: "${AWS::StackName}-datagrok-cvm-alb-int"
        - Key: datagrok.component
          Value: cvm
      Type: application
      LoadBalancerAttributes:
        - Key: routing.http.drop_invalid_header_fields.enabled
          Value: 'true'
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
  LogGroup:
    Properties:
      LogGroupName:
        Fn::Sub: "/ecs/${AWS::StackName}-datagrok-${AWS::Region}"
      RetentionInDays: 7
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Type: AWS::Logs::LogGroup
  PrivateDNSZone:
    Type: AWS::Route53::HostedZone
    Properties:
      HostedZoneConfig:
        Comment:
          Fn::Sub: "${AWS::StackName} Private Datagrok Zone for internal routing"
      Name:
        Fn::Sub: ${AWS::StackName}.datagrok.${AWS::Region}.lb.internal.
      VPCs:
        - VPCId:
            Ref: VPC
          VPCRegion:
            Ref: AWS::Region
  DatagrokPrivateDNS:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId:
        Ref: PrivateDNSZone
      Comment:
        Fn::Sub: "${AWS::StackName} Private Datagrok DNS for internal routing"
      Name:
        Fn::Sub: datagrok.${AWS::StackName}.datagrok.${AWS::Region}.lb.internal.
      Type: A
      AliasTarget:
        HostedZoneId:
          Fn::GetAtt:
            - LoadBalancerIntDatagrok
            - CanonicalHostedZoneID
        DNSName:
          Fn::GetAtt:
            - LoadBalancerIntDatagrok
            - DNSName
  CvmPrivateDNS:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId:
        Ref: PrivateDNSZone
      Comment:
        Fn::Sub: "${AWS::StackName} Private Datagrok CVM DNS for internal routing"
      Name:
        Fn::Sub: cvm.${AWS::StackName}.datagrok.${AWS::Region}.lb.internal.
      Type: A
      AliasTarget:
        HostedZoneId:
          Fn::GetAtt:
            - LoadBalancerIntCvm
            - CanonicalHostedZoneID
        DNSName:
          Fn::GetAtt:
            - LoadBalancerIntCvm
            - DNSName
  H2oPrivateDNS:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId:
        Ref: PrivateDNSZone
      Comment:
        Fn::Sub: "${AWS::StackName} Private Datagrok H2O DNS for internal routing"
      Name:
        Fn::Sub: h2o.${AWS::StackName}.datagrok.${AWS::Region}.lb.internal.
      Type: A
      AliasTarget:
        HostedZoneId:
          Fn::GetAtt:
            - LoadBalancerIntCvm
            - CanonicalHostedZoneID
        DNSName:
          Fn::GetAtt:
            - LoadBalancerIntCvm
            - DNSName
  GrokConnectPrivateDNS:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId:
        Ref: PrivateDNSZone
      Comment:
        Fn::Sub: "${AWS::StackName} Private Datagrok grok connect DNS for internal routing"
      Name:
        Fn::Sub: grok_connect.${AWS::StackName}.datagrok.${AWS::Region}.lb.internal.
      Type: A
      AliasTarget:
        HostedZoneId:
          Fn::GetAtt:
            - LoadBalancerIntDatagrok
            - CanonicalHostedZoneID
        DNSName:
          Fn::GetAtt:
            - LoadBalancerIntDatagrok
            - DNSName

  GrokSpawnerPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      Description:
        Fn::Sub: "${AWS::StackName} Grok Spawner policy to access AWS resources"
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Action:
              - ecs:ListTasks
            Condition:
              ArnEquals:
                ecs:cluster:
                  Fn::GetAtt:
                    - Cluster
                    - Arn
            Effect: Allow
            Resource: "*"
          - Action:
              - ecs:RegisterTaskDefinition
            Condition:
              StringEquals:
                aws:RequestTag/caller: [ "grok_spawner" ]
            Effect: Allow
            Resource: "*"
          - Action:
              - ecs:DescribeTaskDefinition
            Condition: { }
            Effect: Allow
            Resource: "*"
          - Action:
              - "ecs:DescribeServices"
              - "ecs:UpdateService"
            Condition:
              ArnEquals:
                ecs:cluster:
                  Fn::GetAtt:
                    - Cluster
                    - Arn
            Effect: Allow
            Resource:
              Fn::Sub:
                - "arn:aws:ecs:${AWS::Region}:${AWS::AccountId}:service/${cluster_name}/*"
                - cluster_name:
                    Ref: Cluster
          - Action:
              - "ecs:CreateService"
            Condition:
              StringEquals:
                aws:RequestTag/caller: [ "grok_spawner" ]
              ArnEquals:
                ecs:cluster:
                  Fn::GetAtt:
                    - Cluster
                    - Arn
            Effect: Allow
            Resource:
              Fn::Sub:
                - "arn:aws:ecs:${AWS::Region}:${AWS::AccountId}:service/${cluster_name}/*"
                - cluster_name:
                    Ref: Cluster
          - Action:
              - "ecs:DescribeTasks"
            Condition:
              ArnEquals:
                ecs:cluster:
                  Fn::GetAtt:
                    - Cluster
                    - Arn
            Effect: Allow
            Resource:
              Fn::Sub:
                - "arn:aws:ecs:${AWS::Region}:${AWS::AccountId}:task/${cluster_name}/*"
                - cluster_name:
                    Ref: Cluster
          - Action:
              - "logs:GetLogEvents"
            Effect: Allow
            Resource:
              Fn::Sub:
                - "${log_group}:log-stream:grok_spawner/*"
                - log_group:
                    Fn::GetAtt:
                      - LogGroup
                      - Arn
      ManagedPolicyName:
        Fn::Sub: "${AWS::StackName}-GrokSpawner-${AWS::Region}"
  GrokSpawnerECRPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      Description:
        Fn::Sub: "${AWS::StackName} Grok Spawner ECR policy to access AWS resources"
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Action:
              - ecr:GetAuthorizationToken
            Effect: Allow
            Resource: "*"
          - Action:
              - ecr:CreateRepository
            Condition:
              StringEquals:
                aws:RequestTag/builder: [ "grok_spawner" ]
            Effect: Allow
            Resource: "*"
          - Action:
              - ecr:TagResource
            Condition:
              StringEquals:
                aws:RequestTag/builder: [ "grok_spawner" ]
            Effect: Allow
            Resource:
              Fn::Sub: "arn:aws:ecr:${AWS::Region}:${AWS::AccountId}:repository/datagrok/*"
          - Action:
              - "ecr:DescribeRepositories"
              - "ecr:ListImages"
            Effect: Allow
            Resource:
              Fn::Sub: "arn:aws:ecr:${AWS::Region}:${AWS::AccountId}:repository/datagrok/*"
      ManagedPolicyName:
        Fn::Sub: "${AWS::StackName}-GrokSpawner-ECR-${AWS::Region}"
  GrokSpawnerKanikoPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      Description:
        Fn::Sub: "${AWS::StackName} Grok Spawner ECR policy to access AWS resources"
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Action:
              - ecs:RunTask
            Effect: Allow
            Condition:
              ArnEquals:
                ecs:cluster:
                  Fn::GetAtt:
                    - Cluster
                    - Arn
            Resource:
              Ref: KanikoTaskDefinition
          - Action:
              - iam:PassRole
            Effect: Allow
            Resource:
              - Fn::GetAtt:
                  - KanikoTaskRole
                  - Arn
              - Fn::GetAtt:
                  - TaskExecutionRole
                  - Arn
          - Action:
              - s3:GetObject
              - s3:PutObject
              - s3:ListBucket
            Effect: Allow
            Resource:
              - Fn::GetAtt:
                  - S3
                  - Arn
              - Fn::Sub:
                  - "${bucket}/dockerfiles/*"
                  - bucket:
                      Fn::GetAtt:
                        - S3
                        - Arn
      ManagedPolicyName:
        Fn::Sub: "${AWS::StackName}-GrokSpawner-Kaniko-${AWS::Region}"
  KanikoPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      Description:
        Fn::Sub: "${AWS::StackName} Kaniko policy to access AWS resources"
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Action:
              - ecr:GetAuthorizationToken
            Effect: Allow
            Resource: "*"
          - Action:
              - ecr:CompleteLayerUpload
              - ecr:UploadLayerPart
              - ecr:InitiateLayerUpload
              - ecr:BatchCheckLayerAvailability
              - ecr:PutImage
              - ecr:TagResource
            Effect: Allow
            Resource:
              Fn::Sub: "arn:aws:ecr:${AWS::Region}:${AWS::AccountId}:repository/datagrok/*"
          - Action:
              - ecr:BatchCheckLayerAvailability
              - ecr:BatchGetImage
            Effect: Allow
            Resource:
              Fn::Sub: "arn:aws:ecr:${AWS::Region}:${AWS::AccountId}:repository/datagrok/*"
          - Action:
              - s3:GetObject
              - s3:ListBucket
            Effect: Allow
            Resource:
              - Fn::GetAtt:
                  - S3
                  - Arn
              - Fn::Sub:
                  - "${bucket}/dockerfiles/*"
                  - bucket:
                      Fn::GetAtt:
                        - S3
                        - Arn
      ManagedPolicyName:
        Fn::Sub: "${AWS::StackName}-Kaniko-${AWS::Region}"
  GrokSpawnerTaskRole:
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Condition: { }
            Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
        Version: '2012-10-17'
      ManagedPolicyArns:
        - Ref: GrokSpawnerPolicy
        - Ref: GrokSpawnerECRPolicy
        - Ref: GrokSpawnerKanikoPolicy
        - Ref: ECSPolicy
      Tags:
        - Key: datagrok.component
          Value: datagrok
        - Key: datagrok.service
          Value: grok_spawner
    Type: AWS::IAM::Role
  KanikoTaskRole:
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Condition: { }
            Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
        Version: '2012-10-17'
      ManagedPolicyArns:
        - Ref: KanikoPolicy
      Tags:
        - Key: datagrok.component
          Value: datagrok
        - Key: datagrok.service
          Value: grok_spawner
    Type: AWS::IAM::Role
  GrokSpawnerService:
    DependsOn:
      - TCP8000IntListener
    Properties:
      Cluster:
        Fn::GetAtt:
          - Cluster
          - Arn
      DeploymentConfiguration:
        MaximumPercent: 200
        MinimumHealthyPercent: 100
      DeploymentController:
        Type: ECS
      DesiredCount: 1
      LaunchType: "FARGATE"
      LoadBalancers:
        - ContainerName: grok_spawner
          ContainerPort: 8000
          TargetGroupArn:
            Ref: TCP8000IntTargetGroup
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: ENABLED
          SecurityGroups:
            - Ref: DatagrokSecurityGroup
          Subnets:
            - Ref: PrivateSubnet1
            - Ref: PrivateSubnet2
      PlatformVersion: 1.4.0
      PropagateTags: SERVICE
      SchedulingStrategy: REPLICA
      ServiceRegistries:
        - RegistryArn:
            Fn::GetAtt:
              - GrokSpawnerServiceDiscoveryEntry
              - Arn
      Tags:
        - Key: datagrok.component
          Value: datagrok
        - Key: datagrok.service
          Value: grok_spawner
      TaskDefinition:
        Ref: GrokSpawnerTaskDefinition
    Type: AWS::ECS::Service
  GrokSpawnerServiceDiscoveryEntry:
    Properties:
      Description:
        Fn::Sub: "${AWS::StackName} Datagrok grok_spawner service discovery entry in Cloud Map"
      DnsConfig:
        DnsRecords:
          - TTL: 60
            Type: A
        RoutingPolicy: MULTIVALUE
      HealthCheckCustomConfig:
        FailureThreshold: 1
      Name: grok_spawner
      NamespaceId:
        Ref: CloudMap
    Type: AWS::ServiceDiscovery::Service
  GrokSpawnerTaskDefinition:
    Properties:
      ContainerDefinitions:
        - Command:
            - Fn::Sub: "${AWS::Region}.compute.internal"
            - Fn::Sub: ${AWS::StackName}.datagrok.${AWS::Region}.lb.internal
            - Fn::Sub: ${AWS::StackName}.datagrok.${AWS::Region}.cm.internal
          Essential: false
          Image:
            Fn::Sub:
              - "${domain}/${repo}:${tag}"
              - domain:
                  Fn::FindInMap: [ Images, Searchdomain, domain ]
                repo:
                  Fn::FindInMap: [ Images, Searchdomain, repo ]
                tag:
                  Fn::FindInMap: [ Images, Searchdomain, version ]
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group:
                Ref: LogGroup
              awslogs-region:
                Ref: AWS::Region
              awslogs-stream-prefix: grok_spawner
          MemoryReservation: 100
          Name: ResolvConf
        - DependsOn:
            - Condition: SUCCESS
              ContainerName: ResolvConf
          Essential: true
          Image:
            Fn::Sub:
              - "${domain}/${repo}:${tag}"
              - domain:
                  Fn::FindInMap: [ Images, GrokSpawner, domain ]
                repo:
                  Fn::FindInMap: [ Images, GrokSpawner, repo ]
                tag:
                  Ref: GrokSpawnerVersion
          Environment:
            - Name: "DOCKER_REGISTRY_SECRET_ARN"
              Value: ""
            - Name: "ECS_SUBNETS"
              Value:
                Fn::Sub:
                  - '["${s1}", "${s2}"]'
                  - s1:
                      Ref: PrivateSubnet1
                    s2:
                      Ref: PrivateSubnet2
            - Name: "ECS_SECURITY_GROUPS"
              Value:
                Fn::Sub:
                  - '["${s1}"]'
                  - s1:
                      Ref: DatagrokSecurityGroup
            - Name: "ECS_EXEC_ROLE"
              Value:
                Fn::GetAtt:
                  - TaskExecutionRole
                  - Arn
            - Name: "GROK_SPAWNER_ENVIRONMENT"
              Value:
                Fn::Sub: "${AWS::StackName}"
            - Name: "KANIKO_S3_BUCKET"
              Value:
                Ref: S3
            - Name: "KANIKO_TASK_DEFINITION"
              Value:
                Ref: KanikoTaskDefinition
            - Name: "ECS_LOG_GROUP"
              Value:
                Fn::Sub:
                  - arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:${logs}
                  - logs:
                      Ref: LogGroup
          LinuxParameters: { }
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group:
                Ref: LogGroup
              awslogs-region:
                Ref: AWS::Region
              awslogs-stream-prefix: grok_spawner
          MemoryReservation: 100
          Name: grok_spawner
          PortMappings:
            - ContainerPort: 8000
              HostPort: 8000
              Protocol: tcp
      Cpu: '256'
      ExecutionRoleArn:
        Fn::GetAtt:
          - TaskExecutionRole
          - Arn
      Family: grok_spawner
      Memory: '512'
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - "FARGATE"
      TaskRoleArn:
        Ref: GrokSpawnerTaskRole
    Type: AWS::ECS::TaskDefinition
  KanikoTaskDefinition:
    Properties:
      ContainerDefinitions:
        - Essential: true
          Image:
            Fn::Sub:
              - "${domain}/${repo}:${tag}"
              - domain:
                  Fn::FindInMap: [ Images, Kaniko, domain ]
                repo:
                  Fn::FindInMap: [ Images, Kaniko, repo ]
                tag:
                  Fn::FindInMap: [ Images, Kaniko, repo ]
          LinuxParameters: { }
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group:
                Ref: LogGroup
              awslogs-region:
                Ref: AWS::Region
              awslogs-stream-prefix: grok_spawner_kaniko
          MemoryReservation: 100
          Name: grok_spawner_kaniko
      Cpu: '1024'
      ExecutionRoleArn:
        Fn::GetAtt:
          - TaskExecutionRole
          - Arn
      Family: grok_spawner_kaniko
      Memory: '4096'
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - "FARGATE"
      TaskRoleArn:
        Ref: KanikoTaskRole
    Type: AWS::ECS::TaskDefinition
  GrokSpawnerPrivateDNS:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId:
        Ref: PrivateDNSZone
      Comment:
        Fn::Sub: "${AWS::StackName} Private Datagrok grok spawner DNS for internal routing"
      Name:
        Fn::Sub: "grok_spawner.${AWS::StackName}.datagrok.${AWS::Region}.lb.internal."
      Type: A
      AliasTarget:
        HostedZoneId:
          Fn::GetAtt:
            - LoadBalancerIntDatagrok
            - CanonicalHostedZoneID
        DNSName:
          Fn::GetAtt:
            - LoadBalancerIntDatagrok
            - DNSName
  TCP8000IntListener:
    Properties:
      DefaultActions:
        - ForwardConfig:
            TargetGroups:
              - TargetGroupArn:
                  Ref: TCP8000IntTargetGroup
          Type: forward
      LoadBalancerArn:
        Ref: LoadBalancerIntDatagrok
      Port: 8000
      Protocol: HTTP
    Type: AWS::ElasticLoadBalancingV2::Listener
  TCP8000IntTargetGroup:
    Properties:
      Name:
        Fn::Sub: "${AWS::StackName}-gs-i"
      Port: 8000
      Protocol: HTTP
      Tags:
        - Key: datagrok.component
          Value: datagrok
      TargetType: 'ip'
      VpcId:
        Ref: VPC
      HealthCheckIntervalSeconds: 60
      HealthCheckPath: "/info"
      Matcher:
        HttpCode: 200
      UnhealthyThresholdCount: 5
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
Outputs:
  DatagrokAdminPassword:
    Description: Admin password for first login
    Value:
      Ref: AdminPassword
