---
AWSTemplateFormatVersion: '2010-09-09'
Conditions:
  CreateDNS:
    Fn::And:
    - Fn::Not:
      - Fn::Equals:
        - Ref: DNSDomain
        - ''
    - Fn::Not:
      - Fn::Equals:
        - Ref: DNSZoneId
        - ''
  CreatePublicSubnets:
    Fn::Or:
    - Condition: InternetIngressAccess
    - Condition: InternetEgressAccess
  CreateSSL:
    Fn::And:
    - Fn::Not:
      - Fn::Equals:
        - Ref: DNSDomain
        - ''
    - Fn::Not:
      - Fn::Equals:
        - Ref: DNSZoneId
        - ''
  InternetEgressAccess:
    Fn::Equals:
    - Ref: InternetEgressAccess
    - 'true'
  InternetIngressAccess:
    Fn::Equals:
    - Ref: InternetIngressAccess
    - 'true'
Description: Datagrok template to deploy all components to ECS Fargate in new VPC.
  Template also creates ACM and DNS records.
Mappings:
  Images:
    Datagrok:
      domain: docker.io
      repo: datagrok/datagrok
    GrokCompute:
      domain: docker.io
      repo: datagrok/grok_compute
    GrokConnect:
      domain: docker.io
      repo: datagrok/grok_connect
    GrokSpawner:
      domain: docker.io
      repo: datagrok/grok_spawner
    H2o:
      domain: docker.io
      repo: datagrok/h2o
    JKG:
      domain: docker.io
      repo: datagrok/jupyter_kernel_gateway
    JN:
      domain: docker.io
      repo: datagrok/jupyter_notebook
    Kaniko:
      domain: gcr.io
      repo: kaniko-project/executor
      version: v1.12.1
    Searchdomain:
      domain: docker.io
      repo: docker/ecs-searchdomain-sidecar
      version: '1.0'
    Smtp:
      domain: docker.io
      repo: datagrok/smtp
      version: 1.0.0
Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
    - Label:
        default: Network configuration
      Parameters:
      - CIDR
      - InternetIngressAccess
      - InternetSubnetAllow
      - InternetEgressAccess
    - Label:
        default: Client Endpoint configuration
      Parameters:
      - DNSZoneId
      - DNSDomain
    - Label:
        default: Service version
      Parameters:
      - DatagrokVersion
      - GrokConnectVersion
      - GrokSpawnerVersion
      - JKGVersion
      - JNVersion
      - GrokComputeVersion
      - H2oVersion
    ParameterLabels:
      CIDR:
        default: 'CIDR: VPC CIDR'
      DNSDomain:
        default: 'DNSDomain: DNS domain'
      DNSZoneId:
        default: 'DNSZoneId: AWS Route53 Hosted Zone ID'
      DatagrokVersion:
        default: Datagrok Version
      GrokComputeVersion:
        default: Grok Compute Version
      GrokConnectVersion:
        default: Grok Connect Version
      GrokSpawnerVersion:
        default: Grok Spawner Version
      H2oVersion:
        default: H2O Version
      InternetEgressAccess:
        default: 'InternetEgressAccess: Access to internet'
      InternetIngressAccess:
        default: 'InternetIngressAccess: Access from internet'
      InternetSubnetAllow:
        default: 'InternetSubnetAllow: Allow connect from CIDR'
      JKGVersion:
        default: Jupyter Kernel Gateway Version
      JNVersion:
        default: Jupyter Notebook Version
Outputs:
  DatagrokAdminPassword:
    Description: Admin password for first login
    Value:
      Ref: AdminPassword
  DatagrokEndpoint:
    Description: Datagrok endpoint
    Value:
      Ref: DatagrokDNS
Parameters:
  CIDR:
    AllowedPattern: '[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/[0-9]+'
    Default: 10.0.0.0/17
    Description: CIDR block for the new Datagrok VPC
    Type: String
  DNSDomain:
    Description: Specify DNS domain for Datagrok and CVM client endpoints. The domain
      should be based on hosted zone name for specified DNSZoneId. For example, if
      you specified DNSZoneId XXXXXX, which has name domain.com, then for DNSDomain
      you can use either 'subdomain.domain.com' or 'domain.com'. The result endpoint
      will be 'StackName-datagrok.subdomain.domain.com'.
    Type: String
  DNSZoneId:
    Description: Select existing Route53 Hosted Zone ID for Datagrok and CVM client
      endpoints.
    Type: AWS::Route53::HostedZone::Id
  DatagrokVersion:
    AllowedPattern: ([0-9]+\.[0-9]+\.[0-9]+)|latest|stable|bleeding-edge
    Default: 1.16.3
    Description: Enter Datagrok docker image version.
    Type: String
  GrokComputeVersion:
    AllowedPattern: ([0-9]+\.[0-9]+\.[0-9]+)|latest|bleeding-edge
    Default: 1.5.4
    Description: Enter Grok Compute docker image version.
    Type: String
  GrokConnectVersion:
    AllowedPattern: ([0-9]+\.[0-9]+\.[0-9]+)|latest|bleeding-edge
    Default: 2.1.8
    Description: Enter Grok Connect docker image version.
    Type: String
  GrokSpawnerVersion:
    AllowedPattern: ([0-9]+\.[0-9]+\.[0-9]+)|latest|bleeding-edge
    Default: 1.4.4
    Description: Enter Grok Spawner docker image version.
    Type: String
  H2oVersion:
    AllowedPattern: ([0-9]+\.[0-9]+\.[0-9]+)|latest|bleeding-edge
    Default: 1.1.1
    Description: Enter Datagrok H2O docker image version.
    Type: String
  InternetEgressAccess:
    AllowedValues:
    - 'true'
    - 'false'
    Default: 'true'
    Description: Do you want Datagrok to be able to access internet? The access will
      be created using NAT Gateway. Either access to the internet from Datagrok or
      configured proxy are required to install Datagrok packages (https://datagrok.ai/help/develop#packages).
    Type: String
  InternetIngressAccess:
    AllowedValues:
    - 'true'
    - 'false'
    Default: 'true'
    Description: 'Do you want Datagrok to be available from internet? The exact subnet
      from which Datagrok will be available can be specified in ''InternetSubnetAllow:
      Allow connect to Datagrok from CIDR'' parameter.'
    Type: String
  InternetSubnetAllow:
    AllowedPattern: '[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/[0-9]+'
    Description: Subnet for access to Datagrok client endpoints. Set CIDR to 0.0.0.0/0
      to allow all IP addresses access, or another CIDR range.
    Type: String
  JKGVersion:
    AllowedPattern: ([0-9]+\.[0-9]+\.[0-9]+)|latest|bleeding-edge
    Default: 1.6.1
    Description: Enter Datagrok Jupyter Kernel Gateway docker image version. Default
      is 'latest'.
    Type: String
  JNVersion:
    AllowedPattern: ([0-9]+\.[0-9]+\.[0-9]+)|latest|bleeding-edge
    Default: 1.1.1
    Description: Enter Datagrok Jupyter Notebook docker image version. Default is
      'latest'.
    Type: String
Resources:
  ALBIntSecurityGroup:
    Properties:
      GroupDescription:
        Fn::Sub: ${AWS::StackName} Datagrok ALB Internal Security Group
      SecurityGroupEgress:
      - Description:
          Fn::Sub: ${AWS::StackName} Datagrok egress rules
        DestinationSecurityGroupId:
          Ref: DatagrokSecurityGroup
        FromPort: 0
        IpProtocol: TCP
        ToPort: 65535
      SecurityGroupIngress:
      - Description:
          Fn::Sub: ${AWS::StackName} Allow internal connections from CVM to Datagrok
        FromPort: 8080
        IpProtocol: TCP
        SourceSecurityGroupId:
          Ref: CvmSecurityGroup
        ToPort: 8080
      - Description:
          Fn::Sub: ${AWS::StackName} Allow internal connections from Datagrok to Grok
            Connect
        FromPort: 1234
        IpProtocol: TCP
        SourceSecurityGroupId:
          Ref: DatagrokSecurityGroup
        ToPort: 1234
      - Description:
          Fn::Sub: ${AWS::StackName} Allow internal connections from Datagrok to Grok
            Spawner
        FromPort: 8000
        IpProtocol: TCP
        SourceSecurityGroupId:
          Ref: DatagrokSecurityGroup
        ToPort: 8000
      Tags:
      - Key: Name
        Value:
          Fn::Sub: ${AWS::StackName}-datagrok-alb-int
      - Key: datagrok.component
        Value: datagrok
      VpcId:
        Ref: VPC
    Type: AWS::EC2::SecurityGroup
  ALBSecurityGroup:
    Properties:
      GroupDescription:
        Fn::Sub: ${AWS::StackName} Datagrok ALB Security Group
      Tags:
      - Key: Name
        Value:
          Fn::Sub: ${AWS::StackName}-datagrok-alb
      - Key: datagrok.component
        Value: datagrok
      VpcId:
        Ref: VPC
    Type: AWS::EC2::SecurityGroup
  AdminDevKey:
    Properties:
      Description: Datagrok Admin user developer key
      GenerateSecretString:
        ExcludePunctuation: true
        GenerateStringKey: password
        PasswordLength: 24
        RequireEachIncludedType: true
        SecretStringTemplate: '{"user": "admin"}'
    Type: AWS::SecretsManager::Secret
  AdminPassword:
    Properties:
      Description: Datagrok Admin user first-login password
      GenerateSecretString:
        ExcludePunctuation: true
        GenerateStringKey: password
        PasswordLength: 16
        RequireEachIncludedType: true
        SecretStringTemplate: '{"user": "admin"}'
    Type: AWS::SecretsManager::Secret
  ArnSSLCertificate:
    Condition: CreateSSL
    Properties:
      DomainName:
        Fn::Sub:
        - ${AWS::StackName}-datagrok.${domain}
        - domain:
            Ref: DNSDomain
      DomainValidationOptions:
      - DomainName:
          Fn::Sub:
          - ${AWS::StackName}-datagrok.${domain}
          - domain:
              Ref: DNSDomain
        HostedZoneId:
          Ref: DNSZoneId
      - DomainName:
          Fn::Sub:
          - ${AWS::StackName}-datagrok-cvm.${domain}
          - domain:
              Ref: DNSDomain
        HostedZoneId:
          Ref: DNSZoneId
      KeyAlgorithm: RSA_2048
      SubjectAlternativeNames:
      - Fn::Sub:
        - ${AWS::StackName}-datagrok-cvm.${domain}
        - domain:
            Ref: DNSDomain
      Tags:
      - Key: Name
        Value:
          Fn::Sub: ${AWS::StackName}-datagrok
      ValidationMethod: DNS
    Type: AWS::CertificateManager::Certificate
  CloudMap:
    Properties:
      Description: ${AWS::StackName} Service Map for Datagrok
      Name:
        Fn::Sub: ${AWS::StackName}.datagrok.${AWS::Region}.cm.internal
      Vpc:
        Ref: VPC
    Type: AWS::ServiceDiscovery::PrivateDnsNamespace
  Cluster:
    Properties:
      ClusterName:
        Fn::Sub: ${AWS::StackName}-datagrok
      ClusterSettings:
      - Name: containerInsights
        Value: enabled
      Tags:
      - Key: datagrok.component
        Value: datagrok
    Type: AWS::ECS::Cluster
  Cvm443Ingress:
    Properties:
      CidrIp:
        Ref: InternetSubnetAllow
      Description:
        Fn::Sub: ${AWS::StackName} 443/tcp on CVM ALB for JKG, JN, GC
      FromPort: 443
      GroupId:
        Ref: CvmALBSecurityGroup
      IpProtocol: TCP
      ToPort: 443
    Type: AWS::EC2::SecurityGroupIngress
  Cvm443IngressNatGW:
    Condition: InternetEgressAccess
    Properties:
      CidrIp:
        Fn::Sub:
        - ${ip}/32
        - ip:
            Ref: NatGatewayEIP
      Description:
        Fn::Sub: ${AWS::StackName} NatGW 443/tcp on CVM ALB for JKG, JN, GC
      FromPort: 443
      GroupId:
        Ref: CvmALBSecurityGroup
      IpProtocol: TCP
      ToPort: 443
    Type: AWS::EC2::SecurityGroupIngress
  Cvm443IngressVPC:
    Properties:
      CidrIp:
        Ref: CIDR
      Description:
        Fn::Sub: ${AWS::StackName} VPC 443/tcp on CVM ALB for JKG, JN, GC
      FromPort: 443
      GroupId:
        Ref: CvmALBSecurityGroup
      IpProtocol: TCP
      ToPort: 443
    Type: AWS::EC2::SecurityGroupIngress
  Cvm5005Ingress:
    Properties:
      CidrIp:
        Ref: InternetSubnetAllow
      Description:
        Fn::Sub: ${AWS::StackName} 5005/tcp on CVM ALB for H2O GH
      FromPort: 5005
      GroupId:
        Ref: CvmALBSecurityGroup
      IpProtocol: TCP
      ToPort: 5005
    Type: AWS::EC2::SecurityGroupIngress
  Cvm5005IngressNatGW:
    Condition: InternetEgressAccess
    Properties:
      CidrIp:
        Fn::Sub:
        - ${ip}/32
        - ip:
            Ref: NatGatewayEIP
      Description:
        Fn::Sub: ${AWS::StackName} NatGW 5005/tcp on CVM ALB for H2O GH
      FromPort: 5005
      GroupId:
        Ref: CvmALBSecurityGroup
      IpProtocol: TCP
      ToPort: 5005
    Type: AWS::EC2::SecurityGroupIngress
  Cvm5005IngressVPC:
    Properties:
      CidrIp:
        Ref: CIDR
      Description:
        Fn::Sub: ${AWS::StackName} VPC 5005/tcp on CVM ALB for H2O GH
      FromPort: 5005
      GroupId:
        Ref: CvmALBSecurityGroup
      IpProtocol: TCP
      ToPort: 5005
    Type: AWS::EC2::SecurityGroupIngress
  Cvm54321Ingress:
    Properties:
      CidrIp:
        Ref: InternetSubnetAllow
      Description:
        Fn::Sub: ${AWS::StackName} 54321/tcp on CVM ALB for H2O
      FromPort: 54321
      GroupId:
        Ref: CvmALBSecurityGroup
      IpProtocol: TCP
      ToPort: 54321
    Type: AWS::EC2::SecurityGroupIngress
  Cvm54321IngressNatGW:
    Condition: InternetEgressAccess
    Properties:
      CidrIp:
        Fn::Sub:
        - ${ip}/32
        - ip:
            Ref: NatGatewayEIP
      Description:
        Fn::Sub: ${AWS::StackName} NatGW 54321/tcp on CVM ALB for H2O
      FromPort: 54321
      GroupId:
        Ref: CvmALBSecurityGroup
      IpProtocol: TCP
      ToPort: 54321
    Type: AWS::EC2::SecurityGroupIngress
  Cvm54321IngressVPC:
    Properties:
      CidrIp:
        Ref: CIDR
      Description:
        Fn::Sub: ${AWS::StackName} VPC 54321/tcp on CVM ALB for H2O
      FromPort: 54321
      GroupId:
        Ref: CvmALBSecurityGroup
      IpProtocol: TCP
      ToPort: 54321
    Type: AWS::EC2::SecurityGroupIngress
  Cvm80Ingress:
    Properties:
      CidrIp:
        Ref: InternetSubnetAllow
      Description:
        Fn::Sub: ${AWS::StackName} 80/tcp on CVM ALB for JKG, JN, GC
      FromPort: 80
      GroupId:
        Ref: CvmALBSecurityGroup
      IpProtocol: TCP
      ToPort: 80
    Type: AWS::EC2::SecurityGroupIngress
  Cvm80IngressNatGW:
    Condition: InternetEgressAccess
    Properties:
      CidrIp:
        Fn::Sub:
        - ${ip}/32
        - ip:
            Ref: NatGatewayEIP
      Description:
        Fn::Sub: ${AWS::StackName} NatGW 80/tcp on CVM ALB for JKG, JN, GC
      FromPort: 80
      GroupId:
        Ref: CvmALBSecurityGroup
      IpProtocol: TCP
      ToPort: 80
    Type: AWS::EC2::SecurityGroupIngress
  Cvm80IngressVPC:
    Properties:
      CidrIp:
        Ref: CIDR
      Description:
        Fn::Sub: ${AWS::StackName} VPC 80/tcp on CVM ALB for JKG, JN, GC
      FromPort: 80
      GroupId:
        Ref: CvmALBSecurityGroup
      IpProtocol: TCP
      ToPort: 80
    Type: AWS::EC2::SecurityGroupIngress
  CvmALBIntSecurityGroup:
    Properties:
      GroupDescription:
        Fn::Sub: ${AWS::StackName} Datagrok CVM ALB Internal Security Group
      SecurityGroupEgress:
      - Description:
          Fn::Sub: ${AWS::StackName} CVM egress rules
        DestinationSecurityGroupId:
          Ref: CvmSecurityGroup
        FromPort: 0
        IpProtocol: TCP
        ToPort: 65535
      SecurityGroupIngress:
      - Description:
          Fn::Sub: ${AWS::StackName} Allow internal connections from Datagrok to CVM
        FromPort: 8090
        IpProtocol: TCP
        SourceSecurityGroupId:
          Ref: DatagrokSecurityGroup
        ToPort: 8090
      - Description:
          Fn::Sub: ${AWS::StackName} Allow internal connections to HTTP
        FromPort: 80
        IpProtocol: TCP
        SourceSecurityGroupId:
          Ref: DatagrokSecurityGroup
        ToPort: 80
      - Description:
          Fn::Sub: ${AWS::StackName} Allow internal connections from Datagrok to H2O
        FromPort: 54321
        IpProtocol: TCP
        SourceSecurityGroupId:
          Ref: DatagrokSecurityGroup
        ToPort: 54321
      - Description: ${AWS::StackName} Allow internal connections from Datagrok to
          H2O GH
        FromPort: 5005
        IpProtocol: TCP
        SourceSecurityGroupId:
          Ref: DatagrokSecurityGroup
        ToPort: 5005
      Tags:
      - Key: Name
        Value:
          Fn::Sub: ${AWS::StackName}-datagrok-cvm-alb-int
      - Key: datagrok.component
        Value: cvm
      VpcId:
        Ref: VPC
    Type: AWS::EC2::SecurityGroup
  CvmALBSecurityGroup:
    Properties:
      GroupDescription:
        Fn::Sub: ${AWS::StackName} Datagrok CVM ALB Security Group
      Tags:
      - Key: Name
        Value:
          Fn::Sub: ${AWS::StackName}-datagrok-cvm-alb
      - Key: datagrok.component
        Value: cvm
      VpcId:
        Ref: VPC
    Type: AWS::EC2::SecurityGroup
  CvmCluster:
    Properties:
      ClusterName:
        Fn::Sub: ${AWS::StackName}-datagrok-cvm
      ClusterSettings:
      - Name: containerInsights
        Value: enabled
      Tags:
      - Key: datagrok.component
        Value: cvm
    Type: AWS::ECS::Cluster
  CvmDNS:
    Condition: CreateDNS
    Properties:
      AliasTarget:
        DNSName:
          Fn::GetAtt:
          - LoadBalancerCvm
          - DNSName
        HostedZoneId:
          Fn::GetAtt:
          - LoadBalancerCvm
          - CanonicalHostedZoneID
      Comment:
        Fn::Sub: ${AWS::StackName} Public Datagrok CVM DNS
      HostedZoneId:
        Ref: DNSZoneId
      Name:
        Fn::Sub:
        - ${AWS::StackName}-datagrok-cvm.${domain}.
        - domain:
            Ref: DNSDomain
      Type: A
    Type: AWS::Route53::RecordSet
  CvmEgress:
    Properties:
      Description:
        Fn::Sub: ${AWS::StackName} CVM egress rules
      DestinationSecurityGroupId:
        Ref: CvmSecurityGroup
      FromPort: 0
      GroupId:
        Ref: CvmALBSecurityGroup
      IpProtocol: TCP
      ToPort: 65535
    Type: AWS::EC2::SecurityGroupEgress
  CvmInsightsLogGroup:
    DeletionPolicy: Delete
    Properties:
      LogGroupName:
        Fn::Sub:
        - /aws/ecs/containerinsights/${cluster_name}/performance
        - cluster_name:
            Ref: CvmCluster
      RetentionInDays: 1
    Type: AWS::Logs::LogGroup
    UpdateReplacePolicy: Delete
  CvmPrivateDNS:
    Properties:
      AliasTarget:
        DNSName:
          Fn::GetAtt:
          - LoadBalancerIntCvm
          - DNSName
        HostedZoneId:
          Fn::GetAtt:
          - LoadBalancerIntCvm
          - CanonicalHostedZoneID
      Comment:
        Fn::Sub: ${AWS::StackName} Private Datagrok CVM DNS for internal routing
      HostedZoneId:
        Ref: PrivateDNSZone
      Name:
        Fn::Sub: cvm.${AWS::StackName}.datagrok.${AWS::Region}.lb.internal.
      Type: A
    Type: AWS::Route53::RecordSet
  CvmSecurityGroup:
    Properties:
      GroupDescription:
        Fn::Sub: ${AWS::StackName} Datagrok CVM Security Group
      Tags:
      - Key: Name
        Value:
          Fn::Sub: ${AWS::StackName}-datagrok-cvm
      - Key: datagrok.component
        Value: cvm
      VpcId:
        Ref: VPC
    Type: AWS::EC2::SecurityGroup
  CvmSecurityGroupALBCommunications:
    Properties:
      Description:
        Fn::Sub: ${AWS::StackName} Allow communication from ALB to CVM components
      GroupId:
        Ref: CvmSecurityGroup
      IpProtocol: '-1'
      SourceSecurityGroupId:
        Ref: CvmALBSecurityGroup
    Type: AWS::EC2::SecurityGroupIngress
  CvmSecurityGroupALBIntCommunications:
    Properties:
      Description:
        Fn::Sub: ${AWS::StackName} Allow communication from internal ALB to CVM components
      GroupId:
        Ref: CvmSecurityGroup
      IpProtocol: '-1'
      SourceSecurityGroupId:
        Ref: CvmALBIntSecurityGroup
    Type: AWS::EC2::SecurityGroupIngress
  CvmSecurityGroupCommunications:
    Properties:
      Description:
        Fn::Sub: ${AWS::StackName} Allow communication from Datagrok to CVM components
      GroupId:
        Ref: CvmSecurityGroup
      IpProtocol: '-1'
      SourceSecurityGroupId:
        Ref: DatagrokSecurityGroup
    Type: AWS::EC2::SecurityGroupIngress
  CvmSecurityGroupInternalCommunications:
    Properties:
      Description:
        Fn::Sub: ${AWS::StackName} Allow communication within network CVM
      GroupId:
        Ref: CvmSecurityGroup
      IpProtocol: '-1'
      SourceSecurityGroupId:
        Ref: CvmSecurityGroup
    Type: AWS::EC2::SecurityGroupIngress
  CvmTCP443Listener:
    Properties:
      Certificates:
      - CertificateArn:
          Ref: ArnSSLCertificate
      DefaultActions:
      - FixedResponseConfig:
          StatusCode: 204
        Type: fixed-response
      LoadBalancerArn:
        Ref: LoadBalancerCvm
      Port: 443
      Protocol: HTTPS
    Type: AWS::ElasticLoadBalancingV2::Listener
  CvmTCP8090IntListener:
    Properties:
      DefaultActions:
      - FixedResponseConfig:
          StatusCode: 204
        Type: fixed-response
      LoadBalancerArn:
        Ref: LoadBalancerIntCvm
      Port: 8090
      Protocol: HTTP
    Type: AWS::ElasticLoadBalancingV2::Listener
  CvmTCP80Listener:
    Properties:
      DefaultActions:
      - RedirectConfig:
          Port: '443'
          Protocol: HTTPS
          StatusCode: HTTP_301
        Type: redirect
      LoadBalancerArn:
        Ref: LoadBalancerCvm
      Port: 80
      Protocol: HTTP
    Type: AWS::ElasticLoadBalancingV2::Listener
  DB:
    DeletionPolicy: Snapshot
    Properties:
      AllocatedStorage: '50'
      AllowMajorVersionUpgrade: false
      AutoMinorVersionUpgrade: true
      BackupRetentionPeriod: 3
      DBInstanceClass: db.t3.large
      DBInstanceIdentifier:
        Fn::Sub: ${AWS::StackName}-datagrok-rds
      DBName: datagrok
      DBSubnetGroupName:
        Ref: DBSubnetGroup
      DeleteAutomatedBackups: true
      DeletionProtection: false
      EnableIAMDatabaseAuthentication: true
      Engine: postgres
      EngineVersion: '12.15'
      MasterUserPassword:
        Fn::Sub:
        - '{{resolve:secretsmanager:${secret}:SecretString:password}}'
        - secret:
            Ref: DatagrokDbAdminUser
      MasterUsername:
        Fn::Sub:
        - '{{resolve:secretsmanager:${secret}:SecretString:user}}'
        - secret:
            Ref: DatagrokDbAdminUser
      MultiAZ: false
      Port: '5432'
      PubliclyAccessible: false
      StorageEncrypted: true
      Tags:
      - Key: datagrok.component
        Value: datagrok
      VPCSecurityGroups:
      - Ref: DBSecurityGroup
    Type: AWS::RDS::DBInstance
    UpdateReplacePolicy: Delete
  DBSecurityGroup:
    Properties:
      GroupDescription:
        Fn::Sub: ${AWS::StackName} Datagrok DB Security Group
      SecurityGroupEgress: []
      SecurityGroupIngress:
      - Description:
          Fn::Sub: ${AWS::StackName} Allow connection from datagrok server
        FromPort: 5432
        IpProtocol: TCP
        SourceSecurityGroupId:
          Ref: DatagrokSecurityGroup
        ToPort: 5432
      Tags:
      - Key: Name
        Value:
          Fn::Sub: ${AWS::StackName}-datagrok-rds
      - Key: datagrok.component
        Value: datagrok
      VpcId:
        Ref: VPC
    Type: AWS::EC2::SecurityGroup
  DBSubnetGroup:
    Properties:
      DBSubnetGroupDescription:
        Fn::Sub: ${AWS::StackName} Datagrok DB Subnet Group
      DBSubnetGroupName:
        Fn::Sub: ${AWS::StackName}-datagrok-rds-subnet
      SubnetIds:
      - Ref: DataSubnet1
      - Ref: DataSubnet2
      Tags:
      - Key: datagrok.component
        Value: rds
    Type: AWS::RDS::DBSubnetGroup
  DataSubnet1:
    Properties:
      AvailabilityZone:
        Fn::Select:
        - 0
        - Fn::GetAZs:
            Ref: AWS::Region
      CidrBlock:
        Fn::Select:
        - 4
        - Fn::Cidr:
          - Fn::GetAtt:
            - VPC
            - CidrBlock
          - 6
          - 6
      MapPublicIpOnLaunch: false
      Tags:
      - Key: Name
        Value:
          Fn::Sub: ${AWS::StackName} Datagrok Data Subnet 1
      - Key: datagrok.component
        Value: rds
      VpcId:
        Ref: VPC
    Type: AWS::EC2::Subnet
  DataSubnet2:
    Properties:
      AvailabilityZone:
        Fn::Select:
        - 1
        - Fn::GetAZs:
            Ref: AWS::Region
      CidrBlock:
        Fn::Select:
        - 5
        - Fn::Cidr:
          - Fn::GetAtt:
            - VPC
            - CidrBlock
          - 6
          - 6
      MapPublicIpOnLaunch: false
      Tags:
      - Key: Name
        Value:
          Fn::Sub: ${AWS::StackName} Datagrok Data Subnet 2
      - Key: datagrok.component
        Value: rds
      VpcId:
        Ref: VPC
    Type: AWS::EC2::Subnet
  DataSubnetRouteAssos1:
    Properties:
      RouteTableId:
        Ref: DataSubnetRouteTable
      SubnetId:
        Ref: DataSubnet1
    Type: AWS::EC2::SubnetRouteTableAssociation
  DataSubnetRouteAssos2:
    Properties:
      RouteTableId:
        Ref: DataSubnetRouteTable
      SubnetId:
        Ref: DataSubnet2
    Type: AWS::EC2::SubnetRouteTableAssociation
  DataSubnetRouteTable:
    Properties:
      Tags:
      - Key: Name
        Value:
          Fn::Sub: ${AWS::StackName} Datagrok Data Subnet Route Table
      - Key: datagrok.component
        Value: rds
      VpcId:
        Ref: VPC
    Type: AWS::EC2::RouteTable
  Datagrok443Ingress:
    Properties:
      CidrIp:
        Ref: InternetSubnetAllow
      Description:
        Fn::Sub: ${AWS::StackName} 443/tcp on Datagrok ALB for Datagrok Server
      FromPort: 443
      GroupId:
        Ref: ALBSecurityGroup
      IpProtocol: TCP
      ToPort: 443
    Type: AWS::EC2::SecurityGroupIngress
  Datagrok443IngressNatGW:
    Condition: InternetEgressAccess
    Properties:
      CidrIp:
        Fn::Sub:
        - ${ip}/32
        - ip:
            Ref: NatGatewayEIP
      Description:
        Fn::Sub: ${AWS::StackName} NatGW 443/tcp on Datagrok ALB for Datagrok Server
      FromPort: 443
      GroupId:
        Ref: ALBSecurityGroup
      IpProtocol: TCP
      ToPort: 443
    Type: AWS::EC2::SecurityGroupIngress
  Datagrok443IngressVPC:
    Properties:
      CidrIp:
        Ref: CIDR
      Description:
        Fn::Sub: ${AWS::StackName} VPC 443/tcp on Datagrok ALB for Datagrok Server
      FromPort: 443
      GroupId:
        Ref: ALBSecurityGroup
      IpProtocol: TCP
      ToPort: 443
    Type: AWS::EC2::SecurityGroupIngress
  Datagrok80Ingress:
    Properties:
      CidrIp:
        Ref: InternetSubnetAllow
      Description:
        Fn::Sub: ${AWS::StackName} 80/tcp on Datagrok ALB for Datagrok Server
      FromPort: 80
      GroupId:
        Ref: ALBSecurityGroup
      IpProtocol: TCP
      ToPort: 80
    Type: AWS::EC2::SecurityGroupIngress
  Datagrok80IngressNatGW:
    Condition: InternetEgressAccess
    Properties:
      CidrIp:
        Fn::Sub:
        - ${ip}/32
        - ip:
            Ref: NatGatewayEIP
      Description:
        Fn::Sub: ${AWS::StackName} NatGW 80/tcp on Datagrok ALB for Datagrok Server
      FromPort: 80
      GroupId:
        Ref: ALBSecurityGroup
      IpProtocol: TCP
      ToPort: 80
    Type: AWS::EC2::SecurityGroupIngress
  Datagrok80IngressVPC:
    Properties:
      CidrIp:
        Ref: CIDR
      Description:
        Fn::Sub: ${AWS::StackName} VPC 80/tcp on Datagrok ALB for Datagrok Server
      FromPort: 80
      GroupId:
        Ref: ALBSecurityGroup
      IpProtocol: TCP
      ToPort: 80
    Type: AWS::EC2::SecurityGroupIngress
  DatagrokDNS:
    Condition: CreateDNS
    Properties:
      AliasTarget:
        DNSName:
          Fn::GetAtt:
          - LoadBalancerDatagrok
          - DNSName
        HostedZoneId:
          Fn::GetAtt:
          - LoadBalancerDatagrok
          - CanonicalHostedZoneID
      Comment:
        Fn::Sub: ${AWS::StackName} Public Datagrok DNS
      HostedZoneId:
        Ref: DNSZoneId
      Name:
        Fn::Sub:
        - ${AWS::StackName}-datagrok.${domain}.
        - domain:
            Ref: DNSDomain
      Type: A
    Type: AWS::Route53::RecordSet
  DatagrokDbAdminUser:
    Properties:
      Description: Datagrok Admin User First-login password
      GenerateSecretString:
        ExcludePunctuation: true
        GenerateStringKey: password
        PasswordLength: 32
        RequireEachIncludedType: true
        SecretStringTemplate: '{"user": "superuser"}'
    Type: AWS::SecretsManager::Secret
  DatagrokDbUser:
    Properties:
      Description: Datagrok Admin User First-login password
      GenerateSecretString:
        ExcludePunctuation: true
        GenerateStringKey: password
        PasswordLength: 32
        RequireEachIncludedType: true
        SecretStringTemplate: '{"user": "dg"}'
    Type: AWS::SecretsManager::Secret
  DatagrokEgress:
    Properties:
      Description:
        Fn::Sub: ${AWS::StackName} Datagrok egress rules
      DestinationSecurityGroupId:
        Ref: DatagrokSecurityGroup
      FromPort: 0
      GroupId:
        Ref: ALBSecurityGroup
      IpProtocol: TCP
      ToPort: 65535
    Type: AWS::EC2::SecurityGroupEgress
  DatagrokInsightsLogGroup:
    DeletionPolicy: Delete
    Properties:
      LogGroupName:
        Fn::Sub:
        - /aws/ecs/containerinsights/${cluster_name}/performance
        - cluster_name:
            Ref: Cluster
      RetentionInDays: 1
    Type: AWS::Logs::LogGroup
    UpdateReplacePolicy: Delete
  DatagrokPrivateDNS:
    Properties:
      AliasTarget:
        DNSName:
          Fn::GetAtt:
          - LoadBalancerIntDatagrok
          - DNSName
        HostedZoneId:
          Fn::GetAtt:
          - LoadBalancerIntDatagrok
          - CanonicalHostedZoneID
      Comment:
        Fn::Sub: ${AWS::StackName} Private Datagrok DNS for internal routing
      HostedZoneId:
        Ref: PrivateDNSZone
      Name:
        Fn::Sub: datagrok.${AWS::StackName}.datagrok.${AWS::Region}.lb.internal.
      Type: A
    Type: AWS::Route53::RecordSet
  DatagrokSecurityGroup:
    Properties:
      GroupDescription:
        Fn::Sub: ${AWS::StackName} Datagrok Security Group
      Tags:
      - Key: Name
        Value:
          Fn::Sub: ${AWS::StackName}-datagrok
      - Key: datagrok.component
        Value: datagrok
      VpcId:
        Ref: VPC
    Type: AWS::EC2::SecurityGroup
  DatagrokService:
    DependsOn:
    - TCP80Listener
    - TCP443Listener
    - TCP8080IntListener
    - S3
    - DB
    Properties:
      Cluster:
        Fn::GetAtt:
        - Cluster
        - Arn
      DeploymentConfiguration:
        MaximumPercent: 200
        MinimumHealthyPercent: 100
      DeploymentController:
        Type: ECS
      DesiredCount: 1
      LaunchType: FARGATE
      LoadBalancers:
      - ContainerName: datagrok
        ContainerPort: 8080
        TargetGroupArn:
          Ref: TCP8080TargetGroup
      - ContainerName: datagrok
        ContainerPort: 8080
        TargetGroupArn:
          Ref: TCP8080IntTargetGroup
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: ENABLED
          SecurityGroups:
          - Ref: DatagrokSecurityGroup
          Subnets:
          - Ref: PrivateSubnet1
          - Ref: PrivateSubnet2
      PlatformVersion: 1.4.0
      PropagateTags: SERVICE
      SchedulingStrategy: REPLICA
      ServiceRegistries:
      - RegistryArn:
          Fn::GetAtt:
          - ServiceDiscoveryEntry
          - Arn
      Tags:
      - Key: datagrok.component
        Value: datagrok
      - Key: datagrok.service
        Value: datagrok
      TaskDefinition:
        Ref: DatagrokTaskDefinition
    Type: AWS::ECS::Service
  DatagrokTaskDefinition:
    Properties:
      ContainerDefinitions:
      - Command:
        - Fn::Sub: ${AWS::Region}.compute.internal
        - Fn::Sub: ${AWS::StackName}.datagrok.${AWS::Region}.lb.internal
        - Fn::Sub: ${AWS::StackName}.datagrok.${AWS::Region}.cm.internal
        Essential: false
        Image:
          Fn::Sub:
          - ${domain}/${repo}:${tag}
          - domain:
              Fn::FindInMap:
              - Images
              - Searchdomain
              - domain
            repo:
              Fn::FindInMap:
              - Images
              - Searchdomain
              - repo
            tag:
              Fn::FindInMap:
              - Images
              - Searchdomain
              - version
        LogConfiguration:
          LogDriver: awslogs
          Options:
            awslogs-group:
              Ref: LogGroup
            awslogs-region:
              Ref: AWS::Region
            awslogs-stream-prefix: datagrok
        MemoryReservation: 100
        Name: ResolvConf
      - DependsOn:
        - Condition: SUCCESS
          ContainerName: ResolvConf
        Environment:
        - Name: GROK_MODE
          Value: auto
        - Name: GROK_PARAMETERS
          Value:
            Fn::Sub:
            - '{ "amazonStorageRegion": "${AWS::Region}", "amazonStorageBucket": "${bucket}",
              "dbServer": "${dbServer}", "dbPort": "${dbPort}", "db": "datagrok",
              "dbLogin": "${dbLogin}", "dbPassword": "${dbPassword}", "dbAdminLogin":
              "${dbAdminLogin}", "dbAdminPassword": "${dbAdminPassword}", "dbSsl":
              false, "deployDemo": false, "deployTestDemo": false, "adminPassword":
              "${adminPassword}", "adminDevKey": "${adminDevKey}" }'
            - adminDevKey:
                Fn::Sub:
                - '{{resolve:secretsmanager:${secret}:SecretString:password}}'
                - secret:
                    Ref: AdminDevKey
              adminPassword:
                Fn::Sub:
                - '{{resolve:secretsmanager:${secret}:SecretString:password}}'
                - secret:
                    Ref: AdminPassword
              bucket:
                Ref: S3
              dbAdminLogin:
                Fn::Sub:
                - '{{resolve:secretsmanager:${secret}:SecretString:user}}'
                - secret:
                    Ref: DatagrokDbAdminUser
              dbAdminPassword:
                Fn::Sub:
                - '{{resolve:secretsmanager:${secret}:SecretString:password}}'
                - secret:
                    Ref: DatagrokDbAdminUser
              dbLogin:
                Fn::Sub:
                - '{{resolve:secretsmanager:${secret}:SecretString:user}}'
                - secret:
                    Ref: DatagrokDbUser
              dbPassword:
                Fn::Sub:
                - '{{resolve:secretsmanager:${secret}:SecretString:password}}'
                - secret:
                    Ref: DatagrokDbUser
              dbPort:
                Fn::GetAtt:
                - DB
                - Endpoint.Port
              dbServer:
                Fn::GetAtt:
                - DB
                - Endpoint.Address
        Essential: true
        Image:
          Fn::Sub:
          - ${domain}/${repo}:${tag}
          - domain:
              Fn::FindInMap:
              - Images
              - Datagrok
              - domain
            repo:
              Fn::FindInMap:
              - Images
              - Datagrok
              - repo
            tag:
              Ref: DatagrokVersion
        LinuxParameters: {}
        LogConfiguration:
          LogDriver: awslogs
          Options:
            awslogs-group:
              Ref: LogGroup
            awslogs-region:
              Ref: AWS::Region
            awslogs-stream-prefix: datagrok
        MemoryReservation: 1024
        Name: datagrok
        PortMappings:
        - ContainerPort: 8080
          HostPort: 8080
          Protocol: tcp
      Cpu: '2048'
      ExecutionRoleArn:
        Fn::GetAtt:
        - TaskExecutionRole
        - Arn
      Family: datagrok
      Memory: '4096'
      NetworkMode: awsvpc
      RequiresCompatibilities:
      - FARGATE
      TaskRoleArn:
        Ref: TaskRole
    Type: AWS::ECS::TaskDefinition
  ECSPolicy:
    Properties:
      Description:
        Fn::Sub: ${AWS::StackName} Datagrok policy for ECS Services
      ManagedPolicyName:
        Fn::Sub: ${AWS::StackName}-ECSPolicy-${AWS::Region}
      PolicyDocument:
        Statement:
        - Action:
          - logs:CreateLogStream
          - logs:PutLogEvents
          Effect: Allow
          Resource:
          - Fn::GetAtt:
            - LogGroup
            - Arn
          - Fn::Sub:
            - ${log}:log-stream:*
            - log:
                Fn::GetAtt:
                - LogGroup
                - Arn
        - Action:
          - ecr:GetAuthorizationToken
          Effect: Allow
          Resource: '*'
        - Action:
          - ecr:BatchCheckLayerAvailability
          - ecr:BatchGetImage
          - ecr:GetDownloadUrlForLayer
          Effect: Allow
          Resource:
          - arn:aws:ecr:us-east-1:709825985650:repository/datagrok/*
          - Fn::Sub: arn:aws:ecr:${AWS::Region}:${AWS::AccountId}:repository/datagrok/*
        Version: '2012-10-17'
    Type: AWS::IAM::ManagedPolicy
  GrokComputeService:
    DependsOn:
    - CvmTCP80Listener
    - CvmTCP443Listener
    - CvmTCP8090IntListener
    - GrokComputeTCP5005ListenerRule
    - GrokComputeTCP5005IntListenerRule
    Properties:
      Cluster:
        Fn::GetAtt:
        - CvmCluster
        - Arn
      DeploymentConfiguration:
        MaximumPercent: 200
        MinimumHealthyPercent: 100
      DeploymentController:
        Type: ECS
      DesiredCount: 1
      LaunchType: FARGATE
      LoadBalancers:
      - ContainerName: grok_compute
        ContainerPort: 5005
        TargetGroupArn:
          Ref: GrokComputeTCP5005TargetGroup
      - ContainerName: grok_compute
        ContainerPort: 5005
        TargetGroupArn:
          Ref: GrokComputeTCP5005IntTargetGroup
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: DISABLED
          SecurityGroups:
          - Ref: CvmSecurityGroup
          Subnets:
          - Ref: PrivateSubnet1
          - Ref: PrivateSubnet2
      PlatformVersion: 1.4.0
      PropagateTags: SERVICE
      SchedulingStrategy: REPLICA
      ServiceRegistries:
      - RegistryArn:
          Fn::GetAtt:
          - GrokComputeServiceDiscoveryEntry
          - Arn
      Tags:
      - Key: Name
        Value:
          Fn::Sub: ${AWS::StackName} Datagrok CVM Grok Compute Service
      - Key: datagrok.component
        Value: cvm
      - Key: datagrok.service
        Value: grok_compute
      TaskDefinition:
        Ref: GrokComputeTaskDefinition
    Type: AWS::ECS::Service
  GrokComputeServiceDiscoveryEntry:
    Properties:
      Description:
        Fn::Sub: ${AWS::StackName} Datagrok CVM grok_compute service discovery entry
          in Cloud Map
      DnsConfig:
        DnsRecords:
        - TTL: 60
          Type: A
        RoutingPolicy: MULTIVALUE
      HealthCheckCustomConfig:
        FailureThreshold: 1
      Name: grok_compute
      NamespaceId:
        Ref: CloudMap
    Type: AWS::ServiceDiscovery::Service
  GrokComputeTCP5005IntListenerRule:
    Properties:
      Actions:
      - ForwardConfig:
          TargetGroups:
          - TargetGroupArn:
              Ref: GrokComputeTCP5005IntTargetGroup
        Type: forward
      Conditions:
      - Field: path-pattern
        PathPatternConfig:
          Values:
          - /grok_compute/*
      ListenerArn:
        Ref: CvmTCP8090IntListener
      Priority: 2
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
  GrokComputeTCP5005IntTargetGroup:
    Properties:
      HealthCheckPath: /grok_compute/info
      Matcher:
        HttpCode: 200
      Name:
        Fn::Sub: ${AWS::StackName}-datagrok-cvm-gc-i
      Port: 5005
      Protocol: HTTP
      Tags:
      - Key: datagrok.component
        Value: cvm
      TargetGroupAttributes:
      - Key: stickiness.enabled
        Value: true
      - Key: stickiness.type
        Value: lb_cookie
      - Key: stickiness.lb_cookie.duration_seconds
        Value: 86400
      TargetType: ip
      VpcId:
        Ref: VPC
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
  GrokComputeTCP5005ListenerRule:
    Properties:
      Actions:
      - ForwardConfig:
          TargetGroups:
          - TargetGroupArn:
              Ref: GrokComputeTCP5005TargetGroup
        Type: forward
      Conditions:
      - Field: path-pattern
        PathPatternConfig:
          Values:
          - /grok_compute/*
      ListenerArn:
        Ref: CvmTCP443Listener
      Priority: 2
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
  GrokComputeTCP5005TargetGroup:
    Properties:
      HealthCheckPath: /grok_compute/info
      Matcher:
        HttpCode: 200
      Name:
        Fn::Sub: ${AWS::StackName}-datagrok-cvm-gc
      Port: 5005
      Protocol: HTTP
      Tags:
      - Key: datagrok.component
        Value: cvm
      TargetGroupAttributes:
      - Key: stickiness.enabled
        Value: true
      - Key: stickiness.type
        Value: lb_cookie
      - Key: stickiness.lb_cookie.duration_seconds
        Value: 86400
      TargetType: ip
      VpcId:
        Ref: VPC
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
  GrokComputeTaskDefinition:
    Properties:
      ContainerDefinitions:
      - Command:
        - Fn::Sub: ${AWS::Region}.compute.internal
        - Fn::Sub: ${AWS::StackName}.datagrok.${AWS::Region}.lb.internal
        - Fn::Sub: ${AWS::StackName}.datagrok.${AWS::Region}.cm.internal
        Essential: false
        Image:
          Fn::Sub:
          - ${domain}/${repo}:${tag}
          - domain:
              Fn::FindInMap:
              - Images
              - Searchdomain
              - domain
            repo:
              Fn::FindInMap:
              - Images
              - Searchdomain
              - repo
            tag:
              Fn::FindInMap:
              - Images
              - Searchdomain
              - version
        LogConfiguration:
          LogDriver: awslogs
          Options:
            awslogs-group:
              Ref: LogGroup
            awslogs-region:
              Ref: AWS::Region
            awslogs-stream-prefix: cvm
        MemoryReservation: 100
        Name: ResolvConf
      - DependsOn:
        - Condition: SUCCESS
          ContainerName: ResolvConf
        Environment:
        - Name: GROK_COMPUTE_NUM_CORES
          Value: '2'
        Essential: true
        Image:
          Fn::Sub:
          - ${domain}/${repo}:${tag}
          - domain:
              Fn::FindInMap:
              - Images
              - GrokCompute
              - domain
            repo:
              Fn::FindInMap:
              - Images
              - GrokCompute
              - repo
            tag:
              Ref: GrokComputeVersion
        LinuxParameters: {}
        LogConfiguration:
          LogDriver: awslogs
          Options:
            awslogs-group:
              Ref: LogGroup
            awslogs-region:
              Ref: AWS::Region
            awslogs-stream-prefix: cvm
        MemoryReservation: 1024
        Name: grok_compute
        PortMappings:
        - ContainerPort: 5005
          HostPort: 5005
          Protocol: tcp
      Cpu: '1024'
      ExecutionRoleArn:
        Fn::GetAtt:
        - TaskExecutionRole
        - Arn
      Family:
        Fn::Sub: ${AWS::StackName}-datagrok-cvm-grok_compute
      Memory: '2048'
      NetworkMode: awsvpc
      RequiresCompatibilities:
      - FARGATE
    Type: AWS::ECS::TaskDefinition
  GrokConnectPrivateDNS:
    Properties:
      AliasTarget:
        DNSName:
          Fn::GetAtt:
          - LoadBalancerIntDatagrok
          - DNSName
        HostedZoneId:
          Fn::GetAtt:
          - LoadBalancerIntDatagrok
          - CanonicalHostedZoneID
      Comment:
        Fn::Sub: ${AWS::StackName} Private Datagrok grok connect DNS for internal
          routing
      HostedZoneId:
        Ref: PrivateDNSZone
      Name:
        Fn::Sub: grok_connect.${AWS::StackName}.datagrok.${AWS::Region}.lb.internal.
      Type: A
    Type: AWS::Route53::RecordSet
  GrokConnectService:
    DependsOn:
    - TCP1234IntListener
    Properties:
      Cluster:
        Fn::GetAtt:
        - Cluster
        - Arn
      DeploymentConfiguration:
        MaximumPercent: 200
        MinimumHealthyPercent: 100
      DeploymentController:
        Type: ECS
      DesiredCount: 1
      LaunchType: FARGATE
      LoadBalancers:
      - ContainerName: grok_connect
        ContainerPort: 1234
        TargetGroupArn:
          Ref: TCP1234IntTargetGroup
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: ENABLED
          SecurityGroups:
          - Ref: DatagrokSecurityGroup
          Subnets:
          - Ref: PrivateSubnet1
          - Ref: PrivateSubnet2
      PlatformVersion: 1.4.0
      PropagateTags: SERVICE
      SchedulingStrategy: REPLICA
      ServiceRegistries:
      - RegistryArn:
          Fn::GetAtt:
          - GrokConnectServiceDiscoveryEntry
          - Arn
      Tags:
      - Key: datagrok.component
        Value: datagrok
      - Key: datagrok.service
        Value: grok_connect
      TaskDefinition:
        Ref: GrokConnectTaskDefinition
    Type: AWS::ECS::Service
  GrokConnectServiceDiscoveryEntry:
    Properties:
      Description:
        Fn::Sub: ${AWS::StackName} Datagrok grok_connect service discovery entry in
          Cloud Map
      DnsConfig:
        DnsRecords:
        - TTL: 60
          Type: A
        RoutingPolicy: MULTIVALUE
      HealthCheckCustomConfig:
        FailureThreshold: 1
      Name: grok_connect
      NamespaceId:
        Ref: CloudMap
    Type: AWS::ServiceDiscovery::Service
  GrokConnectTaskDefinition:
    Properties:
      ContainerDefinitions:
      - Command:
        - Fn::Sub: ${AWS::Region}.compute.internal
        - Fn::Sub: ${AWS::StackName}.datagrok.${AWS::Region}.lb.internal
        - Fn::Sub: ${AWS::StackName}.datagrok.${AWS::Region}.cm.internal
        Essential: false
        Image:
          Fn::Sub:
          - ${domain}/${repo}:${tag}
          - domain:
              Fn::FindInMap:
              - Images
              - Searchdomain
              - domain
            repo:
              Fn::FindInMap:
              - Images
              - Searchdomain
              - repo
            tag:
              Fn::FindInMap:
              - Images
              - Searchdomain
              - version
        LogConfiguration:
          LogDriver: awslogs
          Options:
            awslogs-group:
              Ref: LogGroup
            awslogs-region:
              Ref: AWS::Region
            awslogs-stream-prefix: grok_connect
        MemoryReservation: 100
        Name: ResolvConf
      - DependsOn:
        - Condition: SUCCESS
          ContainerName: ResolvConf
        Essential: true
        Image:
          Fn::Sub:
          - ${domain}/${repo}:${tag}
          - domain:
              Fn::FindInMap:
              - Images
              - GrokConnect
              - domain
            repo:
              Fn::FindInMap:
              - Images
              - GrokConnect
              - repo
            tag:
              Ref: GrokConnectVersion
        LinuxParameters: {}
        LogConfiguration:
          LogDriver: awslogs
          Options:
            awslogs-group:
              Ref: LogGroup
            awslogs-region:
              Ref: AWS::Region
            awslogs-stream-prefix: grok_connect
        MemoryReservation: 1024
        Name: grok_connect
        PortMappings:
        - ContainerPort: 1234
          HostPort: 1234
          Protocol: tcp
      Cpu: '1024'
      ExecutionRoleArn:
        Fn::GetAtt:
        - TaskExecutionRole
        - Arn
      Family: grok_connect
      Memory: '2048'
      NetworkMode: awsvpc
      RequiresCompatibilities:
      - FARGATE
    Type: AWS::ECS::TaskDefinition
  GrokSpawnerECRPolicy:
    Properties:
      Description:
        Fn::Sub: ${AWS::StackName} Grok Spawner ECR policy to access AWS resources
      ManagedPolicyName:
        Fn::Sub: ${AWS::StackName}-GrokSpawner-ECR-${AWS::Region}
      PolicyDocument:
        Statement:
        - Action:
          - ecr:GetAuthorizationToken
          Effect: Allow
          Resource: '*'
        - Action:
          - ecr:CreateRepository
          Condition:
            StringEquals:
              aws:RequestTag/builder:
              - grok_spawner
          Effect: Allow
          Resource: '*'
        - Action:
          - ecr:TagResource
          Condition:
            StringEquals:
              aws:RequestTag/builder:
              - grok_spawner
          Effect: Allow
          Resource:
            Fn::Sub: arn:aws:ecr:${AWS::Region}:${AWS::AccountId}:repository/datagrok/*
        - Action:
          - ecr:DescribeRepositories
          - ecr:ListImages
          Effect: Allow
          Resource:
            Fn::Sub: arn:aws:ecr:${AWS::Region}:${AWS::AccountId}:repository/datagrok/*
        Version: '2012-10-17'
    Type: AWS::IAM::ManagedPolicy
  GrokSpawnerKanikoPolicy:
    Properties:
      Description:
        Fn::Sub: ${AWS::StackName} Grok Spawner ECR policy to access AWS resources
      ManagedPolicyName:
        Fn::Sub: ${AWS::StackName}-GrokSpawner-Kaniko-${AWS::Region}
      PolicyDocument:
        Statement:
        - Action:
          - ecs:RunTask
          Condition:
            ArnEquals:
              ecs:cluster:
                Fn::GetAtt:
                - Cluster
                - Arn
          Effect: Allow
          Resource:
            Ref: KanikoTaskDefinition
        - Action:
          - iam:PassRole
          Effect: Allow
          Resource:
          - Fn::GetAtt:
            - KanikoTaskRole
            - Arn
          - Fn::GetAtt:
            - TaskExecutionRole
            - Arn
        - Action:
          - s3:GetObject
          - s3:PutObject
          - s3:ListBucket
          Effect: Allow
          Resource:
          - Fn::GetAtt:
            - S3
            - Arn
          - Fn::Sub:
            - ${bucket}/dockerfiles/*
            - bucket:
                Fn::GetAtt:
                - S3
                - Arn
        Version: '2012-10-17'
    Type: AWS::IAM::ManagedPolicy
  GrokSpawnerPolicy:
    Properties:
      Description:
        Fn::Sub: ${AWS::StackName} Grok Spawner policy to access AWS resources
      ManagedPolicyName:
        Fn::Sub: ${AWS::StackName}-GrokSpawner-${AWS::Region}
      PolicyDocument:
        Statement:
        - Action:
          - ecs:ListTasks
          Condition:
            ArnEquals:
              ecs:cluster:
                Fn::GetAtt:
                - Cluster
                - Arn
          Effect: Allow
          Resource: '*'
        - Action:
          - ecs:RegisterTaskDefinition
          Condition:
            StringEquals:
              aws:RequestTag/caller:
              - grok_spawner
          Effect: Allow
          Resource: '*'
        - Action:
          - ecs:DescribeTaskDefinition
          Condition: {}
          Effect: Allow
          Resource: '*'
        - Action:
          - ecs:DescribeServices
          - ecs:UpdateService
          Condition:
            ArnEquals:
              ecs:cluster:
                Fn::GetAtt:
                - Cluster
                - Arn
          Effect: Allow
          Resource:
            Fn::Sub:
            - arn:aws:ecs:${AWS::Region}:${AWS::AccountId}:service/${cluster_name}/*
            - cluster_name:
                Ref: Cluster
        - Action:
          - ecs:CreateService
          Condition:
            ArnEquals:
              ecs:cluster:
                Fn::GetAtt:
                - Cluster
                - Arn
            StringEquals:
              aws:RequestTag/caller:
              - grok_spawner
          Effect: Allow
          Resource:
            Fn::Sub:
            - arn:aws:ecs:${AWS::Region}:${AWS::AccountId}:service/${cluster_name}/*
            - cluster_name:
                Ref: Cluster
        - Action:
          - ecs:DescribeTasks
          Condition:
            ArnEquals:
              ecs:cluster:
                Fn::GetAtt:
                - Cluster
                - Arn
          Effect: Allow
          Resource:
            Fn::Sub:
            - arn:aws:ecs:${AWS::Region}:${AWS::AccountId}:task/${cluster_name}/*
            - cluster_name:
                Ref: Cluster
        - Action:
          - logs:GetLogEvents
          Effect: Allow
          Resource:
            Fn::Sub:
            - ${log_group}:log-stream:grok_spawner/*
            - log_group:
                Fn::GetAtt:
                - LogGroup
                - Arn
        Version: '2012-10-17'
    Type: AWS::IAM::ManagedPolicy
  GrokSpawnerPrivateDNS:
    Properties:
      AliasTarget:
        DNSName:
          Fn::GetAtt:
          - LoadBalancerIntDatagrok
          - DNSName
        HostedZoneId:
          Fn::GetAtt:
          - LoadBalancerIntDatagrok
          - CanonicalHostedZoneID
      Comment:
        Fn::Sub: ${AWS::StackName} Private Datagrok grok spawner DNS for internal
          routing
      HostedZoneId:
        Ref: PrivateDNSZone
      Name:
        Fn::Sub: grok_spawner.${AWS::StackName}.datagrok.${AWS::Region}.lb.internal.
      Type: A
    Type: AWS::Route53::RecordSet
  GrokSpawnerService:
    DependsOn:
    - TCP8000IntListener
    Properties:
      Cluster:
        Fn::GetAtt:
        - Cluster
        - Arn
      DeploymentConfiguration:
        MaximumPercent: 200
        MinimumHealthyPercent: 100
      DeploymentController:
        Type: ECS
      DesiredCount: 1
      LaunchType: FARGATE
      LoadBalancers:
      - ContainerName: grok_spawner
        ContainerPort: 8000
        TargetGroupArn:
          Ref: TCP8000IntTargetGroup
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: ENABLED
          SecurityGroups:
          - Ref: DatagrokSecurityGroup
          Subnets:
          - Ref: PrivateSubnet1
          - Ref: PrivateSubnet2
      PlatformVersion: 1.4.0
      PropagateTags: SERVICE
      SchedulingStrategy: REPLICA
      ServiceRegistries:
      - RegistryArn:
          Fn::GetAtt:
          - GrokSpawnerServiceDiscoveryEntry
          - Arn
      Tags:
      - Key: datagrok.component
        Value: datagrok
      - Key: datagrok.service
        Value: grok_spawner
      TaskDefinition:
        Ref: GrokSpawnerTaskDefinition
    Type: AWS::ECS::Service
  GrokSpawnerServiceDiscoveryEntry:
    Properties:
      Description:
        Fn::Sub: ${AWS::StackName} Datagrok grok_spawner service discovery entry in
          Cloud Map
      DnsConfig:
        DnsRecords:
        - TTL: 60
          Type: A
        RoutingPolicy: MULTIVALUE
      HealthCheckCustomConfig:
        FailureThreshold: 1
      Name: grok_spawner
      NamespaceId:
        Ref: CloudMap
    Type: AWS::ServiceDiscovery::Service
  GrokSpawnerTaskDefinition:
    Properties:
      ContainerDefinitions:
      - Command:
        - Fn::Sub: ${AWS::Region}.compute.internal
        - Fn::Sub: ${AWS::StackName}.datagrok.${AWS::Region}.lb.internal
        - Fn::Sub: ${AWS::StackName}.datagrok.${AWS::Region}.cm.internal
        Essential: false
        Image:
          Fn::Sub:
          - ${domain}/${repo}:${tag}
          - domain:
              Fn::FindInMap:
              - Images
              - Searchdomain
              - domain
            repo:
              Fn::FindInMap:
              - Images
              - Searchdomain
              - repo
            tag:
              Fn::FindInMap:
              - Images
              - Searchdomain
              - version
        LogConfiguration:
          LogDriver: awslogs
          Options:
            awslogs-group:
              Ref: LogGroup
            awslogs-region:
              Ref: AWS::Region
            awslogs-stream-prefix: grok_spawner
        MemoryReservation: 100
        Name: ResolvConf
      - DependsOn:
        - Condition: SUCCESS
          ContainerName: ResolvConf
        Environment:
        - Name: DOCKER_REGISTRY_SECRET_ARN
          Value: ''
        - Name: ECS_SUBNETS
          Value:
            Fn::Sub:
            - '["${s1}", "${s2}"]'
            - s1:
                Ref: PrivateSubnet1
              s2:
                Ref: PrivateSubnet2
        - Name: ECS_SECURITY_GROUPS
          Value:
            Fn::Sub:
            - '["${s1}"]'
            - s1:
                Ref: DatagrokSecurityGroup
        - Name: ECS_EXEC_ROLE
          Value:
            Fn::GetAtt:
            - TaskExecutionRole
            - Arn
        - Name: GROK_SPAWNER_ENVIRONMENT
          Value:
            Fn::Sub: ${AWS::StackName}
        - Name: KANIKO_S3_BUCKET
          Value:
            Ref: S3
        - Name: KANIKO_TASK_DEFINITION
          Value:
            Ref: KanikoTaskDefinition
        - Name: ECS_LOG_GROUP
          Value:
            Fn::Sub:
            - arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:${logs}
            - logs:
                Ref: LogGroup
        Essential: true
        Image:
          Fn::Sub:
          - ${domain}/${repo}:${tag}
          - domain:
              Fn::FindInMap:
              - Images
              - GrokSpawner
              - domain
            repo:
              Fn::FindInMap:
              - Images
              - GrokSpawner
              - repo
            tag:
              Ref: GrokSpawnerVersion
        LinuxParameters: {}
        LogConfiguration:
          LogDriver: awslogs
          Options:
            awslogs-group:
              Ref: LogGroup
            awslogs-region:
              Ref: AWS::Region
            awslogs-stream-prefix: grok_spawner
        MemoryReservation: 100
        Name: grok_spawner
        PortMappings:
        - ContainerPort: 8000
          HostPort: 8000
          Protocol: tcp
      Cpu: '256'
      ExecutionRoleArn:
        Fn::GetAtt:
        - TaskExecutionRole
        - Arn
      Family: grok_spawner
      Memory: '512'
      NetworkMode: awsvpc
      RequiresCompatibilities:
      - FARGATE
      TaskRoleArn:
        Ref: GrokSpawnerTaskRole
    Type: AWS::ECS::TaskDefinition
  GrokSpawnerTaskRole:
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Action:
          - sts:AssumeRole
          Condition: {}
          Effect: Allow
          Principal:
            Service: ecs-tasks.amazonaws.com
        Version: '2012-10-17'
      ManagedPolicyArns:
      - Ref: GrokSpawnerPolicy
      - Ref: GrokSpawnerECRPolicy
      - Ref: GrokSpawnerKanikoPolicy
      - Ref: ECSPolicy
      Tags:
      - Key: datagrok.component
        Value: datagrok
      - Key: datagrok.service
        Value: grok_spawner
    Type: AWS::IAM::Role
  H2oPrivateDNS:
    Properties:
      AliasTarget:
        DNSName:
          Fn::GetAtt:
          - LoadBalancerIntCvm
          - DNSName
        HostedZoneId:
          Fn::GetAtt:
          - LoadBalancerIntCvm
          - CanonicalHostedZoneID
      Comment:
        Fn::Sub: ${AWS::StackName} Private Datagrok H2O DNS for internal routing
      HostedZoneId:
        Ref: PrivateDNSZone
      Name:
        Fn::Sub: h2o.${AWS::StackName}.datagrok.${AWS::Region}.lb.internal.
      Type: A
    Type: AWS::Route53::RecordSet
  H2oService:
    DependsOn:
    - H2oTCP5005Listener
    - H2oTCP5005IntListener
    - H2oTCP54321Listener
    - H2oTCP54321IntListener
    Properties:
      Cluster:
        Fn::GetAtt:
        - CvmCluster
        - Arn
      DeploymentConfiguration:
        MaximumPercent: 200
        MinimumHealthyPercent: 100
      DeploymentController:
        Type: ECS
      DesiredCount: 1
      LaunchType: FARGATE
      LoadBalancers:
      - ContainerName: h2o
        ContainerPort: 5005
        TargetGroupArn:
          Ref: H2oTCP5005TargetGroup
      - ContainerName: h2o
        ContainerPort: 54321
        TargetGroupArn:
          Ref: H2oTCP54321TargetGroup
      - ContainerName: h2o
        ContainerPort: 5005
        TargetGroupArn:
          Ref: H2oTCP5005IntTargetGroup
      - ContainerName: h2o
        ContainerPort: 54321
        TargetGroupArn:
          Ref: H2oTCP54321IntTargetGroup
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: ENABLED
          SecurityGroups:
          - Ref: CvmSecurityGroup
          Subnets:
          - Ref: PrivateSubnet1
          - Ref: PrivateSubnet2
      PlatformVersion: 1.4.0
      PropagateTags: SERVICE
      SchedulingStrategy: REPLICA
      ServiceRegistries:
      - RegistryArn:
          Fn::GetAtt:
          - H2oServiceDiscoveryEntry
          - Arn
      Tags:
      - Key: Name
        Value:
          Fn::Sub: ${AWS::StackName} Datagrok CVM H2O Service
      - Key: datagrok.component
        Value: cvm
      - Key: datagrok.service
        Value: h2o
      TaskDefinition:
        Ref: H2oTaskDefinition
    Type: AWS::ECS::Service
  H2oServiceDiscoveryEntry:
    Properties:
      Description:
        Fn::Sub: ${AWS::StackName} Datagrok CVM h2o service discovery entry in Cloud
          Map
      DnsConfig:
        DnsRecords:
        - TTL: 60
          Type: A
        RoutingPolicy: MULTIVALUE
      HealthCheckCustomConfig:
        FailureThreshold: 1
      Name: h2o
      NamespaceId:
        Ref: CloudMap
    Type: AWS::ServiceDiscovery::Service
  H2oTCP5005IntListener:
    Properties:
      DefaultActions:
      - ForwardConfig:
          TargetGroups:
          - TargetGroupArn:
              Ref: H2oTCP5005IntTargetGroup
        Type: forward
      LoadBalancerArn:
        Ref: LoadBalancerIntCvm
      Port: 5005
      Protocol: HTTP
    Type: AWS::ElasticLoadBalancingV2::Listener
  H2oTCP5005IntTargetGroup:
    Properties:
      HealthCheckPath: /helper/info
      Matcher:
        HttpCode: '200'
      Name:
        Fn::Sub: ${AWS::StackName}-datagrok-cvm-h2o-gh-i
      Port: 5005
      Protocol: HTTP
      Tags:
      - Key: datagrok.component
        Value: cvm
      TargetGroupAttributes:
      - Key: stickiness.enabled
        Value: 'true'
      - Key: stickiness.type
        Value: lb_cookie
      - Key: stickiness.lb_cookie.duration_seconds
        Value: '86400'
      TargetType: ip
      VpcId:
        Ref: VPC
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
  H2oTCP5005Listener:
    Properties:
      Certificates:
      - CertificateArn:
          Ref: ArnSSLCertificate
      DefaultActions:
      - ForwardConfig:
          TargetGroups:
          - TargetGroupArn:
              Ref: H2oTCP5005TargetGroup
        Type: forward
      LoadBalancerArn:
        Ref: LoadBalancerCvm
      Port: 5005
      Protocol: HTTPS
    Type: AWS::ElasticLoadBalancingV2::Listener
  H2oTCP5005TargetGroup:
    Properties:
      HealthCheckPath: /helper/info
      Matcher:
        HttpCode: '200'
      Name:
        Fn::Sub: ${AWS::StackName}-datagrok-cvm-h2o-gh
      Port: 5005
      Protocol: HTTP
      Tags:
      - Key: datagrok.component
        Value: cvm
      TargetGroupAttributes:
      - Key: stickiness.enabled
        Value: 'true'
      - Key: stickiness.type
        Value: lb_cookie
      - Key: stickiness.lb_cookie.duration_seconds
        Value: '86400'
      TargetType: ip
      VpcId:
        Ref: VPC
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
  H2oTCP54321IntListener:
    Properties:
      DefaultActions:
      - ForwardConfig:
          TargetGroups:
          - TargetGroupArn:
              Ref: H2oTCP54321IntTargetGroup
        Type: forward
      LoadBalancerArn:
        Ref: LoadBalancerIntCvm
      Port: 54321
      Protocol: HTTP
    Type: AWS::ElasticLoadBalancingV2::Listener
  H2oTCP54321IntTargetGroup:
    Properties:
      HealthCheckPath: /3/About
      Matcher:
        HttpCode: '200'
      Name:
        Fn::Sub: ${AWS::StackName}-datagrok-cvm-h2o-i
      Port: 54321
      Protocol: HTTP
      Tags:
      - Key: datagrok.component
        Value: cvm
      TargetGroupAttributes:
      - Key: stickiness.enabled
        Value: 'true'
      - Key: stickiness.type
        Value: lb_cookie
      - Key: stickiness.lb_cookie.duration_seconds
        Value: '86400'
      TargetType: ip
      VpcId:
        Ref: VPC
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
  H2oTCP54321Listener:
    Properties:
      Certificates:
      - CertificateArn:
          Ref: ArnSSLCertificate
      DefaultActions:
      - ForwardConfig:
          TargetGroups:
          - TargetGroupArn:
              Ref: H2oTCP54321TargetGroup
        Type: forward
      LoadBalancerArn:
        Ref: LoadBalancerCvm
      Port: 54321
      Protocol: HTTPS
    Type: AWS::ElasticLoadBalancingV2::Listener
  H2oTCP54321TargetGroup:
    Properties:
      HealthCheckPath: /3/About
      Matcher:
        HttpCode: '200'
      Name:
        Fn::Sub: ${AWS::StackName}-datagrok-cvm-h2o
      Port: 54321
      Protocol: HTTP
      Tags:
      - Key: datagrok.component
        Value: cvm
      TargetGroupAttributes:
      - Key: stickiness.enabled
        Value: 'true'
      - Key: stickiness.type
        Value: lb_cookie
      - Key: stickiness.lb_cookie.duration_seconds
        Value: '86400'
      TargetType: ip
      VpcId:
        Ref: VPC
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
  H2oTaskDefinition:
    Properties:
      ContainerDefinitions:
      - Command:
        - Fn::Sub: ${AWS::Region}.compute.internal
        - Fn::Sub: ${AWS::StackName}.datagrok.${AWS::Region}.lb.internal
        - Fn::Sub: ${AWS::StackName}.datagrok.${AWS::Region}.cm.internal
        Essential: false
        Image:
          Fn::Sub:
          - ${domain}/${repo}:${tag}
          - domain:
              Fn::FindInMap:
              - Images
              - Searchdomain
              - domain
            repo:
              Fn::FindInMap:
              - Images
              - Searchdomain
              - repo
            tag:
              Fn::FindInMap:
              - Images
              - Searchdomain
              - version
        LogConfiguration:
          LogDriver: awslogs
          Options:
            awslogs-group:
              Ref: LogGroup
            awslogs-region:
              Ref: AWS::Region
            awslogs-stream-prefix: cvm
        MemoryReservation: 100
        Name: ResolvConf
      - DependsOn:
        - Condition: SUCCESS
          ContainerName: ResolvConf
        Essential: true
        Image:
          Fn::Sub:
          - ${domain}/${repo}:${tag}
          - domain:
              Fn::FindInMap:
              - Images
              - H2o
              - domain
            repo:
              Fn::FindInMap:
              - Images
              - H2o
              - repo
            tag:
              Ref: H2oVersion
        LinuxParameters: {}
        LogConfiguration:
          LogDriver: awslogs
          Options:
            awslogs-group:
              Ref: LogGroup
            awslogs-region:
              Ref: AWS::Region
            awslogs-stream-prefix: cvm
        MemoryReservation: 1024
        Name: h2o
        PortMappings:
        - ContainerPort: 5005
          HostPort: 5005
          Protocol: tcp
        - ContainerPort: 54321
          HostPort: 54321
          Protocol: tcp
      Cpu: '512'
      ExecutionRoleArn:
        Fn::GetAtt:
        - TaskExecutionRole
        - Arn
      Family:
        Fn::Sub: ${AWS::StackName}-datagrok-cvm-h2o
      Memory: '2048'
      NetworkMode: awsvpc
      RequiresCompatibilities:
      - FARGATE
    Type: AWS::ECS::TaskDefinition
  InternetGateway:
    Condition: CreatePublicSubnets
    Properties:
      Tags:
      - Key: Name
        Value:
          Fn::Sub: ${AWS::StackName} Datagrok Internet Gateway
      - Key: datagrok.component
        Value: common
    Type: AWS::EC2::InternetGateway
  InternetGatewayAttach:
    Condition: CreatePublicSubnets
    Properties:
      InternetGatewayId:
        Ref: InternetGateway
      VpcId:
        Ref: VPC
    Type: AWS::EC2::VPCGatewayAttachment
  JupyterKernelGatewayService:
    DependsOn:
    - CvmTCP80Listener
    - CvmTCP443Listener
    - CvmTCP8090IntListener
    - JupyterKernelGatewayTCP5005ListenerRule
    - JupyterKernelGatewayTCP5005IntListenerRule
    - JupyterKernelGatewayTCP8888ListenerRule
    - JupyterKernelGatewayTCP8888IntListenerRule
    Properties:
      Cluster:
        Fn::GetAtt:
        - CvmCluster
        - Arn
      DeploymentConfiguration:
        MaximumPercent: 200
        MinimumHealthyPercent: 100
      DeploymentController:
        Type: ECS
      DesiredCount: 1
      LaunchType: FARGATE
      LoadBalancers:
      - ContainerName: jupyter_kernel_gateway
        ContainerPort: 5005
        TargetGroupArn:
          Ref: JupyterKernelGatewayTCP5005TargetGroup
      - ContainerName: jupyter_kernel_gateway
        ContainerPort: 8888
        TargetGroupArn:
          Ref: JupyterKernelGatewayTCP8888TargetGroup
      - ContainerName: jupyter_kernel_gateway
        ContainerPort: 5005
        TargetGroupArn:
          Ref: JupyterKernelGatewayTCP5005IntTargetGroup
      - ContainerName: jupyter_kernel_gateway
        ContainerPort: 8888
        TargetGroupArn:
          Ref: JupyterKernelGatewayTCP8888IntTargetGroup
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: ENABLED
          SecurityGroups:
          - Ref: CvmSecurityGroup
          Subnets:
          - Ref: PrivateSubnet1
          - Ref: PrivateSubnet2
      PlatformVersion: 1.4.0
      PropagateTags: SERVICE
      SchedulingStrategy: REPLICA
      ServiceRegistries:
      - RegistryArn:
          Fn::GetAtt:
          - JupyterKernelGatewayServiceDiscoveryEntry
          - Arn
      Tags:
      - Key: datagrok.component
        Value: cvm
      - Key: datagrok.service
        Value: jupyter_kernel_gateway
      TaskDefinition:
        Ref: JupyterKernelGatewayTaskDefinition
    Type: AWS::ECS::Service
  JupyterKernelGatewayServiceDiscoveryEntry:
    Properties:
      Description:
        Fn::Sub: ${AWS::StackName} Datagrok CVM 'jupyter_kernel_gateway' service discovery
          entry in Cloud Map
      DnsConfig:
        DnsRecords:
        - TTL: 60
          Type: A
        RoutingPolicy: MULTIVALUE
      HealthCheckCustomConfig:
        FailureThreshold: 1
      Name: jupyter_kernel_gateway
      NamespaceId:
        Ref: CloudMap
    Type: AWS::ServiceDiscovery::Service
  JupyterKernelGatewayTCP5005IntListenerRule:
    Properties:
      Actions:
      - ForwardConfig:
          TargetGroups:
          - TargetGroupArn:
              Ref: JupyterKernelGatewayTCP5005IntTargetGroup
        Type: forward
      Conditions:
      - Field: path-pattern
        PathPatternConfig:
          Values:
          - /jupyter/helper/*
      ListenerArn:
        Ref: CvmTCP8090IntListener
      Priority: 3
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
  JupyterKernelGatewayTCP5005IntTargetGroup:
    Properties:
      HealthCheckPath: /jupyter/helper/info
      Matcher:
        HttpCode: 200
      Name:
        Fn::Sub: ${AWS::StackName}-datagrok-cvm-jkg-gh-i
      Port: 5005
      Protocol: HTTP
      Tags:
      - Key: datagrok.component
        Value: cvm
      TargetGroupAttributes:
      - Key: stickiness.enabled
        Value: true
      - Key: stickiness.type
        Value: lb_cookie
      - Key: stickiness.lb_cookie.duration_seconds
        Value: 86400
      TargetType: ip
      VpcId:
        Ref: VPC
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
  JupyterKernelGatewayTCP5005ListenerRule:
    Properties:
      Actions:
      - ForwardConfig:
          TargetGroups:
          - TargetGroupArn:
              Ref: JupyterKernelGatewayTCP5005TargetGroup
        Type: forward
      Conditions:
      - Field: path-pattern
        PathPatternConfig:
          Values:
          - /jupyter/helper/*
      ListenerArn:
        Ref: CvmTCP443Listener
      Priority: 3
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
  JupyterKernelGatewayTCP5005TargetGroup:
    Properties:
      HealthCheckPath: /jupyter/helper/info
      Matcher:
        HttpCode: 200
      Name:
        Fn::Sub: ${AWS::StackName}-datagrok-cvm-jkg-gh
      Port: 5005
      Protocol: HTTP
      Tags:
      - Key: datagrok.component
        Value: cvm
      TargetGroupAttributes:
      - Key: stickiness.enabled
        Value: true
      - Key: stickiness.type
        Value: lb_cookie
      - Key: stickiness.lb_cookie.duration_seconds
        Value: 86400
      TargetType: ip
      VpcId:
        Ref: VPC
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
  JupyterKernelGatewayTCP8888IntListenerRule:
    Properties:
      Actions:
      - ForwardConfig:
          TargetGroups:
          - TargetGroupArn:
              Ref: JupyterKernelGatewayTCP8888IntTargetGroup
        Type: forward
      Conditions:
      - Field: path-pattern
        PathPatternConfig:
          Values:
          - /jupyter/*
      ListenerArn:
        Ref: CvmTCP8090IntListener
      Priority: 4
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
  JupyterKernelGatewayTCP8888IntTargetGroup:
    Properties:
      HealthCheckPath: /jupyter/api/swagger.yaml
      Matcher:
        HttpCode: 200
      Name:
        Fn::Sub: ${AWS::StackName}-datagrok-cvm-jkg-i
      Port: 8888
      Protocol: HTTP
      Tags:
      - Key: com.docker.compose.project
        Value: cvm
      TargetGroupAttributes:
      - Key: stickiness.enabled
        Value: true
      - Key: stickiness.type
        Value: lb_cookie
      - Key: stickiness.lb_cookie.duration_seconds
        Value: 86400
      TargetType: ip
      VpcId:
        Ref: VPC
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
  JupyterKernelGatewayTCP8888ListenerRule:
    Properties:
      Actions:
      - ForwardConfig:
          TargetGroups:
          - TargetGroupArn:
              Ref: JupyterKernelGatewayTCP8888TargetGroup
        Type: forward
      Conditions:
      - Field: path-pattern
        PathPatternConfig:
          Values:
          - /jupyter/*
      ListenerArn:
        Ref: CvmTCP443Listener
      Priority: 4
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
  JupyterKernelGatewayTCP8888TargetGroup:
    Properties:
      HealthCheckPath: /jupyter/api/swagger.yaml
      Matcher:
        HttpCode: 200
      Name:
        Fn::Sub: ${AWS::StackName}-datagrok-cvm-jkg
      Port: 8888
      Protocol: HTTP
      Tags:
      - Key: com.docker.compose.project
        Value: cvm
      TargetGroupAttributes:
      - Key: stickiness.enabled
        Value: true
      - Key: stickiness.type
        Value: lb_cookie
      - Key: stickiness.lb_cookie.duration_seconds
        Value: 86400
      TargetType: ip
      VpcId:
        Ref: VPC
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
  JupyterKernelGatewayTaskDefinition:
    Properties:
      ContainerDefinitions:
      - Command:
        - Fn::Sub: ${AWS::Region}.compute.internal
        - Fn::Sub: ${AWS::StackName}.datagrok.${AWS::Region}.lb.internal
        - Fn::Sub: ${AWS::StackName}.datagrok.${AWS::Region}.cm.internal
        Essential: false
        Image:
          Fn::Sub:
          - ${domain}/${repo}:${tag}
          - domain:
              Fn::FindInMap:
              - Images
              - Searchdomain
              - domain
            repo:
              Fn::FindInMap:
              - Images
              - Searchdomain
              - repo
            tag:
              Fn::FindInMap:
              - Images
              - Searchdomain
              - version
        LogConfiguration:
          LogDriver: awslogs
          Options:
            awslogs-group:
              Ref: LogGroup
            awslogs-region:
              Ref: AWS::Region
            awslogs-stream-prefix: cvm
        MemoryReservation: 100
        Name: ResolvConf
      - DependsOn:
        - Condition: SUCCESS
          ContainerName: ResolvConf
        Essential: true
        Image:
          Fn::Sub:
          - ${domain}/${repo}:${tag}
          - domain:
              Fn::FindInMap:
              - Images
              - JKG
              - domain
            repo:
              Fn::FindInMap:
              - Images
              - JKG
              - repo
            tag:
              Ref: JKGVersion
        LinuxParameters: {}
        LogConfiguration:
          LogDriver: awslogs
          Options:
            awslogs-group:
              Ref: LogGroup
            awslogs-region:
              Ref: AWS::Region
            awslogs-stream-prefix: cvm
        MemoryReservation: 2048
        Name: jupyter_kernel_gateway
        PortMappings:
        - ContainerPort: 5005
          HostPort: 5005
          Protocol: tcp
        - ContainerPort: 8888
          HostPort: 8888
          Protocol: tcp
      Cpu: '1024'
      EphemeralStorage:
        SizeInGiB: 50
      ExecutionRoleArn:
        Fn::GetAtt:
        - TaskExecutionRole
        - Arn
      Family: datagrok-cvm-jupyter_kernel_gateway
      Memory: '3072'
      NetworkMode: awsvpc
      RequiresCompatibilities:
      - FARGATE
    Type: AWS::ECS::TaskDefinition
  JupyterNotebookService:
    DependsOn:
    - CvmTCP80Listener
    - CvmTCP443Listener
    - CvmTCP8090IntListener
    - JupyterNotebookTCP5005ListenerRule
    - JupyterNotebookTCP5005IntListenerRule
    - JupyterNotebookTCP8889ListenerRule
    - JupyterNotebookTCP8889IntListenerRule
    Properties:
      Cluster:
        Fn::GetAtt:
        - CvmCluster
        - Arn
      DeploymentConfiguration:
        MaximumPercent: 200
        MinimumHealthyPercent: 100
      DeploymentController:
        Type: ECS
      DesiredCount: 1
      LaunchType: FARGATE
      LoadBalancers:
      - ContainerName: jupyter_notebook
        ContainerPort: 5005
        TargetGroupArn:
          Ref: JupyterNotebookTCP5005TargetGroup
      - ContainerName: jupyter_notebook
        ContainerPort: 8889
        TargetGroupArn:
          Ref: JupyterNotebookTCP8889TargetGroup
      - ContainerName: jupyter_notebook
        ContainerPort: 5005
        TargetGroupArn:
          Ref: JupyterNotebookTCP5005IntTargetGroup
      - ContainerName: jupyter_notebook
        ContainerPort: 8889
        TargetGroupArn:
          Ref: JupyterNotebookTCP8889IntTargetGroup
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: ENABLED
          SecurityGroups:
          - Ref: CvmSecurityGroup
          Subnets:
          - Ref: PrivateSubnet1
          - Ref: PrivateSubnet2
      PlatformVersion: 1.4.0
      PropagateTags: SERVICE
      SchedulingStrategy: REPLICA
      ServiceRegistries:
      - RegistryArn:
          Fn::GetAtt:
          - JupyterNotebookServiceDiscoveryEntry
          - Arn
      Tags:
      - Key: datagrok.component
        Value: cvm
      - Key: datagrok.service
        Value: jupyter_notebook
      TaskDefinition:
        Ref: JupyterNotebookTaskDefinition
    Type: AWS::ECS::Service
  JupyterNotebookServiceDiscoveryEntry:
    Properties:
      Description:
        Fn::Sub: ${AWS::StackName} Datagrok CVM jupyter_notebook service discovery
          entry in Cloud Map
      DnsConfig:
        DnsRecords:
        - TTL: 60
          Type: A
        RoutingPolicy: MULTIVALUE
      HealthCheckCustomConfig:
        FailureThreshold: 1
      Name: jupyter_notebook
      NamespaceId:
        Ref: CloudMap
    Type: AWS::ServiceDiscovery::Service
  JupyterNotebookTCP5005IntListenerRule:
    Properties:
      Actions:
      - ForwardConfig:
          TargetGroups:
          - TargetGroupArn:
              Ref: JupyterNotebookTCP5005IntTargetGroup
        Type: forward
      Conditions:
      - Field: path-pattern
        PathPatternConfig:
          Values:
          - /notebook/helper/*
      ListenerArn:
        Ref: CvmTCP8090IntListener
      Priority: 5
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
  JupyterNotebookTCP5005IntTargetGroup:
    Properties:
      HealthCheckPath: /notebook/helper/info
      Matcher:
        HttpCode: 200
      Name:
        Fn::Sub: ${AWS::StackName}-datagrok-cvm-jn-gh-i
      Port: 5005
      Protocol: HTTP
      Tags:
      - Key: datagrok.component
        Value: cvm
      TargetGroupAttributes:
      - Key: stickiness.enabled
        Value: true
      - Key: stickiness.type
        Value: lb_cookie
      - Key: stickiness.lb_cookie.duration_seconds
        Value: 86400
      TargetType: ip
      VpcId:
        Ref: VPC
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
  JupyterNotebookTCP5005ListenerRule:
    Properties:
      Actions:
      - ForwardConfig:
          TargetGroups:
          - TargetGroupArn:
              Ref: JupyterNotebookTCP5005TargetGroup
        Type: forward
      Conditions:
      - Field: path-pattern
        PathPatternConfig:
          Values:
          - /notebook/helper/*
      ListenerArn:
        Ref: CvmTCP443Listener
      Priority: 5
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
  JupyterNotebookTCP5005TargetGroup:
    Properties:
      HealthCheckPath: /notebook/helper/info
      Matcher:
        HttpCode: 200
      Name:
        Fn::Sub: ${AWS::StackName}-datagrok-cvm-jn-gh
      Port: 5005
      Protocol: HTTP
      Tags:
      - Key: datagrok.component
        Value: cvm
      TargetGroupAttributes:
      - Key: stickiness.enabled
        Value: true
      - Key: stickiness.type
        Value: lb_cookie
      - Key: stickiness.lb_cookie.duration_seconds
        Value: 86400
      TargetType: ip
      VpcId:
        Ref: VPC
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
  JupyterNotebookTCP8889IntListenerRule:
    Properties:
      Actions:
      - ForwardConfig:
          TargetGroups:
          - TargetGroupArn:
              Ref: JupyterNotebookTCP8889IntTargetGroup
        Type: forward
      Conditions:
      - Field: path-pattern
        PathPatternConfig:
          Values:
          - /notebook/*
      ListenerArn:
        Ref: CvmTCP8090IntListener
      Priority: 6
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
  JupyterNotebookTCP8889IntTargetGroup:
    Properties:
      HealthCheckPath: /notebook/api
      Matcher:
        HttpCode: 200
      Name:
        Fn::Sub: ${AWS::StackName}-datagrok-cvm-jn-i
      Port: 8889
      Protocol: HTTP
      Tags:
      - Key: datagrok.component
        Value: cvm
      TargetGroupAttributes:
      - Key: stickiness.enabled
        Value: true
      - Key: stickiness.type
        Value: lb_cookie
      - Key: stickiness.lb_cookie.duration_seconds
        Value: 86400
      TargetType: ip
      VpcId:
        Ref: VPC
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
  JupyterNotebookTCP8889ListenerRule:
    Properties:
      Actions:
      - ForwardConfig:
          TargetGroups:
          - TargetGroupArn:
              Ref: JupyterNotebookTCP8889TargetGroup
        Type: forward
      Conditions:
      - Field: path-pattern
        PathPatternConfig:
          Values:
          - /notebook/*
      ListenerArn:
        Ref: CvmTCP443Listener
      Priority: 6
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
  JupyterNotebookTCP8889TargetGroup:
    Properties:
      HealthCheckPath: /notebook/api
      Matcher:
        HttpCode: 200
      Name:
        Fn::Sub: ${AWS::StackName}-datagrok-cvm-jn
      Port: 8889
      Protocol: HTTP
      Tags:
      - Key: datagrok.component
        Value: cvm
      TargetGroupAttributes:
      - Key: stickiness.enabled
        Value: true
      - Key: stickiness.type
        Value: lb_cookie
      - Key: stickiness.lb_cookie.duration_seconds
        Value: 86400
      TargetType: ip
      VpcId:
        Ref: VPC
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
  JupyterNotebookTaskDefinition:
    Properties:
      ContainerDefinitions:
      - Command:
        - Fn::Sub: ${AWS::Region}.compute.internal
        - Fn::Sub: ${AWS::StackName}.datagrok.${AWS::Region}.lb.internal
        - Fn::Sub: ${AWS::StackName}.datagrok.${AWS::Region}.cm.internal
        Essential: false
        Image:
          Fn::Sub:
          - ${domain}/${repo}:${tag}
          - domain:
              Fn::FindInMap:
              - Images
              - Searchdomain
              - domain
            repo:
              Fn::FindInMap:
              - Images
              - Searchdomain
              - repo
            tag:
              Fn::FindInMap:
              - Images
              - Searchdomain
              - version
        LogConfiguration:
          LogDriver: awslogs
          Options:
            awslogs-group:
              Ref: LogGroup
            awslogs-region:
              Ref: AWS::Region
            awslogs-stream-prefix: cvm
        MemoryReservation: 100
        Name: ResolvConf
      - DependsOn:
        - Condition: SUCCESS
          ContainerName: ResolvConf
        Essential: true
        Image:
          Fn::Sub:
          - ${domain}/${repo}:${tag}
          - domain:
              Fn::FindInMap:
              - Images
              - JN
              - domain
            repo:
              Fn::FindInMap:
              - Images
              - JN
              - repo
            tag:
              Ref: JNVersion
        LinuxParameters: {}
        LogConfiguration:
          LogDriver: awslogs
          Options:
            awslogs-group:
              Ref: LogGroup
            awslogs-region:
              Ref: AWS::Region
            awslogs-stream-prefix: cvm
        MemoryReservation: 1024
        Name: jupyter_notebook
        PortMappings:
        - ContainerPort: 5005
          HostPort: 5005
          Protocol: tcp
        - ContainerPort: 8889
          HostPort: 8889
          Protocol: tcp
      Cpu: '512'
      ExecutionRoleArn:
        Fn::GetAtt:
        - TaskExecutionRole
        - Arn
      Family: datagrok-cvm-jupyter_notebook
      Memory: '2048'
      NetworkMode: awsvpc
      RequiresCompatibilities:
      - FARGATE
    Type: AWS::ECS::TaskDefinition
  KanikoPolicy:
    Properties:
      Description:
        Fn::Sub: ${AWS::StackName} Kaniko policy to access AWS resources
      ManagedPolicyName:
        Fn::Sub: ${AWS::StackName}-Kaniko-${AWS::Region}
      PolicyDocument:
        Statement:
        - Action:
          - ecr:GetAuthorizationToken
          Effect: Allow
          Resource: '*'
        - Action:
          - ecr:CompleteLayerUpload
          - ecr:UploadLayerPart
          - ecr:InitiateLayerUpload
          - ecr:BatchCheckLayerAvailability
          - ecr:PutImage
          - ecr:TagResource
          Effect: Allow
          Resource:
            Fn::Sub: arn:aws:ecr:${AWS::Region}:${AWS::AccountId}:repository/datagrok/*
        - Action:
          - ecr:BatchCheckLayerAvailability
          - ecr:BatchGetImage
          Effect: Allow
          Resource:
            Fn::Sub: arn:aws:ecr:${AWS::Region}:${AWS::AccountId}:repository/datagrok/*
        - Action:
          - s3:GetObject
          - s3:ListBucket
          Effect: Allow
          Resource:
          - Fn::GetAtt:
            - S3
            - Arn
          - Fn::Sub:
            - ${bucket}/dockerfiles/*
            - bucket:
                Fn::GetAtt:
                - S3
                - Arn
        Version: '2012-10-17'
    Type: AWS::IAM::ManagedPolicy
  KanikoTaskDefinition:
    Properties:
      ContainerDefinitions:
      - Essential: true
        Image:
          Fn::Sub:
          - ${domain}/${repo}:${tag}
          - domain:
              Fn::FindInMap:
              - Images
              - Kaniko
              - domain
            repo:
              Fn::FindInMap:
              - Images
              - Kaniko
              - repo
            tag:
              Fn::FindInMap:
              - Images
              - Kaniko
              - repo
        LinuxParameters: {}
        LogConfiguration:
          LogDriver: awslogs
          Options:
            awslogs-group:
              Ref: LogGroup
            awslogs-region:
              Ref: AWS::Region
            awslogs-stream-prefix: grok_spawner_kaniko
        MemoryReservation: 100
        Name: grok_spawner_kaniko
      Cpu: '1024'
      ExecutionRoleArn:
        Fn::GetAtt:
        - TaskExecutionRole
        - Arn
      Family: grok_spawner_kaniko
      Memory: '4096'
      NetworkMode: awsvpc
      RequiresCompatibilities:
      - FARGATE
      TaskRoleArn:
        Ref: KanikoTaskRole
    Type: AWS::ECS::TaskDefinition
  KanikoTaskRole:
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Action:
          - sts:AssumeRole
          Condition: {}
          Effect: Allow
          Principal:
            Service: ecs-tasks.amazonaws.com
        Version: '2012-10-17'
      ManagedPolicyArns:
      - Ref: KanikoPolicy
      Tags:
      - Key: datagrok.component
        Value: datagrok
      - Key: datagrok.service
        Value: grok_spawner
    Type: AWS::IAM::Role
  LoadBalancerCvm:
    Properties:
      LoadBalancerAttributes:
      - Key: routing.http.drop_invalid_header_fields.enabled
        Value: 'true'
      Name:
        Fn::Sub: ${AWS::StackName}-datagrok-cvm
      Scheme: internet-facing
      SecurityGroups:
      - Ref: CvmALBSecurityGroup
      Subnets:
      - Ref: PublicSubnet1
      - Ref: PublicSubnet2
      Tags:
      - Key: Name
        Value:
          Fn::Sub: ${AWS::StackName}-datagrok-cvm-alb
      - Key: datagrok.component
        Value: cvm
      Type: application
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
  LoadBalancerDatagrok:
    Properties:
      LoadBalancerAttributes:
      - Key: routing.http.drop_invalid_header_fields.enabled
        Value: 'true'
      Name:
        Fn::Sub: ${AWS::StackName}-datagrok
      Scheme: internet-facing
      SecurityGroups:
      - Ref: ALBSecurityGroup
      Subnets:
      - Ref: PublicSubnet1
      - Ref: PublicSubnet2
      Tags:
      - Key: Name
        Value:
          Fn::Sub: ${AWS::StackName}-datagrok-alb
      - Key: datagrok.component
        Value: datagrok
      Type: application
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
  LoadBalancerIntCvm:
    Properties:
      LoadBalancerAttributes:
      - Key: routing.http.drop_invalid_header_fields.enabled
        Value: 'true'
      Name:
        Fn::Sub: ${AWS::StackName}-datagrok-cvm-int
      Scheme: internal
      SecurityGroups:
      - Ref: CvmALBIntSecurityGroup
      Subnets:
      - Ref: PrivateSubnet1
      - Ref: PrivateSubnet2
      Tags:
      - Key: Name
        Value:
          Fn::Sub: ${AWS::StackName}-datagrok-cvm-alb-int
      - Key: datagrok.component
        Value: cvm
      Type: application
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
  LoadBalancerIntDatagrok:
    Properties:
      LoadBalancerAttributes:
      - Key: routing.http.drop_invalid_header_fields.enabled
        Value: 'true'
      Name:
        Fn::Sub: ${AWS::StackName}-datagrok-int
      Scheme: internal
      SecurityGroups:
      - Ref: ALBIntSecurityGroup
      Subnets:
      - Ref: PrivateSubnet1
      - Ref: PrivateSubnet2
      Tags:
      - Key: Name
        Value:
          Fn::Sub: ${AWS::StackName}-datagrok-alb-int
      - Key: datagrok.component
        Value: datagrok
      Type: application
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
  LogGroup:
    DeletionPolicy: Delete
    Properties:
      LogGroupName:
        Fn::Sub: /ecs/${AWS::StackName}-datagrok-${AWS::Region}
      RetentionInDays: 7
    Type: AWS::Logs::LogGroup
    UpdateReplacePolicy: Delete
  NatGateway:
    Condition: InternetEgressAccess
    Properties:
      AllocationId:
        Fn::GetAtt:
        - NatGatewayEIP
        - AllocationId
      ConnectivityType: public
      SubnetId:
        Ref: PublicSubnet1
      Tags:
      - Key: Name
        Value:
          Fn::Sub: ${AWS::StackName} Datagrok Nat Gateway
      - Key: datagrok.component
        Value: common
    Type: AWS::EC2::NatGateway
  NatGatewayEIP:
    Condition: InternetEgressAccess
    Properties:
      Domain: vpc
      Tags:
      - Key: Name
        Value:
          Fn::Sub: ${AWS::StackName} Datagrok Nat Gateway EIP
      - Key: datagrok.component
        Value: common
    Type: AWS::EC2::EIP
  Policy:
    Properties:
      Description:
        Fn::Sub: ${AWS::StackName} Datagrok policy to access AWS resources
      ManagedPolicyName:
        Fn::Sub: ${AWS::StackName}-S3Access-${AWS::Region}
      PolicyDocument:
        Statement:
        - Action:
          - s3:PutObject
          - s3:GetObject
          - s3:DeleteObject
          - s3:ListBucket
          Condition: {}
          Effect: Allow
          Resource:
          - Fn::GetAtt:
            - S3
            - Arn
          - Fn::Sub:
            - ${bucket}/*
            - bucket:
                Fn::GetAtt:
                - S3
                - Arn
        Version: '2012-10-17'
    Type: AWS::IAM::ManagedPolicy
  PrivateDNSZone:
    Properties:
      HostedZoneConfig:
        Comment:
          Fn::Sub: ${AWS::StackName} Private Datagrok Zone for internal routing
      Name:
        Fn::Sub: ${AWS::StackName}.datagrok.${AWS::Region}.lb.internal.
      VPCs:
      - VPCId:
          Ref: VPC
        VPCRegion:
          Ref: AWS::Region
    Type: AWS::Route53::HostedZone
  PrivateSubnet1:
    Properties:
      AvailabilityZone:
        Fn::Select:
        - 0
        - Fn::GetAZs:
            Ref: AWS::Region
      CidrBlock:
        Fn::Select:
        - 2
        - Fn::Cidr:
          - Fn::GetAtt:
            - VPC
            - CidrBlock
          - 6
          - 6
      MapPublicIpOnLaunch: false
      Tags:
      - Key: Name
        Value:
          Fn::Sub: ${AWS::StackName} Datagrok Private Subnet 1
      - Key: datagrok.component
        Value: common
      VpcId:
        Ref: VPC
    Type: AWS::EC2::Subnet
  PrivateSubnet2:
    Properties:
      AvailabilityZone:
        Fn::Select:
        - 1
        - Fn::GetAZs:
            Ref: AWS::Region
      CidrBlock:
        Fn::Select:
        - 3
        - Fn::Cidr:
          - Fn::GetAtt:
            - VPC
            - CidrBlock
          - 6
          - 6
      MapPublicIpOnLaunch: false
      Tags:
      - Key: Name
        Value:
          Fn::Sub: ${AWS::StackName} Datagrok Private Subnet 2
      - Key: datagrok.component
        Value: common
      VpcId:
        Ref: VPC
    Type: AWS::EC2::Subnet
  PrivateSubnetNatRoute:
    Condition: InternetEgressAccess
    Properties:
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId:
        Ref: NatGateway
      RouteTableId:
        Ref: PrivateSubnetRouteTable
    Type: AWS::EC2::Route
  PrivateSubnetRouteAssos1:
    Properties:
      RouteTableId:
        Ref: PrivateSubnetRouteTable
      SubnetId:
        Ref: PrivateSubnet1
    Type: AWS::EC2::SubnetRouteTableAssociation
  PrivateSubnetRouteAssos2:
    Properties:
      RouteTableId:
        Ref: PrivateSubnetRouteTable
      SubnetId:
        Ref: PrivateSubnet2
    Type: AWS::EC2::SubnetRouteTableAssociation
  PrivateSubnetRouteTable:
    Properties:
      Tags:
      - Key: Name
        Value:
          Fn::Sub: ${AWS::StackName} Datagrok Private Subnet Route Table
      - Key: datagrok.component
        Value: common
      VpcId:
        Ref: VPC
    Type: AWS::EC2::RouteTable
  PublicSubnet1:
    Condition: CreatePublicSubnets
    Properties:
      AvailabilityZone:
        Fn::Select:
        - 0
        - Fn::GetAZs:
            Ref: AWS::Region
      CidrBlock:
        Fn::Select:
        - 0
        - Fn::Cidr:
          - Fn::GetAtt:
            - VPC
            - CidrBlock
          - 6
          - 6
      MapPublicIpOnLaunch: true
      Tags:
      - Key: Name
        Value:
          Fn::Sub: ${AWS::StackName} Datagrok Public Subnet 1
      - Key: datagrok.component
        Value: common
      VpcId:
        Ref: VPC
    Type: AWS::EC2::Subnet
  PublicSubnet2:
    Condition: CreatePublicSubnets
    Properties:
      AvailabilityZone:
        Fn::Select:
        - 1
        - Fn::GetAZs:
            Ref: AWS::Region
      CidrBlock:
        Fn::Select:
        - 1
        - Fn::Cidr:
          - Fn::GetAtt:
            - VPC
            - CidrBlock
          - 6
          - 6
      MapPublicIpOnLaunch: true
      Tags:
      - Key: Name
        Value:
          Fn::Sub: ${AWS::StackName} Datagrok Public Subnet 2
      - Key: datagrok.component
        Value: common
      VpcId:
        Ref: VPC
    Type: AWS::EC2::Subnet
  PublicSubnetPublicRoute:
    Condition: CreatePublicSubnets
    Properties:
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId:
        Ref: InternetGateway
      RouteTableId:
        Ref: PublicSubnetRouteTable
    Type: AWS::EC2::Route
  PublicSubnetRouteAssos1:
    Condition: CreatePublicSubnets
    Properties:
      RouteTableId:
        Ref: PublicSubnetRouteTable
      SubnetId:
        Ref: PublicSubnet1
    Type: AWS::EC2::SubnetRouteTableAssociation
  PublicSubnetRouteAssos2:
    Condition: CreatePublicSubnets
    Properties:
      RouteTableId:
        Ref: PublicSubnetRouteTable
      SubnetId:
        Ref: PublicSubnet2
    Type: AWS::EC2::SubnetRouteTableAssociation
  PublicSubnetRouteTable:
    Condition: CreatePublicSubnets
    Properties:
      Tags:
      - Key: Name
        Value:
          Fn::Sub: ${AWS::StackName} Datagrok Public Subnet Route Table
      - Key: datagrok.component
        Value: common
      VpcId:
        Ref: VPC
    Type: AWS::EC2::RouteTable
  R53Cleanup:
    DependsOn:
    - R53CleanupLambdaFunctionLogGroup
    Properties:
      DNSZone:
        Ref: DNSZoneId
      SSLCertificate:
        Ref: ArnSSLCertificate
      ServiceToken:
        Fn::GetAtt:
        - R53CleanupLambdaFunction
        - Arn
    Type: AWS::CloudFormation::CustomResource
  R53CleanupLambdaFunction:
    Properties:
      Code:
        ZipFile: "import boto3\nimport cfnresponse\n\n\ndef handler(event, context):\n\
          \    responseData = {}\n    try:\n        zone_id = event['ResourceProperties']['DNSZone']\n\
          \        certArn = event['ResourceProperties']['SSLCertificate']\n\n   \
          \     if event['RequestType'] == 'Delete':\n            session = boto3.Session()\n\
          \            acm = session.client('acm')\n            response = acm.describe_certificate(CertificateArn=certArn)\n\
          \            records = []\n            for d in response['Certificate']['DomainValidationOptions']:\n\
          \                records.append(d['ResourceRecord'])\n            r53 =\
          \ session.client('route53')\n            for r in records:\n           \
          \     response = r53.list_resource_record_sets(HostedZoneId=zone_id, StartRecordName=r['Name'],\
          \ MaxItems='1')\n                if r['Name'] in response['ResourceRecordSets'][0]['Name']:\n\
          \                    r53.change_resource_record_sets(\n                \
          \        HostedZoneId=zone_id,\n                        ChangeBatch={\n\
          \                            'Changes': [{\n                           \
          \     'Action': 'DELETE',\n                                'ResourceRecordSet':\
          \ response['ResourceRecordSets'][0]\n                            }]\n  \
          \                      }\n                    )\n                    print(f'Deleted:\
          \ {response[\"ResourceRecordSets\"][0]}')\n                else:\n     \
          \               print(f'Record {r[\"Name\"]} does not exist')\n        \
          \    responseData['Status'] = 200\n        cfnresponse.send(event, context,\
          \ cfnresponse.SUCCESS, responseData)\n    except Exception as e:\n     \
          \   print(type(e).__name__, e)\n        cfnresponse.send(event, context,\
          \ cfnresponse.FAILED, responseData)\n"
      Description: Removes obsolete validation records from AWS
      Handler: index.handler
      MemorySize: 128
      Role:
        Fn::GetAtt:
        - R53CleanupLambdaRole
        - Arn
      Runtime: python3.11
      Timeout: 600
    Type: AWS::Lambda::Function
  R53CleanupLambdaFunctionLogGroup:
    DeletionPolicy: Delete
    Properties:
      LogGroupName:
        Fn::Sub:
        - /aws/lambda/${function_name}
        - function_name:
            Ref: R53CleanupLambdaFunction
      RetentionInDays: 1
    Type: AWS::Logs::LogGroup
    UpdateReplacePolicy: Delete
  R53CleanupLambdaRole:
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Action:
          - sts:AssumeRole
          Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
        Version: '2012-10-17'
      Policies:
      - PolicyDocument:
          Statement:
          - Action:
            - logs:CreateLogStream
            - logs:PutLogEvents
            Effect: Allow
            Resource:
              Fn::Sub: arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/${AWS::StackName}-R53CleanupLambdaFunction-*:*
          - Action:
            - acm:DescribeCertificate
            Effect: Allow
            Resource:
              Ref: ArnSSLCertificate
          - Action:
            - route53:ListResourceRecordSets
            - route53:ChangeResourceRecordSets
            Effect: Allow
            Resource:
              Fn::Sub:
              - arn:${AWS::Partition}:route53:::hostedzone/${zone}
              - zone:
                  Ref: DNSZoneId
          Version: '2012-10-17'
        PolicyName:
          Fn::Sub: ${AWS::StackName}-r53-lambda
    Type: AWS::IAM::Role
  S3:
    Properties:
      BucketEncryption:
        ServerSideEncryptionConfiguration:
        - BucketKeyEnabled: true
          ServerSideEncryptionByDefault:
            SSEAlgorithm: AES256
      BucketName:
        Fn::Sub:
        - ${AWS::StackName}-datagrok-s3-${uuid}
        - uuid:
            Fn::Select:
            - 2
            - Fn::Split:
              - /
              - Ref: AWS::StackId
      ObjectLockEnabled: false
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      Tags:
      - Key: datagrok.component
        Value: datagrok
    Type: AWS::S3::Bucket
  S3Empty:
    DependsOn:
    - S3EmptyLambdaFunctionLogGroup
    Properties:
      BucketName:
        Ref: S3
      ServiceToken:
        Fn::GetAtt:
        - S3EmptyLambdaFunction
        - Arn
    Type: AWS::CloudFormation::CustomResource
  S3EmptyLambdaFunction:
    Properties:
      Code:
        ZipFile: "import boto3\nimport cfnresponse\n\n\ndef handler(event, context):\n\
          \    try:\n        bucket = event['ResourceProperties']['BucketName']\n\
          \        status = 0\n\n        if event['RequestType'] == 'Delete':\n  \
          \          s3 = boto3.resource('s3')\n            bucket = s3.Bucket(bucket)\n\
          \            for obj in bucket.objects.filter():\n                s3.Object(bucket.name,\
          \ obj.key).delete()\n            status = 201\n\n        cfnresponse.send(event,\
          \ context, cfnresponse.SUCCESS, {'Status': status})\n    except Exception\
          \ as e:\n        print(type(e).__name__, e)\n        cfnresponse.send(event,\
          \ context, cfnresponse.FAILED, {'Exception': f\"{type(e).__name__} {e}\"\
          })\n"
      Description: Sets required settings for Datagrok
      Handler: index.handler
      MemorySize: 128
      Role:
        Fn::GetAtt:
        - S3EmptyLambdaRole
        - Arn
      Runtime: python3.11
      Timeout: 600
      VpcConfig:
        SecurityGroupIds:
        - Ref: DatagrokSecurityGroup
        SubnetIds:
        - Ref: PrivateSubnet1
        - Ref: PrivateSubnet2
    Type: AWS::Lambda::Function
  S3EmptyLambdaFunctionLogGroup:
    DeletionPolicy: Delete
    Properties:
      LogGroupName:
        Fn::Sub:
        - /aws/lambda/${function_name}
        - function_name:
            Ref: S3EmptyLambdaFunction
      RetentionInDays: 1
    Type: AWS::Logs::LogGroup
    UpdateReplacePolicy: Delete
  S3EmptyLambdaRole:
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Action:
          - sts:AssumeRole
          Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
        Version: '2012-10-17'
      Policies:
      - PolicyDocument:
          Statement:
          - Action:
            - logs:CreateLogStream
            - logs:PutLogEvents
            Effect: Allow
            Resource:
              Fn::Sub: arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/${AWS::StackName}-S3EmptyLambdaFunction-*:*
          - Action:
            - ec2:DescribeNetworkInterfaces
            Effect: Allow
            Resource: '*'
          - Action:
            - ec2:CreateNetworkInterface
            Effect: Allow
            Resource:
            - Fn::Sub:
              - arn:aws:ec2:${AWS::Region}:${AWS::AccountId}:subnet/${subnet_id}
              - subnet_id:
                  Ref: PrivateSubnet1
            - Fn::Sub:
              - arn:aws:ec2:${AWS::Region}:${AWS::AccountId}:subnet/${subnet_id}
              - subnet_id:
                  Ref: PrivateSubnet2
            - Fn::Sub:
              - arn:aws:ec2:${AWS::Region}:${AWS::AccountId}:security-group/${security_group_id}
              - security_group_id:
                  Ref: DatagrokSecurityGroup
            - Fn::Sub: arn:aws:ec2:${AWS::Region}:${AWS::AccountId}:network-interface/*
          - Action:
            - ec2:DeleteNetworkInterface
            - ec2:AssignPrivateIpAddresses
            - ec2:UnassignPrivateIpAddresses
            Condition:
              StringEqualsIfExists:
                ec2:Subnet:
                - Fn::Sub:
                  - arn:aws:ec2:${AWS::Region}:${AWS::AccountId}:subnet/${subnet}
                  - subnet:
                      Ref: PrivateSubnet1
                - Fn::Sub:
                  - arn:aws:ec2:${AWS::Region}:${AWS::AccountId}:subnet/${subnet}
                  - subnet:
                      Ref: PrivateSubnet2
                ec2:Vpc:
                  Fn::Sub:
                  - arn:aws:ec2:${AWS::Region}:${AWS::AccountId}:vpc/${vpc}
                  - vpc:
                      Ref: VPC
            Effect: Allow
            Resource: '*'
          - Action:
            - s3:GetObject
            - s3:DeleteObject
            - s3:ListBucket
            Effect: Allow
            Resource:
            - Fn::GetAtt:
              - S3
              - Arn
            - Fn::Sub:
              - ${bucket}/*
              - bucket:
                  Fn::GetAtt:
                  - S3
                  - Arn
          Version: '2012-10-17'
        PolicyName:
          Fn::Sub: ${AWS::StackName}-s3-lambda
    Type: AWS::IAM::Role
  S3Policy:
    Properties:
      Bucket:
        Ref: S3
      PolicyDocument:
        Statement:
        - Action:
          - s3:PutObject
          - s3:GetObject
          - s3:DeleteObject
          Condition:
            StringNotEquals:
              aws:SourceVpce:
                Ref: S3VPCEndpoint
          Effect: Deny
          Principal: '*'
          Resource:
          - Fn::GetAtt:
            - S3
            - Arn
          - Fn::Sub:
            - ${bucket}/*
            - bucket:
                Fn::GetAtt:
                - S3
                - Arn
        - Action: '*'
          Condition:
            Bool:
              aws:SecureTransport: false
          Effect: Deny
          Principal: '*'
          Resource:
          - Fn::GetAtt:
            - S3
            - Arn
          - Fn::Sub:
            - ${bucket}/*
            - bucket:
                Fn::GetAtt:
                - S3
                - Arn
        Version: '2012-10-17'
    Type: AWS::S3::BucketPolicy
  S3VPCEndpoint:
    Properties:
      PolicyDocument:
        Statement:
        - Action:
          - s3:PutObject
          - s3:GetObject
          - s3:DeleteObject
          - s3:ListBucket
          Condition: {}
          Effect: Allow
          Principal: '*'
          Resource:
          - Fn::GetAtt:
            - S3
            - Arn
          - Fn::Sub:
            - ${bucket}/*
            - bucket:
                Fn::GetAtt:
                - S3
                - Arn
          - Fn::Sub: arn:aws:s3:::amazonlinux.${AWS::Region}.amazonaws.com
          - Fn::Sub: arn:aws:s3:::amazonlinux.${AWS::Region}.amazonaws.com/*
          - Fn::Sub: arn:aws:s3:::amazonlinux-2-repos-${AWS::Region}
          - Fn::Sub: arn:aws:s3:::amazonlinux-2-repos-${AWS::Region}/*
          - Fn::Sub: arn:aws:s3:::prod-${AWS::Region}-starport-layer-bucket
          - Fn::Sub: arn:aws:s3:::prod-${AWS::Region}-starport-layer-bucket/*
          - arn:aws:s3:::docker-images-prod
          - arn:aws:s3:::docker-images-prod/*
        Version: '2012-10-17'
      RouteTableIds:
      - Ref: PrivateSubnetRouteTable
      ServiceName:
        Fn::Sub: com.amazonaws.${AWS::Region}.s3
      VpcEndpointType: Gateway
      VpcId:
        Ref: VPC
    Type: AWS::EC2::VPCEndpoint
  SecurityGroupALBCommunications:
    Properties:
      Description:
        Fn::Sub: ${AWS::StackName} Allow communication from ALB to Datagrok components
      GroupId:
        Ref: DatagrokSecurityGroup
      IpProtocol: '-1'
      SourceSecurityGroupId:
        Ref: ALBSecurityGroup
    Type: AWS::EC2::SecurityGroupIngress
  SecurityGroupCvmCommunications:
    Properties:
      Description:
        Fn::Sub: ${AWS::StackName} Allow communication from CVM to Datagrok components
      GroupId:
        Ref: DatagrokSecurityGroup
      IpProtocol: '-1'
      SourceSecurityGroupId:
        Ref: CvmSecurityGroup
    Type: AWS::EC2::SecurityGroupIngress
  SecurityGroupIntALBCommunications:
    Properties:
      Description:
        Fn::Sub: ${AWS::StackName} Allow communication from internal ALB to Datagrok
          components
      GroupId:
        Ref: DatagrokSecurityGroup
      IpProtocol: '-1'
      SourceSecurityGroupId:
        Ref: ALBIntSecurityGroup
    Type: AWS::EC2::SecurityGroupIngress
  SecurityGroupInternalCommunications:
    Properties:
      Description:
        Fn::Sub: ${AWS::StackName} Allow communication within network Datagrok
      GroupId:
        Ref: DatagrokSecurityGroup
      IpProtocol: '-1'
      SourceSecurityGroupId:
        Ref: DatagrokSecurityGroup
    Type: AWS::EC2::SecurityGroupIngress
  ServiceDiscoveryEntry:
    Properties:
      Description:
        Fn::Sub: ${AWS::StackName} Datagrok datagrok service discovery entry in Cloud
          Map
      DnsConfig:
        DnsRecords:
        - TTL: 60
          Type: A
        RoutingPolicy: MULTIVALUE
      HealthCheckCustomConfig:
        FailureThreshold: 1
      Name: datagrok
      NamespaceId:
        Ref: CloudMap
    Type: AWS::ServiceDiscovery::Service
  SettingsSet:
    DependsOn:
    - DatagrokService
    - SettingsSetLambdaFunctionLogGroup
    Properties:
      DevKey:
        Fn::Sub:
        - '{{resolve:secretsmanager:${secret}:SecretString:password}}'
        - secret:
            Ref: AdminDevKey
      Host:
        Ref: DatagrokDNS
      ServiceToken:
        Fn::GetAtt:
        - SettingsSetLambdaFunction
        - Arn
      cvmClient:
        Ref: CvmDNS
    Type: AWS::CloudFormation::CustomResource
  SettingsSetLambdaFunction:
    Properties:
      Code:
        ZipFile: "import json\nimport os\nimport urllib3\nfrom urllib3.util import\
          \ Retry\nimport cfnresponse\n\nhttp = urllib3.PoolManager()\nretries = 10\n\
          retry = Retry(\n    total=retries,\n    read=retries,\n    connect=retries,\n\
          \    status_forcelist=tuple(range(401, 600)))\n\n\ndef handler(event, context):\n\
          \    try:\n        status = 0\n        if event['RequestType'] != 'Delete':\n\
          \            key = event['ResourceProperties']['DevKey']\n            host\
          \ = event['ResourceProperties']['Host']\n            cvmClient = event['ResourceProperties']['cvmClient']\n\
          \n            http.request(\"GET\", f'https://{host}/api/info/server', retries=retry)\n\
          \n            r = http.request(\"POST\", f'https://{host}/api/users/login/dev/{key}',\
          \ retries=retry)\n            auth = json.loads(r.data)['token']\n     \
          \       get_settings = http.request(\"GET\", f'https://{host}/api/admin/plugins/scripts/settings',\n\
          \                                        headers={'Authorization': auth},\n\
          \                                        retries=retry)\n            oldSettings\
          \ = json.loads(get_settings.data)\n            new_settings = {\n      \
          \          '#type': oldSettings['settings']['#type'],\n                'apiUrl':\
          \ oldSettings['settings']['apiUrl'],\n                'cvmUrl': oldSettings['settings']['cvmUrl'],\n\
          \                'h2oUrl': oldSettings['settings']['h2oUrl'],\n        \
          \        'cvmUrlClient': cvmClient,\n                'cvmSplit': oldSettings['settings']['cvmSplit'],\n\
          \                'jupyterGatewayToken': oldSettings['settings']['jupyterGatewayToken'],\n\
          \                'jupyterNotebookToken': oldSettings['settings']['jupyterNotebookToken']\n\
          \            }\n            setSettings = http.request(\"POST\", f'https://{host}/api/admin/plugins/scripts/settings',\n\
          \                                       body=json.dumps(new_settings),\n\
          \                                       headers={'Authorization': auth,\
          \ \"Content-Type\": \"application/json\"},\n                           \
          \            retries=retry)\n            status = setSettings.status\n \
          \           if status != 200:\n                raise Exception(f'Could not\
          \ update settings for {host} with status code {status}')\n        cfnresponse.send(event,\
          \ context, cfnresponse.SUCCESS, {'Status': status})\n    except Exception\
          \ as e:\n        print(type(e).__name__, e)\n        cfnresponse.send(event,\
          \ context, cfnresponse.FAILED, {'Exception': f\"{type(e).__name__}: {e}\"\
          })\n"
      Description: Sets required settings for Datagrok
      Handler: index.handler
      MemorySize: 128
      Role:
        Fn::GetAtt:
        - SettingsSetLambdaRole
        - Arn
      Runtime: python3.11
      Timeout: 600
      VpcConfig:
        SecurityGroupIds:
        - Ref: DatagrokSecurityGroup
        SubnetIds:
        - Ref: PrivateSubnet1
        - Ref: PrivateSubnet2
    Type: AWS::Lambda::Function
  SettingsSetLambdaFunctionLogGroup:
    DeletionPolicy: Delete
    Properties:
      LogGroupName:
        Fn::Sub:
        - /aws/lambda/${function_name}
        - function_name:
            Ref: SettingsSetLambdaFunction
      RetentionInDays: 1
    Type: AWS::Logs::LogGroup
    UpdateReplacePolicy: Delete
  SettingsSetLambdaRole:
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Action:
          - sts:AssumeRole
          Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
        Version: '2012-10-17'
      Policies:
      - PolicyDocument:
          Statement:
          - Action:
            - logs:CreateLogStream
            - logs:PutLogEvents
            Effect: Allow
            Resource:
              Fn::Sub: arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/${AWS::StackName}-SettingsSetLambdaFunction-*:*
          - Action:
            - ec2:DescribeNetworkInterfaces
            Effect: Allow
            Resource: '*'
          - Action:
            - ec2:CreateNetworkInterface
            Effect: Allow
            Resource:
            - Fn::Sub:
              - arn:aws:ec2:${AWS::Region}:${AWS::AccountId}:subnet/${subnet_id}
              - subnet_id:
                  Ref: PrivateSubnet1
            - Fn::Sub:
              - arn:aws:ec2:${AWS::Region}:${AWS::AccountId}:subnet/${subnet_id}
              - subnet_id:
                  Ref: PrivateSubnet2
            - Fn::Sub:
              - arn:aws:ec2:${AWS::Region}:${AWS::AccountId}:security-group/${security_group_id}
              - security_group_id:
                  Ref: DatagrokSecurityGroup
            - Fn::Sub: arn:aws:ec2:${AWS::Region}:${AWS::AccountId}:network-interface/*
          - Action:
            - ec2:DeleteNetworkInterface
            - ec2:AssignPrivateIpAddresses
            - ec2:UnassignPrivateIpAddresses
            Condition:
              ArnLikeIfExists:
                ec2:Subnet:
                - Fn::Sub:
                  - arn:aws:ec2:${AWS::Region}:${AWS::AccountId}:subnet/${subnet}
                  - subnet:
                      Ref: PrivateSubnet1
                - Fn::Sub:
                  - arn:aws:ec2:${AWS::Region}:${AWS::AccountId}:subnet/${subnet}
                  - subnet:
                      Ref: PrivateSubnet2
                ec2:Vpc:
                  Fn::Sub:
                  - arn:aws:ec2:${AWS::Region}:${AWS::AccountId}:vpc/${vpc}
                  - vpc:
                      Ref: VPC
            Effect: Allow
            Resource: '*'
          Version: '2012-10-17'
        PolicyName:
          Fn::Sub: ${AWS::StackName}-settings-lambda
    Type: AWS::IAM::Role
  TCP1234IntListener:
    Properties:
      DefaultActions:
      - ForwardConfig:
          TargetGroups:
          - TargetGroupArn:
              Ref: TCP1234IntTargetGroup
        Type: forward
      LoadBalancerArn:
        Ref: LoadBalancerIntDatagrok
      Port: 1234
      Protocol: HTTP
    Type: AWS::ElasticLoadBalancingV2::Listener
  TCP1234IntTargetGroup:
    Properties:
      HealthCheckIntervalSeconds: 60
      HealthCheckPath: /health
      Matcher:
        HttpCode: 200
      Name:
        Fn::Sub: ${AWS::StackName}-gcon-i
      Port: 1234
      Protocol: HTTP
      Tags:
      - Key: datagrok.component
        Value: datagrok
      TargetType: ip
      UnhealthyThresholdCount: 5
      VpcId:
        Ref: VPC
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
  TCP443Listener:
    Properties:
      Certificates:
      - CertificateArn:
          Ref: ArnSSLCertificate
      DefaultActions:
      - ForwardConfig:
          TargetGroups:
          - TargetGroupArn:
              Ref: TCP8080TargetGroup
        Type: forward
      LoadBalancerArn:
        Ref: LoadBalancerDatagrok
      Port: 443
      Protocol: HTTPS
    Type: AWS::ElasticLoadBalancingV2::Listener
  TCP8000IntListener:
    Properties:
      DefaultActions:
      - ForwardConfig:
          TargetGroups:
          - TargetGroupArn:
              Ref: TCP8000IntTargetGroup
        Type: forward
      LoadBalancerArn:
        Ref: LoadBalancerIntDatagrok
      Port: 8000
      Protocol: HTTP
    Type: AWS::ElasticLoadBalancingV2::Listener
  TCP8000IntTargetGroup:
    Properties:
      HealthCheckIntervalSeconds: 60
      HealthCheckPath: /info
      Matcher:
        HttpCode: 200
      Name:
        Fn::Sub: ${AWS::StackName}-gs-i
      Port: 8000
      Protocol: HTTP
      Tags:
      - Key: datagrok.component
        Value: datagrok
      TargetType: ip
      UnhealthyThresholdCount: 5
      VpcId:
        Ref: VPC
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
  TCP8080IntListener:
    Properties:
      DefaultActions:
      - ForwardConfig:
          TargetGroups:
          - TargetGroupArn:
              Ref: TCP8080IntTargetGroup
        Type: forward
      LoadBalancerArn:
        Ref: LoadBalancerIntDatagrok
      Port: 8080
      Protocol: HTTP
    Type: AWS::ElasticLoadBalancingV2::Listener
  TCP8080IntTargetGroup:
    Properties:
      HealthCheckIntervalSeconds: 60
      HealthCheckPath: /api/admin/health
      Matcher:
        HttpCode: 200
      Name:
        Fn::Sub: ${AWS::StackName}-datagrok-i
      Port: 8080
      Protocol: HTTP
      Tags:
      - Key: datagrok.component
        Value: datagrok
      TargetType: ip
      UnhealthyThresholdCount: 5
      VpcId:
        Ref: VPC
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
  TCP8080TargetGroup:
    Properties:
      HealthCheckIntervalSeconds: 60
      HealthCheckPath: /api/admin/health
      Matcher:
        HttpCode: 200
      Name:
        Fn::Sub: ${AWS::StackName}-datagrok
      Port: 8080
      Protocol: HTTP
      Tags:
      - Key: datagrok.component
        Value: datagrok
      TargetType: ip
      UnhealthyThresholdCount: 5
      VpcId:
        Ref: VPC
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
  TCP80Listener:
    Properties:
      DefaultActions:
      - RedirectConfig:
          Port: '443'
          Protocol: HTTPS
          StatusCode: HTTP_301
        Type: redirect
      LoadBalancerArn:
        Ref: LoadBalancerDatagrok
      Port: 80
      Protocol: HTTP
    Type: AWS::ElasticLoadBalancingV2::Listener
  TaskExecutionRole:
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Action:
          - sts:AssumeRole
          Condition: {}
          Effect: Allow
          Principal:
            Service: ecs-tasks.amazonaws.com
        Version: '2012-10-17'
      ManagedPolicyArns:
      - Ref: ECSPolicy
    Type: AWS::IAM::Role
  TaskRole:
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Action:
          - sts:AssumeRole
          Condition: {}
          Effect: Allow
          Principal:
            Service: ecs-tasks.amazonaws.com
        Version: '2012-10-17'
      ManagedPolicyArns:
      - Ref: Policy
      - Ref: ECSPolicy
      Tags:
      - Key: datagrok.component
        Value: datagrok
      - Key: datagrok.service
        Value: datagrok
    Type: AWS::IAM::Role
  VPC:
    Properties:
      CidrBlock:
        Ref: CIDR
      EnableDnsHostnames: true
      EnableDnsSupport: true
      InstanceTenancy: default
      Tags:
      - Key: Name
        Value:
          Fn::Sub: ${AWS::StackName} Datagrok VPC
      - Key: datagrok.component
        Value: common
    Type: AWS::EC2::VPC
