---
title: "Advanced scripting in Datagrok"
sidebar_position: 3
---

```mdx-code-block
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import BrowserWindow from '@site/src/components/browser-window';
```

## Environments

### Python (using Conda)

You can specify an environment for the script to use,
including the language version and a set of libraries.

Datagrok uses [Conda](https://docs.Conda.io/en/latest/)
as the environment management system.
A Conda environment:

- isolates each script run,
- resolves dependencies,
- and takes time to be created before a script run.

Later, the script uses the pre-created environment with *no delay* for resolving dependencies.

In Datagrok, Conda environment configuration can be specified either [right inside the script](#specify-environment-in-place),
or as [part of a package](#specify-the-environment-in-a-package).

#### Specify environment in-place

Set an `environment` parameter of the script
to a one-liner YAML following the standard Conda YAML config (omit it's name).

For example, we need to use the following Conda config:

```yaml
name: envtest01
channels:
  - Conda-forge
dependencies:
  - python=3.8
  - glom
  - pip:
      - requests
```

To use it in a script, specify it as follows:

```python
#name: EnvTestInline
#environment: channels: [Conda-forge], dependencies: [python=3.8, glom, {pip: [requests]}]
#language: python
#output: string result

import re, requests
from glom import glom
import pandas as pd

target = {'a': {'b': {'c': 'd'}}}
result = glom(target, 'a.b.c')  # returns 'd'
```

:::tip First launch may take time

When the script runs the first time, Datagrok creates the environment on
the [Compute Virtual Machine](/help/develop/under-the-hood/infrastructure.md#compute-components),
which may take up to several minutes.
For all next script runs, Datagrok will reuse this environment.

:::

Datagrok distinguishes in-place environments using *MD5 hashes* of their body strings.
If there is a ready-to-use environment with the same environment config, Datagrok will reuse it.

#### Specify the environment in a package

You may store your configurations in a package's `environment` folder. They should use Conda YAML format.
You can create an environment YAML
[manually](https://docs.Conda.io/projects/Conda/en/latest/user-guide/tasks/manage-environments.html#create-env-file-manually)
or
[export it](https://docs.Conda.io/projects/Conda/en/latest/user-guide/tasks/manage-environments.html#creating-an-environment-from-an-environment-yml-file)
form your existing Conda environment.

If the `environment` tag in the script header is not specified, the script uses
[the default configuration](https://github.com/datagrok-ai/public/blob/master/environments/default.yaml).

:::tip

Here is an
[example of configuration](https://github.com/datagrok-ai/public/tree/master/environments)
for the Datagrok public repository.
Also, a package can define its own
configurations as well ([see examples](https://github.com/datagrok-ai/public/tree/master/packages/Demo/scripts)).

:::

This is how to define the "Chemprop" environment in the script header:

```python
#environment: Chemprop
```

In this case, the environment `Chemprop` should be specified in a file
`environments/Chemprop.yaml` inside the package where this script belongs.

Datagrok distinguishes package environments by their *names*.
Datagrok will reuse a previously created environment for all subsequent runs
with no delay.

#### Sharing environments

You may share environments by referencing them in your scripts.
Conda environment will be re-used by many users, which is more space- and time-efficient.

To achieve it, do the following steps:

1. Create one package to contain global environments (say, `GlobalEnvs`).
2. Create an environment to share inside of this package (let it be `GlobalEnvDataAnalysis`).
3. Publish `GlobalEnvs` package with `--release` option to the platform.
4. Share it with the specific group of users you want to have access to these environments.
5. Environment will be available as `GlobalEnvs:GlobalEnvDataAnalysis`

#### Conda and Pip custom repositories

By default, Conda uses [Conda-forge](https://Conda-forge.org/) and [PyPI](https://pypi.org/) repositories to install packages.
You may specify your own package repositories in the environment specification.

For example, to use `http://my-repo/custom/` as Conda repository
and `https://mirrors.sustech.edu.cn/pypi/simple` as PIP repository use the following code:

```python
#environment: channels: [http://my-repo/custom/], dependencies: [python=3.8, glom, {pip: [--index-url https://mirrors.sustech.edu.cn/pypi/simple, requests]}]
```

#### Common issues with Conda environments

There is a [known](https://github.com/Conda/Conda/issues/8051#issuecomment-464199791)
[issue](https://github.com/Conda/Conda/issues/8051#issuecomment-631862928)
[of Conda](https://github.com/Conda/Conda/issues/8051#issuecomment-808789923)
that sometimes it takes a long time to resolve dependencies.
Datagrok will interrupt Conda environment creation if it takes more than 5 minutes.

If you encounter a timing problem, try to find an equivalent set of packages from PIP repositories.

### R (using Renv)

Datagrok supports [Renv](https://rstudio.github.io/renv/articles/renv.html) environments. Each R
script has a temporary folder with a unique name. This folder becomes an
Renv project folder for the current run of the script.

Start using Renv by initializing it and installing packages (see a
[full example](https://github.com/datagrok-ai/public/blob/master/packages/Demo/scripts/r/renv_spelling.R)):

```R
#language: r

renv::init()
renv::install("hunspell@3.0.1")
```

Renv session only impacts the R environment for this one single run.
No other R scripts are aware of this local script environment.

Renv uses a global package cache.
It caches a package requested once with `renv::install` and re-uses it whenever it is
requested.

In case the latest package version is requested,
such as in `renv::install("hunspell")`,
Renv connects to remote R package repositories
assuring if the cached package needs to be updated to the newer version.
This may introduce a significant delay in the script run, several seconds in practice.
To avoid this, we recommend
installing a specific version of the package, such as in `renv::install("hunspell@3.0.1")`.

:::note Automatic deactivation

At the R script's start and finish,
Datagrok calls `renv::deactivate()` to assure the script's body isolation.
You don't have to call `renv::deactivate()` manually.

:::

## Advanced ways to execute scripts

First of all, a script can be executed right from the script editor,
as described in [run script section](getting-started#how-to-run-a-script).

In this case, it gets registered in the platform as a
[function](/help/datagrok/concepts/functions/functions.md), and can be invoked in different ways:

- From the [Datagrok console](/help/datagrok/navigation/navigation.md#console)
- From the data job
- From the [transformations editor](../transform/recipe-editor.md)
- From the [function browser](https://public.datagrok.ai/functions)

Registered scripts can be called via [JavaScript API](/help/develop/packages/js-api.md) in the following manner:

```javascript
const result = grok.functions.call(
  "<PACKAGE_NAME>:<SCRIPT_NAME>", 
  { 
    <INPUT_NAME>: <INPUT_VALUE>,
    <INPUT_NAME_2>: <INPUT_VALUE_2>
  }
);
```

The single output will be assigned to `result` directly. Multiple outputs will be united into a single object.
You can retrieve any output value by accessing `result` object fields (e.g. `result['<MY_OUTPUT>']`).

To see it in action, open this
[code snippet](https://public.datagrok.ai/js/samples/scripting/scripting) from our samples gallery.
There, you can find more examples, such as
[adding a progress indicator](https://public.datagrok.ai/js/samples/functions/progress) to the user interface.

## Converting your script to an application

A [Datagrok application](/help/develop/how-to/build-an-app.md)
is a fit-for-purpose solution build on top of the Datagrok platform.
Applications have its own section in the Datagrok UI and a start icon.

You can convert your script in the application, regardless of the script language.
Briefly, you need to do the follows:

1. Create a TypeScript [package](/help/develop/packages).

  ```shell
  grok init package_name --ts
  ```

1. Install required NodeJs modules:

  ```shell
  npm install
  ```

1. Add your script to the package.

    - If you are writing in Javascript/Typescript,
    you can convert your script to the JS function, annotate it, and add directly to `src` folder:

    ```typescript
    //name: DemoScript
    //tags: demo
    //language: javascript
    //input: int input1
    ...
    export async function DemoScript(input1: int, ...) {
    ...
    }
    ```

    - Alternatively, create the `scripts` folder in your package directory and place your script file in it.
    This approach works for all script languages.

1. Add the application function to the `src/package.ts`:

  ```typescript
  //name: ApplicationFromScript
  //tags: app, demo
  //description: Demo application created from a script
  //language: javascript
  export async function DemoAppCreate() {
    const func = await grok.functions.eval(`${_package.name}:DemoScript`);
    const call = func.prepare(); 
    call.edit(); 
  }
  ```

  Substitute the `DemoScript` in the `grok.functions.eval` call with the name of your script
  (what you used in the `//name:` annotation, not the file name).

1. Compile and [publish](/help/develop/develop.md#publishing) the package:

  ```shell
  npm run build && grok publish your_environment
  ```

  If you want to make your package publicly available, use the `--release` [publishing mode](/help/develop/develop.md#publishing-modes).

  ```shell
  npm run build && grok publish your_environment --release
  ```

  That's all.
  Now you can run your application from the **Functions > Apps** section
  of the Datagrok UI.

## Integration

Datagrok is designed to be as extensible and as easy to integrate as possible.
So, out of the box, we get many platform integration capabilities such as authentication, data access,
and many others.
In addition to that,
there are some capabilities specific for developers: [REST API](#rest-api) and
[embedding as iframe](#embedding-as-iframe).

### Datagrok platform UI integration

The [functional annotations](/help/datagrok/concepts/functions/func-params-annotation.md)
provide you with several integration options that you can use with any function of script.
Here are some useful examples.

#### Top menu

To add your function to the top menu, add the `top-menu` annotation tag
and specify the element location in the menu.
Save your script and reload the page to see the new element in the top menu.

```python title="Your function header"
#top-menu: Bio | Generate | Sequences clusters...
```

```mdx-code-block
<BrowserWindow bodyStyle={{'padding': '0px'}} url=''>
```

<img src={require('./pics/Scripting-Integration-TopMenu.png').default} style={{'border-radius': '5px'}}/>

```mdx-code-block
</BrowserWindow>
```

#### Info panel

Add your function to the [info panel](../explore/data-augmentation/info-panels)
to display custom information for your data.
To do this, specify [semantic type](getting-started#semantic-types),
for the script input, add `panel` tag and `condition` annotation.
Read the detailed instruction in the corresponding
[developer's howto sections](/help/develop/how-to/add-info-panel#scripts).

### REST API

Once registered, each function gets assigned a REST API endpoint
that allows external code to execute it by passing the
input parameters, along with the authentication token.
This allows instantaneous deployment of scientific methods for
external consumption. To find out how to use it:

- Select the script in [Scripts section](https://public.datagrok.ai/scripts).
- Press F4 to open the context panel on the right.
- Expand the `REST` pane on it.

Both JavaScript and Curl samples are provided.

<details>
<summary> REST API panel </summary>
<div>

![rest-api](./pics/script-rest.png)

</div>
</details>

### JS API

JavaScript-based apps have access to the whole Datagrok platform via the
[JS API](/help/develop/packages/js-api.md).

### Embedding as iframe

Sometimes, an app has to be included in the external web page.
The simplest way to achieve it is via the [iframe](https://www.w3schools.com/tags/tag_iframe.ASP) element.
To embed a model, click on the hamburger icon in the top left corner and choose `Embed...`.
You will see a dialog with the HTML code on top that you can use to embed this into an external site.
Note that you can change parameter values right in the URL.

<details>
<summary> Embedded iframe preview </summary>
<div>

![embed-as-iframe](./pics/embed-as-iframe.png)

</div>
</details>

### JavaScript examples

The set of [script examples](https://public.datagrok.ai/js/samples) is available publicly.
Feel free to play around with them to explore different Datagrok capabilities.

You may use debugging output and write messages:

- into DG interface (use `grok.shell.info()` / `grok.shell.warning()` / `grok.shell.error()`)
- into the console (use `console.log()` and developer console available by F12)

In addition, you can use the built-in Inspector to see what's happening "under the hood" of the platform.
To open Inspector, use the `Alt+I` hotkey.
For example, the Inspector provides information about triggered events.

## Parameters

### Parameter validators

Validators check whether the value falls in the expected range, and provide visual cue if it does not. To add a
validator to a parameter, provide a comma-separated list of functions that will be invoked each time a value is changed.
A null indicates that the value is valid, anything else indicates an error which gets shown to the user.

A validator is a function that accepts one parameter of any type and returns a string. Choice providers are applicable
only to string parameters.

```mdx-code-block
<Tabs>
<TabItem value="result" label="Result">
```

```mdx-code-block
<BrowserWindow url=''>
```

<img src={require('../../uploads/features/script-param-validators.gif').default} style={{'box-shadow': '#4D5261 0px 0px 5px', 'border': '1px solid #F2F2F5'}}/>

```mdx-code-block
</BrowserWindow>
```

```mdx-code-block
</TabItem>
<TabItem value="creation" label="Register validators">
```

```js title="Run this code once"
grok.functions.register({
    signature: 'List<String> jsVal1(int input)',
    run: (input) => input < 11 ? null : "Error val1" });

grok.functions.register({
    signature: 'List<String> jsVal2(int input)',
    run: (input) => input > 9 ? null : "Error val2" });
```

```mdx-code-block
</TabItem>
<TabItem value="usage" label="Use valdiators">
```

```python title="https://public.datagrok.ai/scripts"
#name: Numbers
#language: python title="Use registered validators"
#input: int count1 {validators: ["jsval1", "jsval2"]} [Number of cells in table]
#input: int count2 {validators: ["jsval1"]} [Number of cells in table]
#input: int count3 {validators: ["jsval2"]} [Number of cells in table]
```

```mdx-code-block
</TabItem>
</Tabs>
```

### Parameter choices

Use choices to provide the editor a list of values to choose from. When choices are provided, the editor becomes a combo
box. Choices can be either a fixed list, or a function that returns a list.

A choice provider is a function with no parameters that returns a list of strings.

The following example demonstrates two ways of defining choices:

```mdx-code-block
<Tabs>
<TabItem value="result" label="Result">
```

```mdx-code-block
<BrowserWindow url=''>
```

<img src={require('../../uploads/features/script-param-choices.gif').default} style={{'box-shadow': '#4D5261 0px 0px 5px', 'border': '1px solid #F2F2F5'}}/>

```mdx-code-block
</BrowserWindow>
```

```mdx-code-block
</TabItem>
<TabItem value="creation" label="Register choices">
```

```js title="Run this code once"
grok.functions.register({
    signature: 'List<String> jsVeggies()',
    run: () => ["Cucumber", "Cauliflower"]});
```

```mdx-code-block
</TabItem>
<TabItem value="usage" label="Use choices">
```

```python title="https://public.datagrok.ai/scripts"
#input: string fruit {choices: ["apple", "banana"]}
#input: string vegetable {choices: jsveggies}
```

```mdx-code-block
</TabItem>
</Tabs>
```

### Parameter suggestions

Use parameter suggestions to help users enter a correct value. For instance, when entering a product name, it might make
sense to dynamically query a database for values starting with the already entered text, and suggest to auto-complete
the value.

Suggestions are functions that take one string argument, and return a list of strings to be suggested to user.
Suggestions work only for string parameters.

The following example helps user enter a country name by dynamically retrieving a list of names from a web service:

```mdx-code-block
<Tabs>
<TabItem value="result" label="Result">
```

```mdx-code-block
<BrowserWindow url=''>
```

<img src={require('../../uploads/features/script-param-suggestions.gif').default} style={{'box-shadow': '#4D5261 0px 0px 5px', 'border': '1px solid #F2F2F5'}}/>

```mdx-code-block
</BrowserWindow>
```

```mdx-code-block
</TabItem>
<TabItem value="creation" label="Register suggestions">
```

```js title="Run this code once"
grok.functions.register({
  signature: 'List<String> jsSuggestCountryName(String text)',
  isAsync: true,
  run: async function(text) {
    let response = await fetch('https://restcountries.eu/rest/v2/name/' + text);
    return response.status === 200 ? (await response.json()).map(country => country['name']) : [];
  }
});
```

```mdx-code-block
</TabItem>
<TabItem value="usage" label="Use suggestions">
```

```python title="https://public.datagrok.ai/scripts"
#name: Sales by country
#language: python
#input: string country = uk {suggestions: jsSuggestCountryName}
```

```mdx-code-block
</TabItem>
</Tabs>
```

#### Auto-complete via SQL

The same concept could be used for SQL queries:

```mdx-code-block
<BrowserWindow bodyStyle={{'padding': '0px'}} url=''>
```

<img src={require('./pics/auto-complete-sql.png').default} style={{'border-radius': '5px'}}/>

```mdx-code-block
</BrowserWindow>
```

### Parameter editors

Use parameter editor to set the output of another function to the parameter value. All function parameters will be
seamlessly integrated to the function call form.

```javascript
//input: dataframe table {editor: Package:DataQuery}
//input: dataframe table {editor: Package:DataQuery(1, "France")}
```

Here, Datagrok will execute the `Package:DataQuery` function right before your script and pass the output table to the
script as an input parameter.

```javascript
//input: dataframe table {editor: PowerPack:DataQuery; editor-button: Outliers...}
```

Specify the `editor-button` parameter to add a button that executes your subfunction separately and allows the user to
check the output before starting the script.

### Examples

The list of parameter examples can be used:

```python
#input: dataframe t1 {columns:numerical} [first input data table]
#input: dataframe t2 {columns:numerical} [second input data table]
#input: column x {type:numerical; table:t1} [x axis column name]
#input: column y {type:numerical} [y axis column name]
#input: column date {type:datetime; format:mm/dd/yyyy} [date column name]
#input: column_list numdata {type:numerical; table:t1} [numerical columns names]
#input: int numcomp = 2 {range:2-7} [number of components]
#input: bool center = true [number of components]
#input: string type = high {choices: ["high", "low"]} [type of filter]
#output: dataframe result {action:join(t1)} [pca components]
#output: graphics scatter [scatter plot]
```

## Output values validation

Datagrok functions return zero, one or more typed variables.
Datagrok expects that all variables are defined in the script code and have proper values by the end of the script run.
If this doesn't happen, the two things will follow:

1. The unset output values will be returned as `null`-s.
2. A warning `Output value ${output.param.name} was not set` will be printed in the
   [Datagrok Console](/help/datagrok/navigation/navigation.md#console).
   Open it pressing `~` key or clicking **Console** <i class="fas fa-terminal"></i> button
   in the right bottom corner of the screen.

In this script, the value `c3` is missed to be set:

```r title="R script with missing output value"
#name: TestMissingInputsR
#language: r
#output: int c1
#output: int c2
#output: int c3
c1 <- 12
c2 <- 15
```

Running the script produces the following output to the console:

```mdx-code-block
<BrowserWindow bodyStyle={{'padding': '0px'}} url=''>
```

```
Output value c3 was not set
  c1: 12
  c2: 15
  c3: null
```

```mdx-code-block
</BrowserWindow>
```

