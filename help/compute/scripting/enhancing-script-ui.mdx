---
title: "Enhancing script UI"
sidebar_position: 2
---

```mdx-code-block
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import BrowserWindow from '@site/src/components/browser-window';
```

The **RichFunctionView** is an advanced UI editor,
allowing you to create a complex full-featured interface for your script.

It has all the features of the basic script view, such as
[captions](getting-started#input-captions),
[output viewers](getting-started#adding-viewers-for-output-dataframes),
[parameters grouping](getting-starteds#grouping-inputs)
etc.

In addition to it, you can:

- Add [viewers for input dataframes](#adding-input-dataframe-viewers)
- Group [outputs](#grouping-outputs)
- [Automatically re-run calculations](#re-running-script-on-opening--on-input-change)
- [Validate inputs](#validating-inputs)
- [Automate export](#exporting-run-results-to-a-file) of script results.
- Use [custom inputs](#using-custom-inputs)
- Save and access [run history](#history)

## Enabling RichFunctionView

To enable **RichFunctionView**, add `editor: Compute:RichFunctionViewEditor` tag
to your following code as it is shown:

```mdx-code-block
<Tabs>
<TabItem value="result" label="Result" default>
```

```mdx-code-block
<BrowserWindow bodyStyle={{'padding': '0px'}} url=''>
```

<img src={require('./pics/rich-function-demo.gif').default} style={{'border-radius': '5px'}}/>

```mdx-code-block
</BrowserWindow>
```

```mdx-code-block
</TabItem>
<TabItem value="python" label="Python">
```

```python title="Your script header"
#editor: Compute:RichFunctionViewEditor
```

```mdx-code-block
</TabItem>
<TabItem value="js" label="Javascript">
```

```javascript title="Your script header"
//editor: Compute:RichFunctionViewEditor
```

```mdx-code-block
</TabItem>
</Tabs>
```

:::warning Package dependency

The `RichFunctionViewEditor` is a part of the `Compute` package.
Ensure that the `Compute` package is installed before working with `RichFunctionViewEditor`

:::

:::tip Ensure computations are correct

Use the RichFunctionView only when you are sure that the script works as expected.
Features of the RichFunctionView affect GUI only and do not affect computations.

:::

## Adding input dataframe viewers

You can add viewers for input dataframes to review input data before starting computations,
same way as for
[output viewers](getting-started#adding-viewers-for-output-dataframes).

```mdx-code-block
<Tabs>
<TabItem value="result" label="Result">
```

```mdx-code-block
<BrowserWindow bodyStyle={{'padding': '0px'}} url=''>
```

<img src={require('./pics/input-viewers.gif').default} style={{'border-radius': '5px'}}/>

```mdx-code-block
</BrowserWindow>
```

```mdx-code-block
</TabItem>
<TabItem value="short" label="Short sample">
```

```javascript title="Your script header"
//input: dataframe test { viewer: Line chart | Grid }
```

```mdx-code-block
</TabItem>
<TabItem value="full" label="Full sample">
```

```javascript title="https://public.datagrok.ai/scripts"
//name: Viewer properties demo
//language: javascript
//sample: demog.csv
//input: dataframe test { viewer: Line chart | Grid }
//output: dataframe test2
//editor: Compute:RichFunctionViewEditor
test2 = test.clone();
```

```mdx-code-block
</TabItem>
</Tabs>
```

You can specify input viewer's properties to control their appearance.
Viewer's properties are listed in the braces right after the viewer's name.
A full list of the viewer's properties may be found by right-clicking on it and selecting the `Properties...` menu item.

RichFunctionView supports the `block` option to control the viewer's width.
By default, any viewer occupies all available space.

```mdx-code-block
<Tabs>
<TabItem value="result" label="Result">
```

```mdx-code-block
<BrowserWindow bodyStyle={{'padding': '0px'}} url=''>
```

<img src={require('./pics/viewers-block.png').default} style={{'border-radius': '5px'}}/>

```mdx-code-block
</BrowserWindow>
```

```mdx-code-block
</TabItem>
<TabItem value="short" label="Short sample">
```

```javascript title="Your script header"
//input: dataframe demog { viewer: Line chart(block: 75) | Filters(block: 25) }
```

```mdx-code-block
</TabItem>
<TabItem value="full" label="Full sample">
```

```javascript title="https://public.datagrok.ai/scripts"
//name: Viewer block option demo
//language: javascript
//input: dataframe demog { viewer: Line chart(block: 75) | Filters(block: 25) }
//output: dataframe test2
//editor: Compute:RichFunctionViewEditor
test2 = test.clone();
```

```mdx-code-block
</TabItem>
</Tabs>
```

## Folded input categories

To fold input category, use the `meta.foldedCategories` annotation.

```mdx-code-block
<Tabs>
<TabItem value="result" label="Result">
```

```mdx-code-block
<BrowserWindow bodyStyle={{'padding': '0px'}} url=''>
```

<img src={require('./pics/folded-categories.gif').default} style={{'border-radius': '5px'}}/>

```mdx-code-block
</BrowserWindow>
```

```mdx-code-block
</TabItem>
<TabItem value="short" label="Short sample">
```

```javascript title="Your script header"
//input: double desiredTemperature = 300.0 { units: C; caption: Desired temperatore; category: Goals }
//input: double desiredPressure = 1.0 { units: Atm; caption: Goal pressure; category: Goals }
//editor: Compute:RichFunctionViewEditor
//meta.foldedCategories: ["Goals"]
```

```mdx-code-block
</TabItem>
</Tabs>
```

## Grouping outputs

You can use the `category` keyword to group output parameters,
similar to the [input categories](getting-started#grouping-inputs).
In the case of output parameters, the `category` tag specifies
the output tab used to show the output parameter values.
The following code generates UI with three output tabs:

```mdx-code-block
<Tabs>
<TabItem value="result" label="Result">
```

```mdx-code-block
<BrowserWindow bodyStyle={{'padding': '0px'}} url=''>
```

<img src={require('./pics/output-categories.gif').default} style={{'border-radius': '5px'}}/>

```mdx-code-block
</BrowserWindow>
```

:::tip

The view includes 4 tabs in total since there is a separate tab for input dataframe viewers.

:::

```mdx-code-block
</TabItem>
<TabItem value="short" label="Short sample">
```

```javascript title="Your script header"
//output: dataframe tempOnTime4 { viewer: Line chart; category: Experimental data }
//output: dataframe tempOnTime5 { viewer: Line chart | Line chart; category: Simulation data }
//output: double IC3 { category: Tab #3}
//output: double IC4 { category: Tab #3}
```

```mdx-code-block
</TabItem>
<TabItem value="full" label="Full sample">
```

```javascript title="https://public.datagrok.ai/scripts"
//name: Grouping outputs
//language: javascript
//input: dataframe test { viewer: Line chart }
//input: double S1 = 50 { caption: S1 }
//output: dataframe tempOnTime4 { viewer: Line chart; category: Experimental data }
//output: double IC1 { category: Experimental data }
//output: dataframe tempOnTime5 { viewer: Line chart | Line chart; category: Simulation data }
//output: double IC2 { category: Simulation data }
//output: double IC3 { category: Tab #3 }
//output: double IC4 { category: Tab #3 }
//editor: Compute:RichFunctionViewEditor

tempOnTime4 = test;
tempOnTime5 = test;

IC1 = 10;
IC2 = 20;
IC3 = test.rowCount * 2;
IC4 = test.rowCount;
```

```mdx-code-block
</TabItem>
</Tabs>
```

## Adding readme

You may add customized readme file to your script.
The linked Markdown file will be available by clicking <i class="fal fa-info"></i> icon on the ribbon panel.
The readme file will appear inside of the panel on the right side.

```mdx-code-block
<Tabs>
<TabItem value="result" label="Result">
```

```mdx-code-block
<BrowserWindow bodyStyle={{'padding': '0px'}} url=''>
```

<img src={require('./pics/rfv-help.png').default} style={{'border-radius': '5px'}}/>

```mdx-code-block
</BrowserWindow>
```

```mdx-code-block
</TabItem>
<TabItem value="short" label="Short sample">
```

Following code will search for the help file in the particular package (e.g., `Compute`).

```javascript title="Your script header (w/ package file)"
//meta.help: Compute/readme.md
```

Following code will search for the help file in your Datagrok's Home folder.

```javascript title="Your script header (w/ personal file)"
//meta.help: readme.md
```

```mdx-code-block
</TabItem>
<TabItem value="full" label="Full sample">
```

```javascript title="https://public.datagrok.ai/scripts"
//name: Data stats
//language: javascript
//tags: demo
//input: dataframe inputDf {caption: Input dataframe; viewer: Grid(); category: Input data}
//output: dataframe outputDf {caption: Output dataframe; viewer: Line chart(block: 50) | Scatter plot(block: 50) | Statistics(block: 100); category: Stats}
//editor: Compute:RichFunctionViewEditor
//meta.runOnOpen: true
//meta.runOnInput: true

outputDf = inputDf.clone();
```

```mdx-code-block
</TabItem>
</Tabs>
```

## File upload

You can use a file as a function input via RichFunctionView,
similar to the default [FileIO UI](getting-started#file-input).
Generated UI allows you to choose any local file or drag'n'drop it directly.
The chosen file will be available in the
code as JS [File](https://developer.mozilla.org/en-US/docs/Web/API/File) object.

:::caution Restriction

Currently, RichFunctionView supports the `file` input
only for JavaScript functions.

:::

## Re-running script on opening & on input change

You can run scripts automatically on UI opening and/or on any input change.
This feature is useful for fast prototyping. We recommend using it only
on fast `Javascript` scripts only to avoid repeatable runs of computational-heavy code.

The automatic function calls are not saved,
so to save results to the [run history](#history) you should press **Save** button manually.

```mdx-code-block
<Tabs>
<TabItem value="result" label="Result">
```

```mdx-code-block
<BrowserWindow bodyStyle={{'padding': '0px'}} url=''>
```

<img src={require('./pics/run-on-input.gif').default} style={{'border-radius': '5px'}}/>

```mdx-code-block
</BrowserWindow>
```

```mdx-code-block
</TabItem>
<TabItem value="short" label="Short sample">
```

```javascript title="Your script header"
//meta.runOnOpen: true
//meta.runOnInput: true 
```

```mdx-code-block
</TabItem>
<TabItem value="full" label="Full sample">
```

```javascript title="https://public.datagrok.ai/scripts"
//name: Data stats
//language: javascript
//tags: demo
//input: dataframe inputDf {caption: Input dataframe; viewer: Grid(); category: Input data}
//output: dataframe outputDf {caption: Output dataframe; viewer: Line chart(block: 50) | Scatter plot(block: 50) | Statistics(block: 100); category: Stats}
//editor: Compute:RichFunctionViewEditor
//meta.runOnOpen: true
//meta.runOnInput: true

outputDf = inputDf.clone();
```

```mdx-code-block
</TabItem>
</Tabs>
```

## Validating inputs

You can use validator functions to validate inputs, similar to the
[platform validators](/help/datagrok/concepts/functions/func-params-annotation#validation).
Validation functions have full access to the
UI and to the context of the script. For example, you can create a function to validate min-max values,
assuring that the minimum value is less than the maximum value.

:::caution

Validation functions should be written in JavaScript to avoid client-server communication delays.

:::

Validation functions have a single input and a single output.

- `params` object may have arbitrary data for the validator to behave differently in certain situations.
- `validator` object is a JS function (e.g. arrow function) that actually will be called each time the input is changed.

Here is an example used in the default [Object cooling](https://public.datagrok.ai/scripts?q=object+cooling) script.  

```mdx-code-block
<Tabs>
<TabItem value="result" label="Result">
```

```mdx-code-block
<BrowserWindow bodyStyle={{'padding': '0px'}} url=''>
```

<img src={require('./pics/validator.png').default} style={{'border-radius': '5px'}}/>

```mdx-code-block
</BrowserWindow>
```

```mdx-code-block
</TabItem>
<TabItem value="validator" label="Validator function">
```

```javascript title="package.ts"
//name: DesiredTempValidator
//input: object params
//output: object validator
export function DesiredTempValidator(params: any) {
  return (val: number, info: ValidationInfo) => {
    const ambTemp = info.funcCall.inputs['ambTemp'];
    const initTemp = info.funcCall.inputs['initTemp'];
    return makeValidationResult({
      errors: [
        ...(val < ambTemp) ? [makeAdvice(`Desired temperature cannot be less than ambient temperature (${ambTemp}). \n`, [
          {actionName: 'Set desired equal to ambient', action: () => info.funcCall.inputs['desiredTemp'] = ambTemp }
        ])]: [],
        ...(val > initTemp) ? [`Desired temperature cannot be higher than initial temperature (${initTemp})`]: [],
      ]
    });
  };
}
```

```mdx-code-block
</TabItem>
<TabItem value="usage" label="Assigning validator to an input">
```

```javascript title="Your script header"
//input: double desiredTemp = 30 {caption: Desired temperature; units: C; category: Environment; validator: Compute:DesiredTempValidator; }
```

```mdx-code-block
</TabItem>
</Tabs>
```

This function accesses other inputs' values via the `info` object.
It compares the validated input using contextual information.
If validation fails, it returns an error and possible action to make validation pass
(structure with `actionName` and `action` fields). You may make your validation interactive
and educational using such errors, warnings, and proposed actions.

:::tip

We suggest you using functions from
[packages](/help/develop/develop.md#packages)
instead of scripts for easier code management.

:::

## Using custom inputs

RichFunctionView supports custom inputs. You can create your own input and use it via the special `input` tag.
Much like a validator function, custom input also should be returned by Datagrok function.

:::caution

Custom input functions should be written in JavaScript.

:::

Here is an example of a custom input for string values. It behaves exactly the same as the default string input
but has `aqua` background color.

```mdx-code-block
<Tabs>
<TabItem value="result" label="Result">
```

```mdx-code-block
<BrowserWindow bodyStyle={{'padding': '0px'}} url=''>
```

<img src={require('./pics/custom-input.png').default} style={{'border-radius': '5px'}}/>

```mdx-code-block
</BrowserWindow>
```

```mdx-code-block
</TabItem>
<TabItem value="validator" label="Custom input">
```

```javascript title="package.ts"
//name: CustomStringInput
//input: object params
//output: object input
export function CustomStringInput(params: any) {
  const defaultInput = ui.stringInput('Custom input', '');
  defaultInput.root.style.backgroundColor = 'aqua';
  defaultInput.input.style.backgroundColor = 'aqua';
  return defaultInput;
}
```

```mdx-code-block
</TabItem>
<TabItem value="usage" label="Using a custom input">
```

```javascript title="Your script header"
//input: string test {input: Compute:CustomStringInput }
```

```mdx-code-block
</TabItem>
</Tabs>
```

## Exporting run results to a file

Enabled by default.

You can use the one-click export feature to save the entire script run to a local file.
To generate the export file,
Select <i class="fas fa-arrow-to-bottom"></i> **Export** icon on the top panel.
Automatic export saves all input and output values with their captions,
units, and even viewers' screenshots.
This feature is available for all scripts using the RichFunctionView.

```mdx-code-block
<Tabs>
<TabItem value="result" label="Result">
```

![export-demo](./pics/export-demo.gif)

```mdx-code-block
</TabItem>
<TabItem value="javascript" label="Disable export">
```

```javascript title="Your script header"
//meta.features: {"export": false}
```

```mdx-code-block
</TabItem>
</Tabs>
```

## History

<div style = {{ display: 'flex' }}>

<div style = {{ width: '60%' }}>

Enabled by default.

When enabled, the server saves each script run. The saved script run includes both the input and output values of the run.
To review the history of runs, click on the <i class="fas fa-history"></i> **History** button on the top panel.

The history panel appears on the right side. To load the run into the UI, click on the corresponding card.
The historical runs are immutable. Thus, if you load a historical run,
change input values, and then rerun it,
the platform will create a new historical run.

</div>

<div style = {{ width: '40%', marginLeft: '15px' }}>

```mdx-code-block
<BrowserWindow bodyStyle={{'padding': '0px'}} url=''>
```

<img src={require('./pics/history.png').default} style={{'border-radius': '5px'}}/>

```mdx-code-block
</BrowserWindow>
```

</div>

</div>

<details>
<summary> How to disable history </summary>
<div>

```javascript title="Your script header"
//meta.features: {"history": false}
```

</div>
</details>

## Comparing the historical runs

You may compare historical runs using history panel. Select the historical runs of the interest
and click <i class="fas fa-exchange"></i> icon to open the comparison view.

:::tip

Click on the column header with table data (e.g. `Temp. vs time`) to see convinient comparison chart.

:::

```mdx-code-block
<Tabs>
<TabItem value="result" label="Comparison">
```

```mdx-code-block
<BrowserWindow bodyStyle={{'padding': '0px'}} url=''>
```

<img src={require('./pics/comparsion-view.png').default} style={{'border-radius': '5px'}}/>

```mdx-code-block
</BrowserWindow>
```

```mdx-code-block
</TabItem>
<TabItem value="short" label="How to compare">
```

```mdx-code-block
<BrowserWindow bodyStyle={{'padding': '0px'}} url=''>
```

<div style={{'text-align': 'center'}}>
<img src={require('./pics/call-compare.png').default} style={{'border-radius': '5px'}}/>
</div>

```mdx-code-block
</BrowserWindow>
```

```mdx-code-block
</TabItem>
</Tabs>
```

## Customizing the comparison

You may provide a Datagrok function to customize the comparison of the historical runs.
For example, you may add particular viewers to your comparison or make additional comparative analysis.

```mdx-code-block
<Tabs>
<TabItem value="result" label="Custom comparison">
```

```mdx-code-block
<BrowserWindow bodyStyle={{'padding': '0px'}} url=''>
```

<img src={require('./pics/custom-compare.png').default} style={{'border-radius': '5px'}}/>

```mdx-code-block
</BrowserWindow>
```

```mdx-code-block
</TabItem>
<TabItem value="enable custom" label="Enabling custom data upload">
```

```javascript title="Your script header"
//meta.compareCustomizer: Compute:CustomCustomizer
```

```mdx-code-block
</TabItem>
<TabItem value="custom comparator" label="Custom data uploader">
```

```javascript title="package.ts"
//name: CustomCustomizer
//input: object params
export function CustomCustomizer(params: {defaultView: DG.TableView}) {
  const comparisonView = params.defaultView;
  comparisonView.scatterPlot({
    "xColumnName": "Initial temperature",
    "yColumnName": "Time to cool",
  });
}
```

```mdx-code-block
</TabItem>
</Tabs>
```

<details>
<summary> Comparison customization API </summary>
<div>

Customizer function should have `//input: object params` in the header.
This object will contain `defaultView` reference to the default-contructed DG.TableView.
Customizations may be applied directly using this reference.

</div>
</details>

## Sensitivity analysis

Disabled by default.

You may use sensitivity analysis (SA) to explore function behavior when inputs are varied in predefined ranges.
Enable this feature and click **<i class="fas fa-analytics"></i> SA** icon on the top panel.

```mdx-code-block
<Tabs>
<TabItem value="result" label="Result">
```

```mdx-code-block
<BrowserWindow bodyStyle={{'padding': '0px'}} url=''>
```

<img src={require('./pics/sens-analysis.png').default} style={{'border-radius': '5px'}}/>

```mdx-code-block
</BrowserWindow>
```

```mdx-code-block
</TabItem>
<TabItem value="short" label="Short sample">
```

```javascript title="Your script header"
//meta.features: {"sens-analysis": true}
```

```mdx-code-block
</TabItem>
<TabItem value="full" label="Full sample">
```

```javascript title="https://public.datagrok.ai/scripts"
//name: Object cooling
//description: Uses Newton's law of cooling to simulate object cooling process. Default values are for cube of boiling water in air.
//language: javascript
//tags: simulation, demo
//input: double ambTemp = 22 {caption: Ambient temperature; units: C; category: Environment; block: 50; validator: Compute:AmbTempValidator; }
//input: double initTemp = 100 {caption: Initial temperature; units: C; category: Environment; block: 50; validator: Compute:InitialTempValidator; }
//input: double desiredTemp = 30 {caption: Desired temperature; units: C; category: Environment; validator: Compute:DesiredTempValidator; }
//input: double area = 0.06 {caption: Surface area; units: m²; category: Object properties}
//input: double heatCap = 4200 {caption: Heat capacity; units: J/C; category: Object properties; validator: Compute:HeatCapValidator; }
//input: double heatTransferCoeff = 8.3 {caption: Heat transfer coefficient; units: W/(m² * C); category: Object properties}
//input: int simTime = 21600 {caption: Simulation time; units: sec; category: Simulation; validator: Compute:SimTimeValidator; validatorOptions: { "reasonableMin": 10800, "reasonableMax": 100000} }
//output: dataframe simulation {caption: Temp. vs time; category: Output; viewer: Line chart(block: 75) | Grid(block: 25)}
//output: double timeToCool {caption: Time to cool; units: sec.; category: Output}
//output: double coolingFactor {caption: Cooling factor; units: 1 / sec.; category: Calculations}
//output: double tempDiff {caption: Temperature difference; units: C; category: Calculations}
//editor: Compute:RichFunctionViewEditor
//meta.features: {"sens-analysis": true}
//meta.foldedCategories: ["Object properties"]

timeToCool = undefined;

const tempDiff = initTemp - ambTemp;
const coolingFactor = heatTransferCoeff * area / heatCap;

const timeStamps = new Float32Array(simTime).map((_, idx) => idx);
const simulatedTemp = timeStamps.map((timeStamp) => {
  const currentTemp = ambTemp + (tempDiff * (Math.E ** -(coolingFactor * timeStamp)));

  if (!timeToCool && currentTemp < desiredTemp) {
    timeToCool = timeStamp;
  }

  return currentTemp;
});

simulation = DG.DataFrame.fromColumns([
  DG.Column.fromFloat32Array('Time', timeStamps),
  DG.Column.fromFloat32Array('Temperature', simulatedTemp),
]);


```

```mdx-code-block
</TabItem>
</Tabs>
```

## Uploading experimental data

Disabled by default.

Using this mode,
you can create in the run history a "fake" run by uploading data from some external source instead of
running the script.
Saved historical run with external data will have the `experimental` tag.

After uploading experimental data to the history, you can compare it with other history records
using build-in **Compare runs** capability.
This specific capability is beneficial when you're developing a
model, predicting the behavior of some real-world process.

To enable this feature,
add `//meta.features: {"upload": true}` tag to your script.
This will add the <i class="fas fa-upload"></i> **Upload mode** button to the generated GUI.
RichFunctionView automatically collects all data fields you need to mimic script run,
and creates corresponding UI elements.

Here is an example used in the default [Object cooling](https://public.datagrok.ai/scripts?q=object+cooling) script.  

```mdx-code-block
<Tabs>
<TabItem value="result" label="Result">
```

```mdx-code-block
<div style = {{display: 'flex', flexDirection: 'row', justifyContent: 'space-between'}}>
<div style = {{maxWidth: '45%'}}>

Data upload GUI:

<BrowserWindow bodyStyle={{'padding': '0px'}} url=''>
```

<img src={require('./pics/basic-data-upload.png').default} style={{'border-radius': '5px'}}/>

```mdx-code-block
</BrowserWindow>
</div>

<div style = {{maxWidth: '50%'}}>

Experimental run in history:

<BrowserWindow bodyStyle={{'padding': '0px'}} url=''>
```

<img src={require('./pics/exp-run-history.png').default} style={{'border-radius': '5px'}}/>

```mdx-code-block
</BrowserWindow>
</div>
</div>
```

```mdx-code-block
</TabItem>
<TabItem value="enable" label="Enabling data upload">
```

```javascript title="Your script header"
//meta.features: {"upload": true}
```

```mdx-code-block
</TabItem>
</Tabs>
```

## Customizing the experimental data upload

You may customize the data upload using Datagrok functions and `meta.uploadFunc` tag.
The function mentioned in this tag will be called on clicking <i class="fas fa-upload"></i> button instead of the basic data upload.
You may use it to extract the experimental data from the external resource (e.g., a database).
Extracted data could be saved to the history or could be used directly to compare the computed and experimental results.

```mdx-code-block
<Tabs>
<TabItem value="enable custom" label="Enabling custom data upload">
```

```javascript title="Your script header"
//meta.uploadFunc: Compute:CustomUploader
```

```mdx-code-block
</TabItem>
<TabItem value="widget function" label="Widget generator">
```

```javascript title="package.ts"
//name: CustomUploader
//input: object params
//output: widget uploadWidget
//output: funccall uploadFuncCall
export async function CustomUploader(params: {func: DG.Func}) {
  const uploadFunc = await grok.functions.eval('Compute:DataExtractor') as DG.Func;
  const uploadFuncCall = uploadFunc.prepare({func: params.func})
  const uploadBtn = ui.bigButton('Click me to get mock calls', () => uploadFuncCall.call());

  const dummyWidget = DG.Widget.fromRoot(ui.panel([ui.divV([
    ui.label('This part of dialog comes from my custom data uploader'),
    ui.divH([uploadBtn], {style: {'justify-content': 'center'}})
  ])]));  

  const setLoadingSub = grok.functions.onBeforeRunAction.pipe(
    filter((call) => call.id === uploadFuncCall.id)
  ).subscribe(() => {
    ui.setUpdateIndicator(uploadBtn, true);
  })

  const unsetLoadingSub = grok.functions.onAfterRunAction.pipe(
    filter((call) => call.id === uploadFuncCall.id)
  ).subscribe(() => {
    ui.setUpdateIndicator(uploadBtn, false);
  })

  dummyWidget.subs.push(setLoadingSub, unsetLoadingSub)

  return {uploadWidget: dummyWidget, uploadFuncCall};
}
```

```mdx-code-block
</TabItem>
<TabItem value="Data extraction function" label="Data extractor">
```

```javascript title="package.ts"
//name: DataExtractor
//input: func func
//output: object uploadedCalls
export async function DataExtractor(func: DG.Func) {
  await new Promise((r) => setTimeout(r, 1000));

  const dummyFunccall = await func.prepare({
    'ambTemp': 22,
    'initTemp': 100,
    'desiredTemp': 30,
    'area': 0.06,
    'heatCap': 4200,
    'heatTransferCoeff': 8.3,
    'simTime': 21600,
    }).call();
    
  return [dummyFunccall]
}
```

```mdx-code-block
</TabItem>
</Tabs>
```

<details>
<summary> Data upload API </summary>
<div>

The custom upload funcion should return `uploadWidget` (of type DG.Widget) and `uploadFuncCall` (of type DG.FuncCall).
`uploadWidget` will be shown on the UI; `uploadFuncCall`, in turn, should return the experimental runs typed as array of DG.FuncCalls.

</div>
</details>