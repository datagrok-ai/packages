name: "Unskip package tests if task is done"
on:
  workflow_dispatch:
    inputs:
      packages:
        description: 'Packages separated by spaces'
        required: true
        type: string
#  schedule:
#    - cron: '0 * * * *'

jobs:
  check_skipped_tests:
    name: Get packages with skipped tests
    runs-on: ubuntu-22.04
    outputs:
      deleted_skip_reason_packages: ${{ steps.deleted_skipReason_packages.outputs.deleted_skip_reason_packages}}
    steps:
      - name: Checkout
        uses: actions/checkout@v3
        with:
          fetch-depth: 2
          token: ${{ secrets.WRITE_TOKEN }}
      - name: Get packages with tests
        id: packages_with_tests
        run: |
          PACKAGES_TEST=''
          PACKAGES=${ls -la | grep '^d' | awk '{print $9}'}
          for package in $PACKAGES; do
            if [ -d "$package/src/tests" ] && grep -rq "skipReason: 'GROK-.*: .*'" "$package/src/tests"; then
                PACKAGES_TEST+= "$package"
            fi
          done
          echo "Jira_skipReason_packages=$PACKAGES_TEST" >> $GITHUB_OUTPUT
        working-directory: packages
      - name: Get packages with deleted skipReason in tests
        id: deleted_skipReason_packages
        run: |
          apt update && apt install -y curl
          deleted_skip_reason_packages=''
          for package in ${{ steps.test-package.outcome.Jira_skipReason_packages }}; do
            files=($(grep -ro "skipReason: 'GROK-.*: .*'" "$package/src/tests" | awk -F: '{print $1}'))
            issues=($(grep -ro "skipReason: 'GROK-.*: .*'" "$package/src/tests" | awk -F: '{print $3}'))
            for ((i=0; i<${#files[@]}; i++)); do
              file=${files[$i]}
              issue=$(echo "${issues[$i]}" | cut -c2-)
              if [[ $(curl -u ${{ secrets.JIRA_LOGIN }}:${{ secrets.JIRA_TOKEN }} -X GET -H "Content-Type: application/json" https://reddata.atlassian.net/rest/api/2/issue/$issue?fields=status | jq -r '.fields.status.name') == "Done" ]] || [[ $(curl -u ${{ secrets.JIRA_LOGIN }}:${{ secrets.JIRA_TOKEN }} -X GET -H "Content-Type: application/json" https://reddata.atlassian.net/rest/api/2/issue/$issue?fields=status | jq -r '.fields.status.name') == "Won't fix" ]]; then
                 skipreasons=()
                 while IFS= read -r line; do
                     skipreasons+=("$line")
                 done < <(grep -ro "skipReason: 'GROK-.*: .*'" "$package/src/tests/$file")
                 for reason in "${skipreasons[@]}"; do
                     sed -i "s/{\$reason}//" "$package/src/tests/$file"
                     echo deleted skipReason $reason in package $package in test-file $file
                 done
                 deleted_skip_reason_packages+=$package
              fi
            done
          done
          echo "deleted_skip_reason_packages=$deleted_skip_reason_packages" >> $GITHUB_OUTPUT
        working-directory: packages
      - name: Commit changes
        id: commit_unskip
        if: steps.deleted_skipReason_packages.outputs.deleted_skip_reason_packages != ''
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          git add .
          git commit -m "GitHub Actions: Unskip tests for packages ${{ steps.deleted_skipReason_packages.outputs.deleted_skip_reason_packages }}

          Workflow ${{ github.workflow }} ${{ github.run_number }}
          https://github.com/datagrok-ai/public/actions/runs/${{ github.run_id }}"
        working-directory: packages
  matrix:
    name: Transform packages to matrix
    runs-on: ubuntu-22.04
    needs: check_skipped_tests
    if: needs.check_skipped_tests.outputs.deleted_skip_reason_packages != ''
    outputs:
      matrix_publish: ${{ steps.generate-matrix.outputs.matrix_publish }}
    steps:
      - name: Generate matrix
        id: generate-matrix
        run: |
          MATRIX_PUBLISH_JSON="["
          for PACKAGE in $(echo ${{ needs.check_skipped_tests.outputs.deleted_skip_reason_packages }} | sort -u); do
            DIR="packages/${PACKAGE}"
            if [ -f "${DIR}/package.json" ]; then
              MATRIX_PUBLISH_JSON+="{\"package\": \"${PACKAGE}\""
              current_version="$(jq -r '.version' "${DIR}/package.json")"
              MATRIX_PUBLISH_JSON+=", \"version\": \"${current_version}\""
              dependencies="$(jq '(. | select( has("dependencies") == true ).dependencies) * (. | select( has("devDependencies") == true ).devDependencies)' "${DIR}/package.json")"
              unpublished_deps="$(jq -r '. | to_entries | map(select(.value | match("\\.\\./.*")))[] | "\(.key)=\(.value)"' <<<$dependencies | tr '\n' ' ')"
              MATRIX_PUBLISH_JSON+=", \"unpublished_deps\": \"$unpublished_deps\""
              MATRIX_PUBLISH_JSON+="}"
            fi
          done
          MATRIX_PUBLISH_JSON="${MATRIX_PUBLISH_JSON//\}\{/\}, \{}"
          MATRIX_PUBLISH_JSON+="]"
          PUBLISH_JSON="{\"include\": ${MATRIX_PUBLISH_JSON}}"
          echo "matrix_publish=${PUBLISH_JSON}" >> $GITHUB_OUTPUT
  test_packages:
    name: Testing packages with uskipped tests 
    runs-on: ubuntu-22.04
    needs: 
      - check_skipped_tests
      - matrix
    if: needs.check_skipped_tests.outputs.deleted_skip_reason_packages
    env:
      HOST: GitHubAction
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.matrix.outputs.matrix_publish) }}
    steps:
      - name: Run datagrok stand
        id: datagrok-image
        run: |
          echo "Find grok dependencies packages"
          grok_deps="$(jq  -r '. | select( has("devDependencies") == true ).devDependencies | to_entries[] | .key | select(test("@datagrok/.*")?)' packages/${{ matrix.package }}/package.json)"
          profiles='--profile datagrok --profile db --profile grok_connect'
          echo "Check if CVM is required for the package"
          if [[ "$(tr '[:upper:]' '[:lower:]' <<<${{ matrix.package }})" == "chem" ]] || \
             [[ "$(tr '[:upper:]' '[:lower:]' <<<${{ matrix.package }})" == "simpkpd" ]] || \
             [[ "$(tr '[:upper:]' '[:lower:]' <<<${{ matrix.package }})" == "dendrogram" ]] || \
             [[ "$(tr '[:upper:]' '[:lower:]' <<<${{ matrix.package }})" == "cvmtests" ]] || \
             [[ "$(tr '[:upper:]' '[:lower:]' <<<${grok_deps})" == *"chem"* ]] || \
             [[ "$(tr '[:upper:]' '[:lower:]' <<<${grok_deps})" == *"simpkpd"* ]] || \
             [[ "$(tr '[:upper:]' '[:lower:]' <<<${grok_deps})" == *"cvmtests"* ]] || \
             [[ "$(tr '[:upper:]' '[:lower:]' <<<${grok_deps})" == *"dendrogram"* ]]; then
            echo "Add Scripting as dependency for package ${{ matrix.package }}"
            profiles+=' --profile scripting'
          fi
          if [[ "$(tr '[:upper:]' '[:lower:]' <<<${{ matrix.package }})" == "chem" ]] || \
             [[ "$(tr '[:upper:]' '[:lower:]' <<<${grok_deps})" == *"chem"* ]]; then
            echo "Add Grok Compute as dependency for package ${{ matrix.package }}"
            profiles+=' --profile grok_compute'
          fi
          echo "Check if Grok Spawner is required for the package"
          if [ -d "packages/${{ matrix.package }}/dockerfiles" ]; then
            profiles+=' --profile grok_spawner'
          fi
          echo "Run datagrok stand with profiles ${profiles}"
          docker system prune -af --volumes
          if [[ "${{ matrix.unpublished_deps }}" == "" ]] && [[ "$(tr '[:upper:]' '[:lower:]' <<<${{ matrix.package }})" != "chem" ]] && [[ "$(tr '[:upper:]' '[:lower:]' <<<${{ matrix.package }})" != "bio" ]] && [[ "$(tr '[:upper:]' '[:lower:]' <<<${{ matrix.package }})" != "peptides" ]]; then
            DATAGROK_VERSION='latest'
          else
            DATAGROK_VERSION='bleeding-edge'
          fi
          export DATAGROK_VERSION
          docker compose -p datagrok -f "docker/localhost.docker-compose.yaml" ${profiles} up -d
          echo "Set docker_sha"
          docker_sha=$(docker images --quiet "datagrok/datagrok:$DATAGROK_VERSION")
          echo "docker_sha=$docker_sha" >> $GITHUB_OUTPUT
          echo "Notify about version used for tests"
          echo "::notice title=${{ matrix.package }}::datagrok/datagrok:$DATAGROK_VERSION SHA=$docker_sha docker version was used for tests"
          df -h


