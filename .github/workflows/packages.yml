name: Packages
on:
  workflow_dispatch:
    inputs:
      packages:
        description: 'Packages separated by spaces'
        required: true
        type: string
  push:
    paths:
      - 'packages/**'

jobs:
  matrix:
    name: Check changes
    runs-on: ubuntu-20.04
    outputs:
      matrix_test: ${{ steps.generate-matrix.outputs.matrix_test }}
      matrix_publish: ${{ steps.generate-matrix.outputs.matrix_publish }}
      test: ${{ steps.generate-matrix.outputs.test }}
      publish: ${{ steps.generate-matrix.outputs.publish }}
    steps:
      - name: Checkout
        uses: actions/checkout@v3
        with:
          fetch-depth: 3
      - name: Generate matrix
        id: generate-matrix
        run: |
          if [[ "${{ github.event.inputs.packages }}" == "" ]]; then
            if [[ $(git log -n 1 --pretty=%B) == *"Merge branch 'master' of"* ]]; then
              commit="$(git log --format="%H" -n 1 --no-merges)"
            else
              commit=${{ github.sha }}
            fi
            CHANGED_PACKAGES="$(git diff-tree -m --no-commit-id --name-only -r "$(echo -n "$commit")" 'packages/**' | xargs -I {} dirname {} | awk -F'/' '{print $2}' | sort -u)"
          else
            CHANGED_PACKAGES="${{ github.event.inputs.packages }}"
          fi

          MATRIX_PUBLISH_JSON="["

          for PACKAGE in $(echo ${CHANGED_PACKAGES} | sort -u); do
            DIR="packages/${PACKAGE}"
            if [ -f "${DIR}/package.json" ]; then
              MATRIX_PUBLISH_JSON+="{\"package\": \"${PACKAGE}\""

              scripts="$(jq  '. | select( has("scripts") == true ).scripts' "${DIR}/package.json")"
              dependencies="$(jq  '(. | select( has("dependencies") == true ).dependencies) * (. | select( has("devDependencies") == true ).devDependencies)' "${DIR}/package.json")"

              if [ -n "$(jq  '. | select( has("test") == true )' <<< "$scripts")" ] && \
                  [[ "$(jq  '. | select( has("skipCI") == true ).skipCI' "${DIR}/package.json")" != "true" ]]; then
                MATRIX_PUBLISH_JSON+=", \"test\": \"true\""
              fi

              if [ ! -z "$(jq  '. | select( has("build") == true )' <<< "$scripts")" ]; then
                MATRIX_PUBLISH_JSON+=", \"build\": \"true\""
              fi

              name="$(jq .name "${DIR}/package.json" | sed -E 's/(^"|"$)//g')"
              current_version="$(jq .version "${DIR}/package.json" | sed -E 's/(^"|"$)//g')"
              npm_json="$(curl --retry 3 -s "https://registry.npmjs.org/${name}/${current_version}")"
              if [[ $npm_json == "\"version not found: ${current_version}\"" ]] || [[ $npm_json == "\"Not Found\"" ]]; then

                if [ "$(awk -F. '{print $1}' <<<$current_version)" -gt "0" ]; then
                  MATRIX_PUBLISH_JSON+=", \"publish\": \"true\""
                else
                  echo "::notice title=${PACKAGE}::Version ${current_version} is under 1.0.0 and is not going to be published"
                fi

                if [ ! -z "$(jq  '. | select( has("datagrok-api") == true )' <<< "$dependencies")" ]; then
                  MATRIX_PUBLISH_JSON+=", \"install_jsapi\": \"true\""
                fi
                if [ ! -z "$(jq  '. | select( has("datagrok-tools") == true )' <<< "$dependencies")" ]; then
                  MATRIX_PUBLISH_JSON+=", \"install_tools\": \"true\""
                fi
              fi

              MATRIX_PUBLISH_JSON+="}"
            fi
          done

          MATRIX_PUBLISH_JSON="${MATRIX_PUBLISH_JSON//\}\{/\}, \{}"
          MATRIX_PUBLISH_JSON+="]"

          PUBLISH_JSON="{\"include\": ${MATRIX_PUBLISH_JSON}}"

          CONTINUE_PUBLISH_JOB="no"
          if [[ "${MATRIX_PUBLISH_JSON}" != "[]" ]]; then
            CONTINUE_PUBLISH_JOB="yes"

            echo 'Result GitHub Actions Matrix JSON'
            echo "${MATRIX_PUBLISH_JSON}"
          fi
          echo "publish=${CONTINUE_PUBLISH_JOB}" >> $GITHUB_OUTPUT
          echo "matrix_publish=${PUBLISH_JSON}" >> $GITHUB_OUTPUT

  publish:
    name: Test and publish to npm
    needs:
      - matrix
    if: needs.matrix.outputs.publish == 'yes'
    runs-on: ubuntu-20.04
    env:
      HOST: GitHubAction
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.matrix.outputs.matrix_publish) }}
    outputs:
      push: ${{ steps.info.outputs.push }}
    steps:
      - uses: actions/checkout@v3
        with:
          token: ${{ secrets.WRITE_TOKEN }}
      - name: Check package properties
        id: check
        working-directory: packages/${{ matrix.package }}
        run: |
          if [ -z "$(jq '. | select( has("repository") == true ).repository' package.json)" ]; then
            echo "::error title=${{ matrix.package }}: failed properties check::Add repository property to ${{ matrix.package }}/package.json"
            exit 1
          fi
          if [[ "$(jq '.name' package.json | sed -E 's/(^"|"$)//g')" != "@datagrok/"* ]]; then
            echo "::error title=${{ matrix.package }}: failed properties check::Package should be in '@datagrok' scope. Change package name to '@datagrok/<name>' in ${{ matrix.package }}/package.json"
            exit 1
          fi
          if [ ! -z "$(jq '. | select( has("beta") == true ).beta' package.json)" ]; then
            echo "::error title=${{ matrix.package }}: failed properties check::Remove beta property in ${{ matrix.package }}/package.json. It is deprecated."
            exit 1
          fi
      - name: Run datagrok stand
        id: datagrok-image
        if: ${{ matrix.test == 'true' }}
        env:
          DATAGROK_VERSION: 'bleeding-edge'
        run: |
          commit_sha=$(echo ${{ github.sha }} | cut -c1-8)
          echo "commit_sha=$commit_sha" >> $GITHUB_OUTPUT
          grok_deps="$(jq  -r '. | select( has("grokDependencies") == true ).grokDependencies | to_entries[] | .key' packages/${{ matrix.package }}/package.json)"
          profiles='--profile datagrok --profile db --profile grok_spawner'
          if [[ "$(tr '[:upper:]' '[:lower:]' <<<${{ matrix.package }})" == "chem" ]] || \
             [[ "$(tr '[:upper:]' '[:lower:]' <<<${{ matrix.package }})" == "simpkpd" ]] || \
             [[ "$(tr '[:upper:]' '[:lower:]' <<<${{ matrix.package }})" == "dendrogram" ]] || \
             [[ "$(tr '[:upper:]' '[:lower:]' <<<${{ matrix.package }})" == "chembl" ]] || \
             [[ "$(tr '[:upper:]' '[:lower:]' <<<${grok_deps})" == *"chem"* ]] || \
             [[ "$(tr '[:upper:]' '[:lower:]' <<<${grok_deps})" == *"chembl"* ]] || \
             [[ "$(tr '[:upper:]' '[:lower:]' <<<${grok_deps})" == *"simpkpd"* ]] || \
             [[ "$(tr '[:upper:]' '[:lower:]' <<<${grok_deps})" == *"dendrogram"* ]]; then
            profiles+=' --profile cvm'
          fi

          docker-compose -p datagrok -f "docker/localhost.docker-compose.yaml" ${profiles} up -d
          docker_sha=$(docker images --quiet datagrok/datagrok:bleeding-edge)
          echo "docker_sha=$docker_sha" >> $GITHUB_OUTPUT
          echo "::notice title=${{ matrix.package }}::datagrok/datagrok:bleeding-edge SHA=$docker_sha docker version was used for tests"
      - name: Setup Node
        uses: actions/setup-node@v3
        with:
          node-version: '18.x'
          registry-url: 'https://registry.npmjs.org'
          scope: '@datagrok'
      - name: Upgrade npm
        run: npm install -g npm@x
      - name: npm version
        run: npm version
      - run: npm install
        id: install
        working-directory: packages/${{ matrix.package }}
      - name: js-api dependencies
        run: npm install
        working-directory: ./js-api
        if: ${{ matrix.install_jsapi == 'true' }}
      - name: tools dependencies
        run: npm install
        working-directory: ./tools
        if: ${{ matrix.install_tools == 'true' }}
      - name: Build package
        if: ${{ matrix.build == 'true' }}
        id: build
        run: npm run build
        working-directory: packages/${{ matrix.package }}
      - name: Install datagrok tools
        if: ${{ matrix.test == 'true' }}
        run: npm install -g datagrok-tools@latest
      - name: Wait for Datagrok to become available
        if: ${{ matrix.test == 'true' }}
        timeout-minutes: 5
        run: |
          while curl -s http://localhost:8080/api/admin/health | grep -e 'ApiError'
          do
            sleep 1
          done
      - name: Create configuration for grok command-line tool
        if: ${{ matrix.test == 'true' }}
        run: |
          echo 'N' | grok config add --default --alias ${HOST} --server 'http://localhost:8080/api' --key admin
          cat /home/runner/.grok/config.yaml
      - name: Install Grok Dependencies before package publish to Datagrok
        if: ${{ matrix.test == 'true' }}
        run: |
          grok_deps="$(jq  -r '. | select( has("grokDependencies") == true ).grokDependencies | to_entries[] | .key' package.json)"
          for dep in $grok_deps; do
            current_dir=$(pwd);
            cd ../;
            dep_dir=$(grep -l "\"name\": \"$dep\"" */package.json | xargs -I {} dirname {});
            cd $dep_dir;
            npm install;
            npm run build;
            count=0
            retries=5
            until grok publish ${HOST}; do
              exit=$?
              wait=$((2 ** count))
              count=$((count + 1))
              if [ $count -lt "$retries" ]; then
                echo "Retry $count/$retries exited $exit, retrying 'grok publish ${HOST}' in $wait seconds..."
                sleep $wait
                git pull --rebase
              else
                echo "Retry $count/$retries exited $exit, no more retries left for 'grok publish ${HOST}'."
                exit $exit
              fi
            done
            cd $current_dir;
          done
        working-directory: packages/${{ matrix.package }}
      - name: Publish package to Datagrok
        if: ${{ matrix.test == 'true' }}
        run: |
          count=0
          retries=5
          until grok publish ${HOST}; do
            exit=$?
            wait=$((2 ** count))
            count=$((count + 1))
            if [ "$count" -lt "$retries" ]; then
              echo "Retry $count/$retries exited $exit, retrying 'grok publish ${HOST}' in $wait seconds..."
              sleep $wait
            else
              echo "Retry $count/$retries exited $exit, no more retries left for 'grok publish ${HOST}'."
              exit $exit
            fi
          done
        working-directory: packages/${{ matrix.package }}
      - name: Test Package
        if: ${{ matrix.test == 'true' }}
        continue-on-error: ${{ matrix.package == 'ApiTests' }}
        timeout-minutes: 15
        id: test-package
        run: npm run test -- --skip-build --skip-publish
        working-directory: packages/${{ matrix.package }}
      - name: Create error notification
        if: failure() && steps.test-package.outcome == 'failure'
        run: |
          echo "::error title=${{ matrix.package }}: failed tests with datagrok:bleeding-edge SHA=${{ steps.datagrok-image.outputs.docker_sha }}::Check test-${{ matrix.package }}-${{ steps.datagrok-image.outputs.docker_sha }}-${{ steps.datagrok-image.outputs.commit_sha }}.html report for results"
          echo "status=error" >> $GITHUB_OUTPUT

      - name: Upload Artifact
        if: always() && (steps.test-package.outcome == 'failure' || steps.test-package.outcome == 'success')
        uses: actions/upload-artifact@v2
        with:
          name: test-${{ matrix.package }}-${{ steps.datagrok-image.outputs.docker_sha }}-${{ steps.datagrok-image.outputs.commit_sha }}.html
          path: packages/${{ matrix.package }}/test-${{ matrix.package }}-${{ steps.datagrok-image.outputs.docker_sha }}-${{ steps.datagrok-image.outputs.commit_sha }}.html
          retention-days: 7

      - name: Check dockerfiles directory existence
        id: check_directory
        uses: andstor/file-existence-action@v2
        with:
          files: "packages/${{ matrix.package }}/dockerfiles"

      - name: Check if dockerfies directory is not empty
        id: check_empty_dir
        run: |
          if [ -z "$(ls -A  packages/${{ matrix.package }}/dockerfiles)" ]; then
            echo "dir_empty=true" >> $GITHUB_OUTPUT
          else
            echo "dir_empty=false" >> $GITHUB_OUTPUT
          fi

      - name: Check if the dockerfiles directory has changes
        if: matrix.publish != 'true'
        id: directory_changes_checker
        uses: georgeneto/directory-changes-checker@v1
        with:
          repo-token: ${{secrets.GITHUB_TOKEN}}
          directory: "packages/${{ matrix.package }}/dockerfiles"

      - name: Get docker image version
        if: steps.check_directory.outputs.files_exists == 'true' && steps.check_empty_dir.outputs.dir_empty == 'false' && (matrix.publish == 'true' || steps.directory_changes_checker.output.hasChanges == 'true')
        id: docker_name_ver
        working-directory: packages/${{ matrix.package }}
        run: |
          image_ver=$(jq -r .version package.json)
          if [[ "${{ matrix.publish }}" != "true" ]]; then
            image_ver+="-${{ steps.datagrok-image.outputs.commit_sha }}"
          fi
          echo "image_ver=$image_ver" >> $GITHUB_OUTPUT
          echo "package_name=$(jq -r .name package.json | sed -e 's,@datagrok/,,g')" >> $GITHUB_OUTPUT

      - name: Build package Docker image
        if: steps.check_directory.outputs.files_exists == 'true' && steps.check_empty_dir.outputs.dir_empty == 'false' && (matrix.publish == 'true' || steps.directory_changes_checker.output.hasChanges == 'true')
        id: build-docker
        uses: docker/build-push-action@v3
        with:
          context: packages/${{ matrix.package }}/dockerfiles
          load: true
          tags: datagrok/${{ steps.docker_name_ver.outputs.package_name }}:${{ steps.docker_name_ver.outputs.image_ver }}

      - name: Publish to npm
        run: npm publish --access public
        id: publish
        working-directory: packages/${{ matrix.package }}
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
        if: github.ref == 'refs/heads/master' && matrix.publish == 'true' && (steps.build.outcome == 'success' || steps.build.outcome == 'skipped') && steps.check.outcome == 'success' && steps.install.outcome == 'success' && (steps.test-package.outcome == 'success' || steps.test-package.outcome == 'skipped' || matrix.package == 'ApiTests')

      - name: Upload Docker image as artifact
        if: steps.build-docker.outcome == 'success' && (steps.publish.outcome == 'failure' || steps.publish.outcome == 'skipped')
        uses: ishworkh/docker-image-artifact-upload@v1
        with:
          image: "datagrok/${{ steps.docker_name_ver.outputs.package_name }}:${{ steps.docker_name_ver.outputs.image_ver }}"

      - name: Login to DockerHub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
        if: steps.publish.outcome == 'success' && steps.build-docker.outcome == 'success'

      - name: Build and push package Docker image
        if: steps.publish.outcome == 'success' && steps.build-docker.outcome == 'success'
        uses: docker/build-push-action@v3
        with:
          context: packages/${{ matrix.package }}/dockerfiles
          push: true
          tags: datagrok/${{ steps.docker_name_ver.outputs.package_name }}:${{ steps.docker_name_ver.outputs.image_ver }}

      - name: Commit package-lock.json
        id: git
        continue-on-error: true
        if: steps.publish.outcome == 'success'
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          git pull
          continue=false
          if [ -n "$(git status -s packages/${{ matrix.package }}/package-lock.json)" ]; then
            git add packages/${{ matrix.package }}/package-lock.json
            git commit -m "GitHub Actions: Update packages/${{ matrix.package }}/package-lock.json [skip ci]"
            continue=true
          fi
          if [[ "${continue}" == "true" ]]; then
            count=0
            retries=10
            until git push; do
              exit=$?
              wait=$((2 ** count))
              count=$((count + 1))
              if [ $count -lt "$retries" ]; then
                echo "Retry $count/$retries exited $exit, retrying 'git push' in $wait seconds..."
                sleep $wait
                git pull --rebase
              else
                echo "Retry $count/$retries exited $exit, no more retries left for 'git push'."
                exit $exit
              fi
            done
          fi
