/* Do not change these import lines to match external modules in webpack configuration */
import * as grok from 'datagrok-api/grok';
import * as ui from 'datagrok-api/ui';
import * as DG from 'datagrok-api/dg';

export const _package = new DG.Package();

//name: info
export function info() {
  grok.shell.info(_package.webRoot);
}

//tags: init
export async function init() {
  //await initFib();
}

//name: fib1
//input: int num = 44
export async function fib1(num) {
  (async () => {
    const fetchPromise = fetch(new URL('../fibs/fib.wasm', import.meta.url));
    const module = await WebAssembly.compileStreaming(fetchPromise);
    const instance = await WebAssembly.instantiate(module);
    
    const func = instance.exports.fib; // this is the function required
    
    alert(func(num));
  })();  
}

//name: fib2
//input: int num = 44
export async function fib2(num) {
 // alert(Fib._fib(num));
}

//name: fib3
//input: int num = 24
export async function fib3(num) {
  // An attempt to apply JS-code generated by Emscripten
  // This doesn't work!
  // Wasm is created using basic flags of Emscripten
  //   emcc fib.c -o fib.js -sMODULARIZE -sEXPORTED_RUNTIME_METHODS=ccall -sENVIRONMENT=web,worker  

  const worker = new Worker(new URL('./worker.js', import.meta.url));  

  worker.postMessage(num);

  worker.onmessage = function(e) {  
    alert(e.data);
  }
}

//name: fib4
//input: int num = 24
export async function fib4(num) {  
  // An attempt to us an approach from https://medium.com/@c.gerard.gallant/webassembly-web-workers-f2ba637c3e4a
  // THIS DOESN'T WORK!

  /*var g_WebWorker = new Worker(new URL('./workerByGal.js', import.meta.url));            
                                     
  // Request the wasm file from the server and compile it...
  // (Typically we would call 'WebAssembly.instantiate' which
  // compiles and instantiates the module. In this case,
  // however, we just want the compiled module which will be
  // passed to the Web Worker. The Web Worker will be
  // responsible for instantiating the module.)         
  fetch(new URL('../fibCpp/fib.wasm', import.meta.url) ).then(response =>
    response.arrayBuffer()
    ).then(bytes =>
      WebAssembly.compile(bytes)
      ).then(WasmModule =>
        g_WebWorker.postMessage({ "MessagePurpose": "CompiledModule", "WasmModule": WasmModule })
  );  

  g_WebWorker.onmessage = function (evt) {
    alert(`Message from the Web Worker:\n\n ${evt.data}`);
  }

  g_WebWorker.postMessage(num);

  g_WebWorker.onmessage = function(e) {  
    alert(e.data);
  }*/

  /*const worker = new Worker(new URL('./workerByGal.js', import.meta.url));

  fetch(new URL('../fibs/fib.wasm', import.meta.url))
  .then((response) => response.arrayBuffer())
  .then((bytes) => WebAssembly.compile(bytes))
  .then((mod) => worker.postMessage({'mod': mod, num: 'num'}));

  worker.onmessage = function(e) {  
    alert(e.data);
  }*/

  const importObject = { imports: { imported_func: (arg) => console.log(arg) } };

WebAssembly.compileStreaming(fetch(new URL('../fibCpp/fib.wasm', import.meta.url)))
  .then((module) => WebAssembly.instantiate(module, importObject))
  .then((instance) => instance.exports.fib(num))
  .then((res) => console.log(res));
}

//name: fib5
//input: int num = 10
export async function fib5(num) {
  // Here is an attempt to use JS-code generated by Emscripten as a worker!
  // It doesn't work!

  const worker = new Worker(new URL('../try/TRY.js', import.meta.url));  

  worker.postMessage(num);

  worker.onmessage = function(e) {  
    alert(e.data);
  }  
}

//name: fib6
//input: int num = 10
export async function fib6(num) {
  // THIS WORKS!
  // The following command is used:
  //    em++ try.cpp -o TRY.js -s TOTAL_MEMORY=268435456 -s WASM=1 -s ALLOW_MEMORY_GROWTH=1 -s MODULARIZE=1 -s EXPORT_NAME="TRY" -s EXPORTED_FUNCTIONS=["_fib","_malloc","_free"] -s EXPORTED_RUNTIME_METHODS=["cwrap","ccall"] -sENVIRONMENT=web,worker

  const worker = new Worker(new URL('../tryAnother/worker.js', import.meta.url));  

  worker.postMessage(num);

  worker.onmessage = function(e) {  
    alert(e.data);
  }  
}

//name: fibWW
//input: int num = 44
export async function fibWW(num) {
  
  // This works!
  // Wasm is created using basic flags of Emscripten

  const worker = new Worker(new URL('../fibs/worker.js', import.meta.url));  

  worker.postMessage(num);

  worker.onmessage = function(e) {  
    alert(e.data);
  } 
}

//name: sum
export async function sum() {  
  // This works!
  // Wasm is created using basic flags of Emscripten

  const worker = new Worker(new URL('../sum/worker.js', import.meta.url));
  
  let arr = new Int32Array([1,2,3,4,5,6]);

  worker.postMessage(arr);

  worker.onmessage = function(e) {  
    alert(e.data);
  } 
}

//name: doubleArr
export async function doubleArr() {  
  // This works!
  // Wasm is created using basic flags of Emscripten

  const worker = new Worker(new URL('../double/worker.js', import.meta.url));
  
  let arr = new Int32Array([1,2,3,4,5,6]);

  console.log(arr);

  worker.postMessage(arr);

  worker.onmessage = function(e) {  
    console.log(e.data);
  } 
}

