// This is a demo-package that illustartes wasm-functions call:
// in the main stream and in webworkers. 

/* Do not change these import lines to match external modules in webpack configuration */
import * as grok from 'datagrok-api/grok';
import * as ui from 'datagrok-api/ui';
import * as DG from 'datagrok-api/dg';

export const _package = new DG.Package();

//name: info
export function info() {
  grok.shell.info(_package.webRoot);
}

// Imports for call wasm runtime-system: in the main stream and in webworkers 
import { callWasm } from '../wasm/callWasm';
import {getCppInput, getResult} from '../wasm/callWasmUtils';

//tags: init
export async function init() {

  // The following provides further usage of the object Lib generated by Emscripten.  
  // Note that 'Lib.js' should be included to 'sources' in the file 'package.json'.
  await initLib();

  // The following provides further usage of the object Analyzer generated by Emscripten.  
  // Note that 'Analyzer.js' should be included to 'sources' in the file 'package.json'.
  await initAnalyzer();
}


// 1. TYPICAL EXAMPLES

// Below, a set of functions pairs is considered: 
//   - first, all computations are performed in the main stream;
//   - next, the corresponding function, which performes computations
//     in webworker, is given.
// 
// REMARK. A detailed comments are given just in the function 'sumInWebWorker'.
//         In other functions, the same approach is used.

//name: sum
//input: int a = 11
//input: int b = 89
//output: int res 
export function sum(a, b) {
  return callWasm(Lib, 'sum', [a, b]);
}

//name: sumInWebWorker
//input: int a = 1012
//input: int b = 99
export function sumInWebWorker(a, b) {

   // web worker declaration
   var worker = new Worker(new URL('../wasm/workerSum.js', import.meta.url));              

   // post function specification & inputs
   worker.postMessage(getCppInput(Lib['sum'].arguments, [a, b]));       

   worker.onmessage = function(e) { 
    
     // get results of wasm-computations 
     let output = getResult(Lib['sum'], e.data);

     // Here must be some UI
     alert(`${a} + ${b} = ${output}`);
   }
}

//name: maxFloatCol
//input: dataframe df
//input: column col
//output: double max 
export function maxFloatCol(df, col) {
  return callWasm(Lib, 'maxFloatCol', [col]);
}

//name: maxFloatColInWebWorker
//input: dataframe df
//input: column col
export function maxFloatColInWebWorker(df, col) {
  var worker = new Worker(new URL('../wasm/workerMaxFloatCol.js', import.meta.url));              

  worker.postMessage(getCppInput(Lib['maxFloatCol'].arguments, [col]));       

  worker.onmessage = function(e) { 

    let output = getResult(Lib['maxFloatCol'], e.data);

    // Here must be some UI
    alert(`Max of the column '${col.name}' of the dataframe '${df.name}' is ${output}`);
  }
}

//name: maxIntCol
//input: dataframe df
//input: column col
//output: int max 
export function maxIntCol(df, col) {
  return callWasm(Lib, 'maxIntCol', [col]);
}

//name: maxIntColInWebWorker
//input: dataframe df
//input: column col 
export function maxIntColInWebWorker(df, col) {
  var worker = new Worker(new URL('../wasm/workerMaxIntCol.js', import.meta.url));              

  worker.postMessage(getCppInput(Lib['maxIntCol'].arguments, [col]));       

  worker.onmessage = function(e) { 

    let output = getResult(Lib['maxIntCol'], e.data);

    // Here must be some UI
    alert(`Max of the column '${col.name}' of the dataframe '${df.name}' is ${output}`);
  }
}

//name: addFloatCols
//input: dataframe df
//input: column col1
//input: column col2
export function addFloatCols(df, col1, col2) {
  let res = callWasm(Lib, 'addFloatCols', [col1, col2]);  
  res.name = `sum of ${col1.name} and ${col2.name}`;
  df.columns.add(res);
}

//name: addFloatColsInWebWorker
//input: dataframe df
//input: column col1
//input: column col2
export function addFloatColsInWebWorker(df, col1, col2) {
  var worker = new Worker(new URL('../wasm/workerAddFloatCols.js', import.meta.url));              

  worker.postMessage(getCppInput(Lib['addFloatCols'].arguments, [col1, col2]));       

  worker.onmessage = function(e) { 

    let output = getResult(Lib['addFloatCols'], e.data);

    // Here must be some UI
    output.name = `sum of ${col1.name} and ${col2.name}`;
    df.columns.add(output);    
  }
}

//name: addIntCols
//input: dataframe df
//input: column col1
//input: column col2
export function addIntCols(df, col1, col2) {
  let res = callWasm(Lib, 'addIntCols', [col1, col2]);  
  res.name = `sum of ${col1.name} and ${col2.name}`;
  df.columns.add(res);
}

//name: addIntColsInWebWorker
//input: dataframe df
//input: column col1
//input: column col2
export function addIntColsInWebWorker(df, col1, col2) {
  var worker = new Worker(new URL('../wasm/workerAddIntCols.js', import.meta.url));              

  worker.postMessage(getCppInput(Lib['addIntCols'].arguments, [col1, col2]));       

  worker.onmessage = function(e) { 

    let output = getResult(Lib['addIntCols'], e.data);

    // Here must be some UI
    output.name = `sum of ${col1.name} and ${col2.name}`;
    df.columns.add(output);    
  }
}

//name: doubledInts
//input: dataframe table
//input: column_list cols
//output: dataframe result 
export function doubledInts(table, cols) {
  let res = callWasm(Lib, 'doubledInts', [cols]);
  res.name = 'Doubled_ints';
  return res;
}

//name: doubledIntsInWebWorker
//input: dataframe table
//input: column_list cols
export function doubledIntsInWebWorker(table, cols) {
  var worker = new Worker(new URL('../wasm/workerDoubledInts.js', import.meta.url));              

  worker.postMessage(getCppInput(Lib['doubledInts'].arguments, [cols]));       

  worker.onmessage = function(e) { 

    let output = getResult(Lib['doubledInts'], e.data);

    // Here must be some UI
    output.name = 'Doubled_ints';
    grok.shell.addTableView(output);
  }
}

//name: doubledFloats
//input: dataframe table
//input: column_list cols
//output: dataframe result 
export function doubledFloats(table, cols) {
  let res = callWasm(Lib, 'doubledFloats', [cols]);
  res.name = 'Doubled_floats';
  return res;
}

//name: doubledFloatsInWebWorker
//input: dataframe table
//input: column_list cols 
export function doubledFloatsInWebWorker(table, cols) {
  var worker = new Worker(new URL('../wasm/workerDoubledFloats.js', import.meta.url));              

  worker.postMessage(getCppInput(Lib['doubledFloats'].arguments, [cols]));       

  worker.onmessage = function(e) { 

    let output = getResult(Lib['doubledFloats'], e.data);

    // Here must be some UI
    output.name = 'Doubled_floats';
    grok.shell.addTableView(output);
  }
}


// 2. MORE COMPLEX EXAMPLES: Principal Component Analysis (PCA),
//                           Partial Least Square Regression (PLS).

//name: pca
//input: dataframe table
//input: column_list columns
//input: int componentsCount
//output: dataframe result 
export function pca(table, columns, componentsCount) {
  return callWasm(Analyzer, 'principalComponentAnalysis', [columns, componentsCount]);
}

//name: pcaInWebWorker
//input: dataframe table
//input: column_list columns
//input: int componentsCount
export function pcaInWebWorker(table, columns, componentsCount) {
  var worker = new Worker(new URL('../wasm/workerPCA.js', import.meta.url));              

  worker.postMessage(getCppInput(Analyzer['principalComponentAnalysis'].arguments, 
    [columns, componentsCount]));       

  worker.onmessage = function(e) { 

    let output = getResult(Analyzer['principalComponentAnalysis'], e.data);

    // Here must be some UI
    output.name = 'Principal components';
    grok.shell.addTableView(output);
  }
}

//name: pls
//input: dataframe table
//input: column_list features
//input: column predict
//input: int componentsCount
export function pls(table, features, predict, componentsCount) {
  let callOutput = callWasm(Analyzer, 'partialLeastSquareRegression', [features, predict, componentsCount]);

  // CREATING VISUALIZATION

  let start = new Date().getTime();
  
  let dfView = grok.shell.getTableView(table.name);

  // 1. Predicted vs Reference scatter plot

  let prediction = callOutput[0];
  prediction.name = predict.name + '(predicted)';

  let dfReferencePrediction = DG.DataFrame.fromColumns([predict, prediction]);
  dfReferencePrediction.name = 'Reference vs. Predicted';
  
  dfView.addViewer(DG.Viewer.scatterPlot(dfReferencePrediction, 
    { title: dfReferencePrediction.name,
      x: predict.name,
      y: prediction.name,
      showRegressionLine: true,
      markerType: 'circle'
     }));

  // 2. Regression Coefficients Bar Chart
  let regressionCoefficients = callOutput[1];
  regressionCoefficients.name = 'regression coefficient';

  let namesOfPredictors = [];
  for(let col of features)
    namesOfPredictors.push(col.name); 
  
  let  predictorNamesColumn = DG.Column.fromStrings('feature', namesOfPredictors);  

  let dfRegrCoefs = DG.DataFrame.fromColumns([predictorNamesColumn, regressionCoefficients]);
  dfRegrCoefs.name = 'Regression Coefficients';
    
  dfView.addViewer(DG.Viewer.barChart(dfRegrCoefs, 
    {title: dfRegrCoefs.name, split: 'feature', 
     value: 'regression coefficient', valueAggrType: 'avg'}));
  

  // 3. Scores Scatter Plot

  let scoresColumns = [];
  
  let xScores = callOutput[2];
  for(let i = 0; i < xScores.length; i++) {
    xScores[i].name = `x.score.t${i+1}`;
    scoresColumns.push(xScores[i]);
  }

  let yScores = callOutput[3];
  for(let i = 0; i < yScores.length; i++) {
    yScores[i].name = `y.score.u${i+1}`;
    scoresColumns.push(yScores[i]);
  }  

  let scores = DG.DataFrame.fromColumns(scoresColumns);
  scores.name = 'Scores';
  //grok.shell.addTableView(scores);

  dfView.addViewer(DG.Viewer.scatterPlot(scores, 
    { title: scores.name,
      x: xScores[0].name,
      y: yScores[0].name,      
      markerType: 'circle'
     }));

  // 4. Loading Scatter Plot
  let loadingCols = [];

  let loadingLabels = [];
  for(let col of features)
    loadingLabels.push(col.name);

  loadingCols.push(DG.Column.fromStrings('labels', loadingLabels));

  let xLoadings = callOutput[4];
  for(let i = 0; i < xLoadings.length; i++) {
    xLoadings[i].name = `x.loading.p${i+1}`;
    loadingCols.push(xLoadings[i]);
  }

  let dfLoadings = DG.DataFrame.fromColumns(loadingCols);
  dfLoadings.name = 'Loadings';
  
  dfView.addViewer(DG.Viewer.scatterPlot(dfLoadings, 
    { title: dfLoadings.name,
      x: xLoadings[0].name,
      y: xLoadings[0].name,      
      markerType: 'circle',
      labels: 'labels'
     }));

  let finish = new Date().getTime();

  console.log(`Time for creating viewers is ${finish - start} ms.`);
}

//name: plsInWebWorker
//input: dataframe table
//input: column_list features
//input: column predict
//input: int componentsCount
export function plsInWebWorker(table, features, predict, componentsCount) {
  var worker = new Worker(new URL('../wasm/workerPLS.js', import.meta.url));              

  worker.postMessage(getCppInput(Analyzer['partialLeastSquareRegression'].arguments, 
    [features, predict, componentsCount]));       

  worker.onmessage = function(e) { 

    let output = getResult(Analyzer['partialLeastSquareRegression'], e.data);

    // BELOW, WE PROVIDE AN APPROPRAITE UI

    let dfView = grok.shell.getTableView(table.name);

    // 1. Predicted vs Reference scatter plot
  
    let prediction = output[0];
    prediction.name = predict.name + '(predicted)';
  
    let dfReferencePrediction = DG.DataFrame.fromColumns([predict, prediction]);
    dfReferencePrediction.name = 'Reference vs. Predicted';

    //grok.shell.addTableView(dfReferencePrediction);
    
    dfView.addViewer(DG.Viewer.scatterPlot(dfReferencePrediction, 
      { title: dfReferencePrediction.name,
        x: predict.name,
        y: prediction.name,
        showRegressionLine: true,
        markerType: 'circle'
       }));

    // 2. Regression Coefficients Bar Chart
    let regressionCoefficients = output[1];
    regressionCoefficients.name = 'regression coefficient';

    let namesOfPredictors = [];
    for(let col of features)
    namesOfPredictors.push(col.name); 
  
    let  predictorNamesColumn = DG.Column.fromStrings('feature', namesOfPredictors);  

    let dfRegrCoefs = DG.DataFrame.fromColumns([predictorNamesColumn, regressionCoefficients]);
    dfRegrCoefs.name = 'Regression Coefficients';
    
    dfView.addViewer(DG.Viewer.barChart(dfRegrCoefs, 
      {title: dfRegrCoefs.name, split: 'feature', 
       value: 'regression coefficient', valueAggrType: 'avg'}));
  

    // 3. Scores Scatter Plot

    let scoresColumns = [];
  
    let xScores = output[2];
    for(let i = 0; i < xScores.length; i++) {
      xScores[i].name = `x.score.t${i+1}`;
      scoresColumns.push(xScores[i]);
    }

    let yScores = output[3];
    for(let i = 0; i < yScores.length; i++) {
      yScores[i].name = `y.score.u${i+1}`;
      scoresColumns.push(yScores[i]);
    }  

    let scores = DG.DataFrame.fromColumns(scoresColumns);
    scores.name = 'Scores';    

    dfView.addViewer(DG.Viewer.scatterPlot(scores, 
      { title: scores.name,
        x: xScores[0].name,
        y: yScores[0].name,      
        markerType: 'circle'
      }));
  
    // 4. Loading Scatter Plot
    let loadingCols = [];

    let loadingLabels = [];
    for(let col of features)
      loadingLabels.push(col.name);

    loadingCols.push(DG.Column.fromStrings('labels', loadingLabels));

    let xLoadings = output[4];
    for(let i = 0; i < xLoadings.length; i++) {
      xLoadings[i].name = `x.loading.p${i+1}`;
      loadingCols.push(xLoadings[i]);
    }

    let dfLoadings = DG.DataFrame.fromColumns(loadingCols);
    dfLoadings.name = 'Loadings';
  
    dfView.addViewer(DG.Viewer.scatterPlot(dfLoadings, 
      { title: dfLoadings.name,
        x: xLoadings[0].name,
        y: xLoadings[0].name,      
        markerType: 'circle',
        labels: 'labels'
      }));

  }
}

